<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0" ns="http://ruleml.org/spec" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                Spatio-Temporal Derivation Rule (DR)
            dialect of Reaction RuleML         This layer defines the spatio-temporal Derivation
            Rule dialect of Reaction RuleML.    It adds necessary extensions to the RuleML Horn
            Logic layer with equality for    the spatio-temporal Derivation Rule dialect.
            File: dr.xsd    Version: 1.0    Last Modification: 2011-03-22        This schema
            declares the following Reaction RuleML elements and attributes:                        *
            rename Implies into Rule (if-then-else)       * extends RuleML by adding meta, scope,
            guard, evaluation, signature, qualification, quantification        * extends Assert,
            Retract by adding Rule, Negation, Neg, Time, Spatial, Interval,  meta, scope, guard,
            evaluation, signature, qualification, quantification,  @safety and @size       * extends
            Query by adding Negation, Naf, Neg Time, Spatial, Interval, meta, scope, guard,
            evaluation, signature, qualification, quantification                   * extends
            Rulebase by adding Rule, Negation, Neg, Time, Spatial, Interval, meta, scope, guard,
            evaluation, signature, qualification, quantification        * extends if and then by
            adding Time, Spatial, Interval       * extends Atom by adding meta, scope, guard,
            evaluation, signature, qualification, quantification, Time, Spatial, Interval        *
            extends Expr, Plex by adding meta, scope, guard, evaluation, signature, qualification,
            quantification and Time, Spatial, Interval       * extends slot by adding Time, Spatial,
            Interval       * extends oid by adding Time, Spatial, Interval       * extends Var by
            adding @mode (input / output mode declaration)                         * extends Rel by
            adding @per        * extends And/Or by adding Negation, Neg, Naf, Rule       * extends
            torso by  Negation, Neg, Naf        * extends @type to be of type
            termOrCurieOrIRI.datatype       * add Negation, Neg, Naf        * add Time, Interval,
            Spatial       * add Quantifier, Forall, Exists (quantification)        * add @key,
            @keyref (with key and keyref of type curieORAbsIRI)      Rule is the core construct for
            all types of rules in Reaction RuleML.        
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">DR Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">spatio-temporal Derivation Rule dialect of Reaction
                RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!-- includes the datalog layer of deliberation ruleml -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML performatives.
            File:       performative_module.xsd Version: 1.0 Last Modification: 2011-09-26 This
            module declares the       following RuleML elements: * RuleML * Assert * Retract * Query
            * act * formula See       http://www.ruleml.org/modularization for details about this
            modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-09-26T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** RuleML ***
		The n-ary top-level of a RuleML document.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-RuleML
		
	 the DR schema redefines the RuleML element
	 and adds meta, evaluation, signature, qualification, quantification, and scope so that the content model is:
	 
	( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Assert | Retract | Query)* )

 	 Note: key and keyref object identifier are defined to be unique under the RuleML document root
				
	-->
    <rng:define name="RuleML.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="RuleML.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="act"/>
                <rng:ref name="Assert"/>
                <rng:ref name="Retract"/>
                <rng:ref name="Query"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="RuleML.type">
        <rng:ref name="RuleML.content"/>
        <rng:ref name="RuleML.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="RuleML"/>
</rng:start>
<rng:define name="RuleML">
<rng:element name="RuleML">
<rng:ref name="RuleML.type"/>
        <!-- key object identifiers and key object references defined on the top level -->
        
            
            
        
        
            
            
        
    </rng:element>
</rng:define>
    <!--
    *** act ***
    The act role of the root element (<RuleML>).
    
    See http://www.ruleml.org/1.0/glossary/#gloss-act
    
    content model  (Assert|Retract|Query)
    
  -->
    <rng:define name="act.content">
        <rng:choice>
            <rng:ref name="Assert"/>
            <rng:ref name="Retract"/>
            <rng:ref name="Query"/>
        </rng:choice>
    </rng:define>
    <rng:define name="act.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="act.type">
        <rng:ref name="act.content"/>
        <rng:ref name="act.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="act"/>
</rng:start>
<rng:define name="act">
<rng:element name="act">
<rng:ref name="act.type"/>
</rng:element>
</rng:define>
    <!--
		*** Assert ***
		A KQML-like performative acting as a wrapper specifying that its content is
		asserted, making an 'implicit <Rulebase>' assumption.

		See http://www.ruleml.org/1.0/glossary/#gloss-Assert 

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )*)	
	-->
    <rng:define name="Assert.attlist">
        <rng:ref name="mapDirection.attrib"/>
        <rng:ref name="mapClosure.attrib"/>
        <rng:ref name="mapMaterial.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
        <rng:ref name="safety.attrib"/>
        <rng:ref name="size.attrib"/>
    </rng:define>
    <rng:define name="Assert.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                <rng:ref name="formula-assert.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Assert.type">
        <rng:ref name="Assert.content"/>
        <rng:ref name="Assert.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Assert"/>
</rng:start>
<rng:define name="Assert">
<rng:element name="Assert">
<rng:ref name="Assert.type"/>
</rng:element>
</rng:define>
    <!--
		*** Retract ***
		A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
		content is to be deleted, making an 'implicit <Rulebase>' assumption.

		See http://www.ruleml.org/1.0/glossary/#gloss-Retract

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )*)
	-->
    <rng:define name="Retract.attlist">
        <rng:ref name="mapDirection.attrib"/>
        <rng:ref name="mapClosure.attrib"/>
        <rng:ref name="mapMaterial.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Retract.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                <rng:ref name="formula-assert.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Retract.type">
        <rng:ref name="Retract.content"/>
        <rng:ref name="Retract.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Retract"/>
</rng:start>
<rng:define name="Retract">
<rng:element name="Retract">
<rng:ref name="Retract.type"/>
</rng:element>
</rng:define>
    <!--
		*** Query ***
		A KQML-like performative acting as a wrapper specifying that its content is
		queried, making an 'implicit <Rulebase>' assumption.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Query 

		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Atom | Rulebase | And | Or | Entails | Exists | Quantifier | Equal | Negation | Neg | Naf | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Atom | Rulebase | And | Or | Entails | Exists | Quantifier | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )* )
	-->
    <rng:define name="Query.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Query.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-query.type"/>
</rng:element>
                <rng:ref name="formula-query.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Query.type">
        <rng:ref name="Query.content"/>
        <rng:ref name="Query.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Query"/>
</rng:start>
<rng:define name="Query">
<rng:element name="Query">
<rng:ref name="Query.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a performative (<Assert>, <Retract> or <Query>).

		See http://www.ruleml.org/1.0/glossary/#gloss-formula

		content model (below Assert): 
		DR Reaction RuleML (Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval )
		KR Reaction RuleML (Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval  | Event | Situation | Holds | Initiates | Terminates | Happens )
		
		content model (below Query): 
		DR Reaction RuleML (Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists | Quantifier | Time | Spatial | Interval )
		KR Reaction RuleML (Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists | Quantifier | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )


		Other (context-sensitive) versions of <formula> are in the
		connective and quantifier modules.
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <rng:define name="formula-assert.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="Implies"/>
            <rng:ref name="Rule"/>
            <rng:ref name="Equivalent"/>
            <rng:ref name="Entails"/>
            <rng:ref name="outer-quantifier.content"/>
            <rng:ref name="outer-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-query.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="Entails"/>
            <rng:ref name="query-connective.content"/>
            <rng:ref name="query-quantifier.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-assert.type">
        <rng:ref name="formula-assert.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-query.type">
        <rng:ref name="formula-query.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <!--<rng:include href="modules/xml_module.rng" ns="http://www.w3.org/XML/1998/namespace"/>-->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for description-related
            RuleML       elements. File: desc_module.xsd Version: 1.0 Last Modification: 2012-05-17
            [Adrian Paschke]       This module declares the following RuleML elements:
            * @node       * meta            descriptive metadata        * scope           scope
            (e.g. for scoped reasoning)        * guard         guard (e.g. for guard constraints in
            scoped reasoning)       * evaluation      semantic profile        * signature
            interface signature, pattern definition,       * qualification   qualification, e.g.
            priorities, validity, strategy       * quantification  quantification       * oid
            See       http://www.ruleml.org/modularization for details about this modularization
            approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-05-17T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
    *** @node ***
    An optional identification label for a Node, creating accessibility within
    the knowledge representation.
    This can help for representing prioritization between rules, for example. 
    The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
    such a label.
    
    See http://www.ruleml.org/1.0/glossary/#gloss-@node
    
    content model: xs:anyURI
  -->
    <rng:define name="node.attrib">
        <rng:optional>
<rng:attribute name="node">
<rng:data type="anyURI"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="oid.attlist"><rng:empty/></rng:define>
    <rng:define name="oid.content">
        <rng:choice>
            <rng:ref name="Ind"/>
            <rng:ref name="Data"/>
            <rng:ref name="Var"/>
            <rng:ref name="Skolem"/>
            <rng:ref name="Reify"/>
            <rng:ref name="Expr"/>
            <rng:element name="Plex">
<rng:ref name="Plex.type"/>
</rng:element>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="oid.type">
        <rng:ref name="oid.content"/>
        <rng:ref name="oid.attlist"/>
    </rng:define>
    <!--
  *** oid ***
  An optional object identifier for an atomic formula, expression or the unifed terms
  of the SWSL branch, as needed for PSOA semantics.
  Note that oids are not required to be unique within a rulebase.
  
  See http://www.ruleml.org/1.0/glossary/#gloss-oid
  
  content model: 
  in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
  in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
  -->
    <rng:start combine="choice">
<rng:ref name="oid"/>
</rng:start>
<rng:define name="oid">
<rng:element name="oid">
<rng:ref name="oid.type"/>
</rng:element>
</rng:define>
    <!-- 
 	
	@key @keyref @xml:id @xml:base
 
  @key and @keyref attributes for modularization of the knowledge base

  -->
    <rng:define name="xml.attlist">
        <rng:ref name="key.attrib"/>
        <rng:ref name="keyref.attrib"/>
        <rng:attribute name="base" ns="http://www.w3.org/XML/1998/namespace">
<rng:text/>
</rng:attribute>
        <rng:attribute name="id" ns="http://www.w3.org/XML/1998/namespace">
<rng:text/>
</rng:attribute>
    </rng:define>
    <!-- 
     *** meta ***     
     
    An optional container for meta-knowledge about a Node.
    
    See http://www.ruleml.org/1.0/glossary/#gloss-meta
    
	Used for descriptive Metadata annotations in Reaction RuleML
	
     content model: 
     in DR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval  )
     in KR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval | Event | Situation )
        
     Multiple Metadata annotations are possible by repreating <meta>
-->
    <rng:define name="meta.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="meta.content">
        <rng:choice>
            <rng:ref name="formula-assert.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="meta.type">
        <rng:ref name="meta.content"/>
        <rng:ref name="meta.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="meta"/>
</rng:start>
<rng:define name="meta">
<rng:element name="meta">
<rng:ref name="meta.type"/>
</rng:element>
</rng:define>
    <!--
     *** scope ***
     
     Note: scope of the rule, e.g. defining a constructive view on the rules and facts
     using the metadata annotations and the qualifications annotations. 
     The scoped rule/literal goal only applies in this scope (scoped reasoning/processing)
     
     For an implementation of scoped reasoning as a mechanism to dynamicaly create a scope (a constructive view)
     on the knowledge base and to do scoped reasoning on this scope see the Prova rule engine (http://prova.ws).
     
     Example:
     @src(kb1) @author("Adrian Paschke") @validity([2011-03-20, 2011-04-20]) @label(fact1) fact1(constant1).
     @src(kb2) @author("Alex Kozlenkov") @validity([2011-01-20, 2011-03-20]) @label(fact2) fact2(constant2).
     
     @src(rb1) @label(rule1) rule1(Y) :- @validity(VTime) @authors("Adrian Paschke") fact1(Y) [between(SysTime,VTime)] 
     
     In this example all knowledge is annotated with predefined (@src, ...) and user-defined metadata annotations (@author, @validity, ...). 
     User-defined metadata annotations can be arbitrary name/value pairs described as predicates. The literal "fact1" in the body
     of "rule1" is a scoped literal defining a scope over knowledge in the knowledge base with the scope constraints
     @validity and @author. If such knowledge is found in the KB the meta data value (an Interval) for @validity
     is bound to the variable "VTime" and used in the guard constraint [...] on the literal. The guard is stating that 
     the actual system time should be  within the validity interval. The second scope constraint is directly compared 
     to the constant value "Adrian Paschke".
     The sub-goal literal "fact1" in the rule condition is then applied only on the selected scope 
     (a constructive view on the overall knowledge base which is selected by the metadata scope of the literal) and not on the 
     overal knowledge. It is possible to define scopes for modules (e.g. sets of knowledge such as a rule-base/rule-set or 
     an knowledge updates (assert, retracts) by using the meta data identifier such as @src or @label. Such identifiers can
     be also used for transactional logics.
     
     In Reaction RuleML general metadata annotations (descriptive metadata) are defined under the <meta> tag role and
     qualifying metadata which qualify the rule (such as validity in the above example) are defined under the <qualification> tag.
     The @key attribute which defines a unique identifier for knowledge in the knowledge base is used for a 
     modular nested structuring of the knowledge base. The @key of e.g. <Assert key=""> or <Rulebase key=""> acts as module identifier 
     (which in Prova is denoted by the predefined @src metadata).
     
	 Scopes in Reaction RuleML can be defined within the <scope> role tag on descriptive metadata <meta> and qualifying metadata <qualification> as well as
	 on the unique identifier @key of the knowledge in the knowledge base (<Assert key="">, <Rulebase key="">, <Rule key="">, <Atom key="">)
	 by referencing it with the @keyref attribute.
	 
	 There is a nesting of scopes. Scopes defined on the more general level automatically apply to the inner knowledge. For instance, a scope
	 defined on the level of a <Rulebase> automatically applies to all goal literals of the <Rule>s in the rulebase. Inner scopes
	 overwrite the outer scope. For instance a scope defined on <Assert> becomes overwritten by an inner scope defined on a <Rule> which is within the
	 this asserted knowledge module. That is the goal literals within this rules are automatically applying the innter scope and not the outer scope.
	 
	 Note: the old approach which used <oid> to define a scope has been replaces by the key-keyref approach in Reaction RuleML 1.0
     
     Note: multiple scopes can be defined by repeating the <scope> role element
     Note: an empty scope either assumes the outer scope or an existing scope needs to be explicity referenced by keyref
     
     content model: ( (Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists | Quantifier | Time | Spatial | Interval)? )
          
-->
    <rng:define name="scope.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="scope.content">
        <rng:choice>
            <rng:optional>
<rng:ref name="formula-query.content"/>
</rng:optional>
        </rng:choice>
    </rng:define>
    <rng:define name="scope.type">
        <rng:ref name="scope.content"/>
        <rng:ref name="scope.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="scope"/>
</rng:start>
<rng:define name="scope">
<rng:element name="scope">
<rng:ref name="scope.type"/>
</rng:element>
</rng:define>
    <!--
     *** guard ***     
     
	guard constraints 
	
     content model: 
     in DR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
     in KR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation )
          
-->
    <rng:define name="guard.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="guard.content">
        <rng:choice>
            <rng:ref name="if.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="guard.type">
        <rng:ref name="guard.content"/>
        <rng:ref name="guard.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="guard"/>
</rng:start>
<rng:define name="guard">
<rng:element name="guard">
<rng:ref name="guard.type"/>
</rng:element>
</rng:define>
    <!--
     *** evaluation ***
     
     The intended evaluation semantics of the rule, 
     e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
     
     Note: multiple Profiles can be defined by repreating the <evaluation> role element
     The Profiles can be defined externally by using the Profile attributes to point to it or internally by defining it in XML (xs:any)
     
     content model: (Profile )     -->
    <rng:define name="evaluation.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="evaluation.content">
        
            <rng:ref name="Profile"/>
        
    </rng:define>
    <rng:define name="evaluation.type">
        <rng:ref name="evaluation.content"/>
        <rng:ref name="evaluation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="evaluation"/>
</rng:start>
<rng:define name="evaluation">
<rng:element name="evaluation">
<rng:ref name="evaluation.type"/>
</rng:element>
</rng:define>
    <!--
     *** signature ***
     
     The signature defines the signature with optional input / output mode declarations. The signature declaration can act as public interface and
	can be published together with the intended evaluation semantics. 
	
	Note: In PR, RR and CEP reaction rules the signature is extended with events and actions
	for defining the event templates (i.e. the event form / event descriptor which corresponds to the event type/class. The event template is used for
	pattern machting, i.e. in the on part of a reaction rule it triggers the reaction rule if the template matches with required event instances, which are
	instantiations of the event type / class to which make up the required properties of the event template.
	
	In backward-reasoning derivation rules the signature interface description defines a query template for the head of the rule. 
	In forward-(reasoning) reaction rules the signature interface description  defines the event template for the event pattern matching which triggers the rules.  
	
	Multiple signatures are possible by repreating the <signature> element
	
     content model: 
     in DR Reaction RuleML: ( Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists | Quantifier | Time | Spatial | Interval )
     in KR Reaction RuleML: ( Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists | Quantifier | Time | Spatial | Interval | Event | Situation )
          
-->
    <rng:define name="signature.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="signature.content">
        <rng:choice>
            <rng:ref name="formula-query.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="signature.type">
        <rng:ref name="signature.content"/>
        <rng:ref name="signature.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="signature"/>
</rng:start>
<rng:define name="signature">
<rng:element name="signature">
<rng:ref name="signature.type"/>
</rng:element>
</rng:define>
    <!--
     *** qualification ***
     
    Definition of the rule's qualification (qualifying metadata), e.g. validity time of the rule, priorities, etc.
     
    Note: the qualification can be also defined as a situation  <Situation> 
	A situation could be also modelled as a changeable situation called fluent (in the KR dialect of Reaction RuleML),
	which changes its truth value depending on the context (context can be time, events/actions which 
	initiate/terminate the changeable situation, or a history of occured events/actions which leads to an occured situation
	as context for the truth changes of the fluent.
	
	That would mean the qualification of the rule changes depending on the situation (the truth value of the fluent in KR RuleML)
	
     content model: 
     in DR Reaction RuleML: (Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval)
     in KR Reaction RuleML: (Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall | Quantifier | Time | Spatial | Interval | Event | Situation)

-->
    <rng:define name="qualification.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="qualification.content">
        <rng:choice>
            <rng:ref name="formula-assert.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="qualification.type">
        <rng:ref name="qualification.content"/>
        <rng:ref name="qualification.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="qualification"/>
</rng:start>
<rng:define name="qualification">
<rng:element name="qualification">
<rng:ref name="qualification.type"/>
</rng:element>
</rng:define>
    <!--
     *** quantification ***
     
     Definition of the rules' quantifier. 
     
     content model: (Forall | Exists | Quantifier)
          
-->
    <rng:define name="quantification.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="quantification.content">
        <rng:choice>
            <rng:ref name="inner-quantifier.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="quantification.type">
        <rng:ref name="quantification.content"/>
        <rng:ref name="quantification.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="quantification"/>
</rng:start>
<rng:define name="quantification">
<rng:element name="quantification">
<rng:ref name="quantification.type"/>
</rng:element>
</rng:define>
    <!-- extended descriptors in Reaction RuleML -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML quantifiers. File:
            quantifier_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares
            the       following RuleML elements: * Forall * Exists * declare * formula See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Forall ***
		Explicit universal quantifier.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Forall

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens ) )
		
	-->
    <rng:define name="Forall.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Forall.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-forall.type"/>
</rng:element>
                <rng:ref name="formula-forall.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Forall.type">
        <rng:ref name="Forall.content"/>
        <rng:ref name="Forall.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Forall"/>
</rng:start>
<rng:define name="Forall">
<rng:element name="Forall">
<rng:ref name="Forall.type"/>
</rng:element>
</rng:define>
    <!--
		*** Exists ***
		Explicit existential quantifier.

		See http://www.ruleml.org/1.0/glossary/#gloss-Exists

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens) )		
	-->
    <rng:define name="Exists.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Exists.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-exists.type"/>
</rng:element>
                <rng:ref name="formula-exists.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Exists.type">
        <rng:ref name="Exists.content"/>
        <rng:ref name="Exists.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Exists"/>
</rng:start>
<rng:define name="Exists">
<rng:element name="Exists">
<rng:ref name="Exists.type"/>
</rng:element>
</rng:define>
    <!--
		*** declare ***
		A role used for variables declared within a quantifier.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-declare

		content model: ( Var )
	-->
    <rng:define name="declare.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="declare.content">
        
            <rng:ref name="Var"/>
        
    </rng:define>
    <rng:define name="declare.type">
        <rng:ref name="declare.content"/>
        <rng:ref name="declare.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="declare"/>
</rng:start>
<rng:define name="declare">
<rng:element name="declare">
<rng:ref name="declare.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a quantifier (<Forall> or <Exists>).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-formula
		
		content model (below Forall): 
		DR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)

		content model (below Exists): 
		DR Reaction RuleML ( Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )
		
		Other (context-sensitive) versions of <formula> are in the
		connective and performative modules.
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <rng:define name="formula-forall.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="Implies"/>
            <rng:ref name="Rule"/>
            <rng:ref name="Equivalent"/>
            <rng:ref name="outer-quantifier.content"/>
            <rng:ref name="outer-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-forall.type">
        <rng:ref name="formula-forall.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-exists.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="query-quantifier.content"/>
            <rng:ref name="query-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-exists.type">
        <rng:ref name="formula-exists.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML connectives. File:
            connective_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This
            module       declares the following RuleML elements and attributes: * Implies * if *
            then * Entails *       Equivalent * torso * Rulebase * And * Or * formula * @mapMaterial
            * @material * @mapDirection       * @direction * @mapClosure * @closure See
            http://www.ruleml.org/modularization for details       about this modularization
            approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!-- necessary for schematron -->
    <!-- 
	<xs:appinfo>
		
		<ns prefix="r" uri="http://ruleml.org/spec"/>
	</xs:appinfo> 
	-->
    <!--
		*** Implies ***
		An implication rule.

		See http://www.ruleml.org/1.0/glossary/#gloss-Implies

		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (then, if) | (if, then) | ( (Atom | And | Or | Equal), (Atom | Equal) ) )
	-->
    <rng:define name="Implies.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="direction.attrib"/>
        <rng:ref name="material.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Implies.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                
                    <rng:ref name="then"/>
                    <rng:ref name="if"/>
                
                
                    <rng:ref name="if"/>
                    <rng:ref name="then"/>
                
                
                    <rng:ref name="if.content"/>
                    <rng:ref name="then.content"/>
                
            </rng:choice>
        
    </rng:define>
    <rng:define name="Implies.type">
        <rng:ref name="Implies.content"/>
        <rng:ref name="Implies.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Implies"/>
</rng:start>
<rng:define name="Implies">
<rng:element name="Implies">
<rng:ref name="Implies.type"/>
</rng:element>
</rng:define>
    <!-- 
		*** if ***
		The if of an implication rule containing the premise(s),
		also known as the "antecedent" or "if" part of the rule.

		See http://www.ruleml.org/1.0/glossary/#gloss-if

		content model: 
		DR Reaction RuleML (Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
		KR Reaction RuleML (Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)
	-->
    <rng:define name="if.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="if.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="inner-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="if-entails.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
        </rng:choice>
    </rng:define>
    <rng:define name="if.type">
        <rng:ref name="if.content"/>
        <rng:ref name="if.attlist"/>
    </rng:define>
    <rng:define name="if-entails.type">
        <rng:ref name="if-entails.content"/>
        <rng:ref name="if.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="if"/>
</rng:start>
<rng:define name="if">
<rng:element name="if">
<rng:ref name="if.type"/>
</rng:element>
</rng:define>
    <!--
		*** then ***
		The then of an implication rule containing the conclusion,
		also known as the "consequent" or "then" part of the rule.

		See http://www.ruleml.org/1.0/glossary/#gloss-then

		content model: 
		DR Reaction RuleML ( Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)
	-->
    <rng:define name="then.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="then.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="outer-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="then-entails.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
        </rng:choice>
    </rng:define>
    <rng:define name="then.type">
        <rng:ref name="then.content"/>
        <rng:ref name="then.attlist"/>
    </rng:define>
    <rng:define name="then-entails.type">
        <rng:ref name="then-entails.content"/>
        <rng:ref name="then.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="then"/>
</rng:start>
<rng:define name="then">
<rng:element name="then">
<rng:ref name="then.type"/>
</rng:element>
</rng:define>
    <!--
		*** Entails ***
		Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
		Kowalski/Bowen's object/meta-level-amalgamated logic).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Entails
		
		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (if | Rulebase), (then | Rulebase) )
	-->
    <rng:define name="Entails.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Entails.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                <rng:element name="if">
<rng:ref name="if-entails.type"/>
</rng:element>
                <rng:ref name="if-entails.content"/>
            </rng:choice>
            <rng:choice>
                <rng:element name="then">
<rng:ref name="then-entails.type"/>
</rng:element>
                <rng:ref name="then-entails.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Entails.type">
        <rng:ref name="Entails.content"/>
        <rng:ref name="Entails.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Entails"/>
</rng:start>
<rng:define name="Entails">
<rng:element name="Entails">
<rng:ref name="Entails.type"/>
</rng:element>
</rng:define>
    <!--
		*** Equivalent ***
		An equivalence expression, which is "syntactic sugar" for a pair
		of conjoined converse implication rules.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Equivalent

		content model: 		
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Atom | Equal | Negation | Neg |  Time | Spatial | Interval), (Atom | Equal | Negation | Neg | Time | Spatial | Interval) ) ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Atom | Equal | Negation | Neg |  Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens), 
		                      (Atom | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens) ) ) )
	-->
    <rng:define name="Equivalent.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Equivalent.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                
                    <rng:ref name="torso"/>
<rng:ref name="torso"/>
                
                
                    <rng:ref name="torso.content"/>
<rng:ref name="torso.content"/>
                
            </rng:choice>
        
    </rng:define>
    <rng:define name="Equivalent.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<pattern name="Equivalent">
					<rule context="r:Equivalent[count( descendant::r:Equal/r:Expr | descendant::r:Equal/r:left/r:Expr )=2]">
						<assert test=
							"( descendant::r:Equal[1]/descendant::r:Fun[@per = 'copy']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'copy'] )
							 or
							 ( descendant::r:Equal[1]/descendant::r:Fun[@per = 'open']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'open'] )">
						  Equalities within an equivalence expression must either both be interpreted or both uninterpreted.
						</assert>
					</rule>
				</pattern>
			</xs:appinfo>
		</xs:annotation>
                -->
        <rng:ref name="Equivalent.content"/>
        <rng:ref name="Equivalent.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Equivalent"/>
</rng:start>
<rng:define name="Equivalent">
<rng:element name="Equivalent">
<rng:ref name="Equivalent.type"/>
</rng:element>
</rng:define>
    <!--
		*** torso ***
		A symmetric role used in an equivalence expression combining
		the asymmetric <then> and <if>.

		See http://www.ruleml.org/1.0/glossary/#gloss-torso

		content model: 
		DR Reaction RuleML (Atom |  Negation | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Atom |  Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)
	-->
    <rng:define name="torso.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="torso.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="outer-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="torso.type">
        <rng:ref name="torso.content"/>
        <rng:ref name="torso.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="torso"/>
</rng:start>
<rng:define name="torso">
<rng:element name="torso">
<rng:ref name="torso.type"/>
</rng:element>
</rng:define>
    <!--
		*** Rulebase ***
		A collection of rules that can be ordered or unordered, without or with duplicates.

		See http://www.ruleml.org/1.0/glossary/#gloss-Rulebase
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )* )
	-->
    <rng:define name="Rulebase.attlist">
        <rng:ref name="mapClosure.attrib"/>
        <rng:ref name="mapDirection.attrib"/>
        <rng:ref name="mapMaterial.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Rulebase.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-rulebase.type"/>
</rng:element>
                <rng:ref name="formula-rulebase.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Rulebase.type">
        <rng:ref name="Rulebase.content"/>
        <rng:ref name="Rulebase.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rulebase"/>
</rng:start>
<rng:define name="Rulebase">
<rng:element name="Rulebase">
<rng:ref name="Rulebase.type"/>
</rng:element>
</rng:define>
    <!--
		*** And ***
		A conjunctive expression, where <And>Atom</And> is equivalent to Atom.

		See http://www.ruleml.org/1.0/glossary/#gloss-And
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)* ) 

		Under Query, And may have attribute closure="existential"; elsewhere, it may
		not have any attributes.
	-->
    <rng:define name="And-inner.attlist">
        <rng:ref name="node.attrib"/>
    </rng:define>
    <rng:define name="And-query.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="And.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-and-or.type"/>
</rng:element>
                <rng:ref name="formula-and-or.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="And-query.type">
        <rng:ref name="And.content"/>
        <rng:ref name="And-query.attlist"/>
    </rng:define>
    <rng:define name="And-inner.type">
        <rng:ref name="And.content"/>
        <rng:ref name="And-inner.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="And"/>
</rng:start>
<rng:define name="And">
<rng:element name="And">
<rng:ref name="And-inner.type"/>
</rng:element>
</rng:define>
    <!--
		*** Or ***
		A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Or
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)* )

		Under Query, Or may have attribute closure="existential"; elsewhere, it may not
		have any attributes.
	-->
    <rng:define name="Or-query.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Or-inner.attlist">
        <rng:ref name="node.attrib"/>
    </rng:define>
    <rng:define name="Or.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-and-or.type"/>
</rng:element>
                <rng:ref name="formula-and-or.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Or-query.type">
        <rng:ref name="Or.content"/>
        <rng:ref name="Or-query.attlist"/>
    </rng:define>
    <rng:define name="Or-inner.type">
        <rng:ref name="Or.content"/>
        <rng:ref name="Or-inner.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Or"/>
</rng:start>
<rng:define name="Or">
<rng:element name="Or">
<rng:ref name="Or-inner.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a conjunctive/disjunctive expression or a rulebase.

		See http://www.ruleml.org/1.0/glossary/#gloss-formula

		content model (below And/Or): 
		DR Reaction RuleML (Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)
		
		content model (below Rulebase): 
		DR Reaction RuleML (Atom | Implies | Rule | Equivalent | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval)
		KR Reaction RuleML (Atom | Implies | Rule | Equivalent | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)
		
		Other (context-sensitive) versions of <formula> are in the
		performative and quantifier modules.
	-->
    <rng:define name="formula.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="formula-and-or.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="inner-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <!--
		In 1.0, Naf is not allowed in the consequent (second child) of Entails
		because Integrity uses of Entails call for classical Neg
		and Rulebase should not contain Naf in any other context (except Query).
		Alternatives would have been to use And in the consequent of Entails
		or to only allow Naf children within Rulebases that are used for Integrity
		and querying, but this would require making the role tags explicit (i.e.
		not skippable). Schematron could be used here to disallow Naf from other
		Rulebases.
	-->
    <rng:define name="formula-rulebase.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:element name="Implies">
<rng:ref name="Implies.type"/>
</rng:element>
            <rng:ref name="Rule"/>
            <rng:element name="Equivalent">
<rng:ref name="Equivalent.type"/>
</rng:element>
            <rng:ref name="outer-quantifier.content"/>
            <rng:ref name="outer-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-and-or.type">
        <rng:ref name="formula-and-or.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-rulebase.type">
        <rng:ref name="formula-rulebase.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <!--
		*** @mapMaterial ***
		An attribute indicating the kind of all implication rules 
		falling within its scope (i.e. child elements).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@mapMaterial
	-->
    <rng:define name="mapMaterial.attrib">
        <rng:optional>
<rng:attribute name="mapMaterial" a0:defaultValue="yes" xmlns:a0="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>no</rng:value>
                    <rng:value>yes</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @material ***
		An attribute indicating the kind of an implication rule.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@material
	-->
    <rng:define name="material.attrib">
        <rng:optional>
<rng:attribute name="material" a1:defaultValue="yes" xmlns:a1="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>no</rng:value>
                    <rng:value>yes</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @mapDirection ***
		An attribute indicating the intended direction of implication rule inferencing
		of elements falling within its scope (i.e. child elements).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@mapDirection
	-->
    <rng:define name="mapDirection.attrib">
        <rng:optional>
<rng:attribute name="mapDirection" a2:defaultValue="bidirectional" xmlns:a2="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>forward</rng:value>
                    <rng:value>backward</rng:value>
                    <rng:value>bidirectional</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @direction ***
		An attribute indicating the intended direction of an implication rule's inferencing.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@direction
	-->
    <rng:define name="direction.attrib">
        <rng:optional>
<rng:attribute name="direction" a3:defaultValue="bidirectional" xmlns:a3="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>forward</rng:value>
                    <rng:value>backward</rng:value>
                    <rng:value>bidirectional</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @mapClosure ***
		An attribute indicating how the free variables falling within
		its scope (i.e. child elements) are quantified.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@mapClosure
	-->
    <rng:define name="mapClosure.attrib">
        <rng:optional>
<rng:attribute name="mapClosure">
            
                <rng:choice>
                    <rng:value>universal</rng:value>
                    <rng:value>existential</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @closure ***
		An attribute indicating how the contained free variables are quantified.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@closure		
	-->
    <rng:define name="closure.attrib">
        <rng:optional>
<rng:attribute name="closure">
            
                <rng:choice>
                    <rng:value>universal</rng:value>
                    <rng:value>existential</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML atoms. File:
            atom_module.xsd Version: 1.0 Last Modification: 2012-02-21 This module declares
            the following RuleML elements and attributes: * Atom * op * Rel * degree See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
        *** Atom ***
		A logical atom, i.e. an expression formed from a predicate
		applied to a collection of its (logical) arguments.

		See http://www.ruleml.org/1.0/glossary/#gloss-Atom
	
		content model:
		in DR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel), slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval)*, repo?) | repo), slot*, resl?
		)
		
		in KR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel), slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo?) | repo), slot*, resl?
		)
		
		however, the above content model is non-deterministic,
		so it is (equivalently) restructured as follows:
		in DR Reaction RuleML:
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel), slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)	
			
		in KR Reaction RuleML
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel), slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)
	
		Note the 'positionalized' normal form where the oid and op roles
		are at the beginning of the atom.
	-->
    <rng:define name="Atom.attlist">
        <rng:ref name="closure.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <!--
		These .extend groups, pointed to by Atom.content, are necessary
		for redefinition to be binary in bindatalog and to add rest
		variables in hornlog.
	-->
    <rng:define name="Atom-repo.extend">
        <rng:choice>
            <rng:ref name="Atom-arg.extend"/>
            <rng:ref name="repo"/>
        </rng:choice>
    </rng:define>
    <rng:define name="Atom-arg.extend">
        
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="arg"/>
                <rng:ref name="arg.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Atom-slots.extend1">
        
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Atom-slots.extend2">
        
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Atom.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:choice>
                <rng:element name="op">
<rng:ref name="op-atom.type"/>
</rng:element>
                <rng:ref name="op-atom.content"/>
            </rng:choice>
            <rng:ref name="Atom-slots.extend1"/>
            
                <rng:ref name="Atom-repo.extend"/>
                <rng:ref name="Atom-slots.extend1"/>
            
            <rng:ref name="Atom-slots.extend2"/>
        
    </rng:define>
    <rng:define name="Atom.type">
        <rng:ref name="Atom.content"/>
        <rng:ref name="Atom.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Atom"/>
</rng:start>
<rng:define name="Atom">
<rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
</rng:define>
    <!--
		*** op ***
		An operator expression including the relation of an atom.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-op

		content model (within Atom): (Rel)
		
		Other (context-sensitive) versions of <op> are in the expr and holog modules.
	-->
    <rng:define name="op.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="op-atom.content">
        
            <rng:ref name="Rel"/>
        
    </rng:define>
    <rng:define name="op-atom.type">
        <rng:ref name="op-atom.content"/>
        <rng:ref name="op.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="op"/>
</rng:start>
<rng:define name="op">
<rng:element name="op">
<rng:ref name="op-atom.type"/>
</rng:element>
</rng:define>
    <!--
		*** Rel ***
		A relation, i.e. a logical predicate, of an atom.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Rel
		
		content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
	-->
    <rng:define name="Rel.attlist">
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
        <rng:ref name="per-effect.attrib"/>
    </rng:define>
    <rng:define name="Rel.content">
         <rng:data type="token"></rng:data>
    </rng:define>
    <rng:define name="Rel.type">
        <rng:ref name="Rel.content"/>
        <rng:ref name="Rel.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rel"/>
</rng:start>
<rng:define name="Rel">
<rng:element name="Rel">
<rng:ref name="Rel.type"/>
</rng:element>
</rng:define>
    <!-- 
		*** degree ***

		An optional uncertainty value (between 0.0 and 1.0)
		that may be assigned to facts and rules.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-degree

		content model: (Data)
	-->
    <rng:define name="degree.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="degree.content">
        
            <rng:ref name="Data"/>
        
    </rng:define>
    <rng:define name="degree.type">
        <rng:ref name="degree.content"/>
        <rng:ref name="degree.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="degree"/>
</rng:start>
<rng:define name="degree">
<rng:element name="degree">
<rng:ref name="degree.type"/>
</rng:element>
</rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML slots. File:
            slot_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares the
            following       RuleML element and attributes: * slot * @card * @weight See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** slot ***
		A user-defined slot consisting of a name (first position) and a filler (second position).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-slot

		content model:
		DR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval) )
		KR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Event|Situation), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation) )
		
		
		this allows using time and spatial as slot names to define nominal units, e.g. time1(years->3 months->2)  
			location1(x -> 10 y -> 10)
	-->
    <rng:define name="slot.attlist">
        <rng:ref name="card.attrib"/>
        <rng:ref name="weight.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="slot-name.extend">
        <rng:choice>
            <rng:ref name="Ind"/>
            <rng:ref name="Data"/>
            <rng:ref name="Expr"/>
            <rng:ref name="Plex"/>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="slot.content">
        
            <rng:ref name="slot-name.extend"/>
            <rng:ref name="arg.content"/>
        
    </rng:define>
    <rng:define name="slot.type">
        <rng:ref name="slot.content"/>
        <rng:ref name="slot.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="slot"/>
</rng:start>
<rng:define name="slot">
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:define>
    <!--
		*** @card ***
		An attribute optionally specifying a slot's cardinality.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@card		
	-->
    <rng:define name="card.attrib">
        <rng:optional>
<rng:attribute name="card">
<rng:data type="nonNegativeInteger"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @weight ***
		An attribute optionally specifying a slot's relative weight.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@weight		
	-->
    <rng:define name="weight.attrib">
        <rng:optional>
<rng:attribute name="weight">
            
                <rng:data type="decimal">
                    <rng:param name="minInclusive">0</rng:param>
                    <rng:param name="maxInclusive">1</rng:param>
                </rng:data>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML terms. File:
            term_module.xsd Version: 1.0 Last Modification: 2012-04-03 This module declares the
            following       RuleML elements and attributes: * arg * Ind * Data * Var * Skolem *
            Reify * @type * @index as       well as including a number of complex types for use in
            expicitly-typed data Nodes. See       http://www.ruleml.org/modularization for details
            about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-04-03T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** arg ***
		A role used for the positional arguments of a logical atom.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-arg

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
	-->
    <rng:define name="arg.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg.content">
        <rng:choice>
            <rng:ref name="Ind"/>
            <rng:ref name="Data"/>
            <rng:ref name="Var"/>
            <rng:ref name="Skolem"/>
            <rng:ref name="Reify"/>
            <rng:ref name="Expr"/>
            <rng:ref name="Plex"/>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg.type">
        <rng:ref name="arg.content"/>
        <rng:ref name="arg.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="arg"/>
</rng:start>
<rng:define name="arg">
<rng:element name="arg">
<rng:ref name="arg.type"/>
</rng:element>
</rng:define>
    <!--
		*** Ind ***
		An individual constant, as in predicate logic, which can also be considered to
		be a fixed argument like RDF resources.

		See http://www.ruleml.org/1.0/glossary/#gloss-Ind
		
		content model: text

	-->
    <rng:define name="Ind.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Ind.content">
        <rng:data type="token"></rng:data>
    </rng:define>
    <rng:define name="Ind.type">
        <rng:ref name="Ind.content"/>
        <rng:ref name="Ind.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Ind"/>
</rng:start>
<rng:define name="Ind">
<rng:element name="Ind">
<rng:ref name="Ind.type"/>
</rng:element>
</rng:define>
    <!--
		*** Data ***
		A fixed argument like RDF literals, allowing XML data.  It may be
		optionally associated with an XML Schema built-in datatype
		(see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
		using the built-in xsi:type attribute.

		See http://www.ruleml.org/1.0/glossary/#gloss-Data
		
		content model: xs:anytype [optionally datatyped]
  -->
    <rng:start combine="choice">
<rng:ref name="Data"/>
</rng:start>
<rng:define name="Data">
<rng:element name="Data">
<rng:data type="string"/>
</rng:element>
</rng:define>
    <!--
		*** Var ***
		A logical variable, as in logic programming.

		See http://www.ruleml.org/1.0/glossary/#gloss-Var

		content model: text
		
		@mode = + | - | ?; default is ?

	  + input variable which must be bound
        - output variable which must be free (unbound)
        ? can be both input / bound or output / free

	-->
    <rng:define name="Var.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
        <rng:ref name="mode.attrib"/>
    </rng:define>
    <rng:define name="Var.content">
        <rng:data type="token"/>
    </rng:define>
    <rng:define name="Var.type">
        <rng:ref name="Var.content"/>
        <rng:ref name="Var.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Var"/>
</rng:start>
<rng:define name="Var">
<rng:element name="Var">
<rng:ref name="Var.type"/>
</rng:element>
</rng:define>
    <!--
		*** Skolem ***
		A Skolem individual constant, like RDF's blank nodes.

		See http://www.ruleml.org/1.0/glossary/#gloss-Skolem

		content model: text

	-->
    <rng:define name="Skolem.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Skolem.content">
        <rng:data type="token"/>
    </rng:define>
    <rng:define name="Skolem.type">
        <rng:ref name="Skolem.content"/>
        <rng:ref name="Skolem.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Skolem"/>
</rng:start>
<rng:define name="Skolem">
<rng:element name="Skolem">
<rng:ref name="Skolem.type"/>
</rng:element>
</rng:define>
    <!--
		*** Reify ***
		Supports reification (a kind of instantiation or quasi-quotation)
		as needed by SWSL. It allows any RuleML tag available within the
		current sublanguage as content, treating it as a term for performing
		reasoning on.
				
		See http://www.ruleml.org/1.0/glossary/#gloss-Reify		
		
		content model: (any valid RuleML formula)
	-->
    <rng:define name="Reify.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Reify.content">
        
            <!--
		  <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/> -->
            <!-- <Reify> only allows valid RuleML -->
            <!--<xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>-->
            <rng:optional>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:optional>
        
    </rng:define>
    <rng:define name="Reify.type">
        <rng:ref name="Reify.content"/>
        <rng:ref name="Reify.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Reify"/>
</rng:start>
<rng:define name="Reify">
<rng:element name="Reify">
<rng:ref name="Reify.type"/>
</rng:element>
</rng:define>
    <!--
		*** @type ***
		An attribute for optionally specifying a term's (user-defined) type.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@type
		
		Note: In Reaction RuleML the type is changed to Term or Curie or IRI
	-->
    <rng:define name="type.attrib">
        <rng:optional>
<rng:attribute name="type">
<rng:ref name="termOrCurieOrIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @index ***
		A required attribute for specifying the position of a positional
		argument within an atom.
		
		Note: in Reaction RuleML @index is optional
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@index
	-->
    <rng:define name="index.attrib">
        <rng:optional>
<rng:attribute name="index">
<rng:data type="positiveInteger"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for IRI references in RuleML.
            File: iri_module.xsd Version: 1.0 Last Modification: 2010-07-16 This module declares the
            following RuleML attribute: * @iri See http://www.ruleml.org/modularization for details
            about this modularization approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2010-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** @iri ***
		An attribute for referring to a IRI.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-@iri
	-->
    <rng:define name="iri.attrib">
        <rng:optional>
<rng:attribute name="iri">
<rng:data type="anyURI"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!-- includes the hornlog layer with the 'expr' and 'rest' modules -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML expressions. File:
            expr_module.xsd Version: 1.0 Last Modification: 2011-10-05 [Tara Athan] This module
            declares       the following RuleML elements and attributes: * Expr * op * Fun * Plex *
            @per See       http://www.ruleml.org/modularization for details about this
            modularization approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-10-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
        <!-- necessary for schematron -->
        <!-- 
		<xs:appinfo>

		<sch:ns prefix="r" iri="http://www.ruleml.org/0.91/xsd"/>
		-->
    </a:documentation>
    <!--
		*** Expr ***
		A logical function of the form "f(...)" where f is a function name.

		See http://www.ruleml.org/0.91/glossary/#gloss-Expr

		content model:
		DR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun), slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*,
		  repo?, slot*, resl?
		)

    KR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun), slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*,
		  repo?, slot*, resl?
		)

		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		DR Reaction RuleML:
		(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun), slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		KR Reaction RuleML:
				(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun), slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		Note the 'positionalized' normal form where the op role is only
		at the beginning of the Expr.
	-->
    <rng:define name="Expr.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="per.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Expr.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                <rng:element name="op">
<rng:ref name="op-Expr.type"/>
</rng:element>
                <rng:ref name="op-Expr.content"/>
            </rng:choice>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            
                <rng:choice>
                    
                        <rng:oneOrMore>
<rng:choice>
                            <rng:ref name="arg"/>
                            <rng:ref name="arg.content"/>
                        </rng:choice>
</rng:oneOrMore>
                        <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                    
                    <rng:ref name="repo"/>
                </rng:choice>
                <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Expr.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Uninterpreted functions">
					<sch:rule context="r:Expr/r:Fun[@per='no']">
						<sch:assert test=
								"not(../r:Expr/r:Fun[@per='yes'] or
									 ../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
					<sch:rule context="r:Expr/r:op/r:Fun[@per='no']">
						<sch:assert test=
								"not(../../r:Expr/r:Fun[@per='yes'] or
									 ../../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <rng:ref name="Expr.content"/>
        <rng:ref name="Expr.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Expr"/>
</rng:start>
<rng:define name="Expr">
<rng:element name="Expr">
<rng:ref name="Expr.type"/>
</rng:element>
</rng:define>
    <!--
		*** op ***
		An operator expression including the function name of an expression.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-op
				
		content model (within Expr): (Fun)
		
		Other (context-sensitive) versions of <op> are in the atom and holog modules.
	-->
    <!-- the (empty) attribute list is declared in the atom module -->
    <rng:define name="op-Expr.content">
        
            <rng:ref name="Fun"/>
        
    </rng:define>
    <rng:define name="op-Expr.type">
        <rng:ref name="op-Expr.content"/>
        <rng:ref name="op.attlist"/>
    </rng:define>
    <!--
		*** Fun ***
		A user-defined function name.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-Fun

content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
	-->
    <rng:define name="Fun.attlist">
        <rng:ref name="iri.attrib"/>
        <rng:ref name="per.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
        <rng:ref name="val.attrib"/>
    </rng:define>
    <rng:define name="Fun.content">
         <rng:data type="token"></rng:data>
    </rng:define>
    <rng:define name="Fun.type">
        <rng:ref name="Fun.content"/>
        <rng:ref name="Fun.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Fun"/>
</rng:start>
<rng:define name="Fun">
<rng:element name="Fun">
<rng:ref name="Fun.type"/>
</rng:element>
</rng:define>
    <!--
		*** @val ***
		An attribute indicating whether a function is deterministic (exactly one)
		or non-deterministic (set-valued).
		
		May be unified with @card/@minCard/@maxCard for slots in a future version.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-@val
	-->
    <rng:define name="val.attrib">
        <rng:optional>
<rng:attribute name="val" a4:defaultValue="0.." xmlns:a4="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>1</rng:value>
                    <rng:value>0..</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** Plex ***
		An unordered collection of arguments without a constructor.

		See http://www.ruleml.org/0.91/glossary/#gloss-Plex
		
		content model (within Atom, Plex, slot):
		DR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*, repo?, slot*, resl? )
    
    KR Reaction RuleML
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Interval)*, repo?, slot*, resl? )
		
		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		
		DR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		KR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		content model (within repo): 
		DR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval )*, repo? )
		KR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo? )
		
		content model (within resl):
		DR Reaction RuleML: (slot*, resl? )
		KR Reaction RuleML: (slot*, resl? )
	-->
    <rng:define name="Plex.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Plex.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            <rng:choice>
                
                    <rng:oneOrMore>
<rng:choice>
                        <rng:ref name="arg"/>
                        <rng:ref name="arg.content"/>
                    </rng:choice>
</rng:oneOrMore>
                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                
                    <rng:ref name="repo"/>
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                
                    <rng:ref name="resl"/>
                
            </rng:choice>
        
    </rng:define>
    <rng:define name="Plex-repo.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="arg"/>
                <rng:ref name="arg.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Plex-resl.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Plex.type">
        <rng:ref name="Plex.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:define name="Plex-repo.type">
        <rng:ref name="Plex-repo.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:define name="Plex-resl.type">
        <rng:ref name="Plex-resl.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Plex"/>
</rng:start>
<rng:define name="Plex">
<rng:element name="Plex">
<rng:ref name="Plex.type"/>
</rng:element>
</rng:define>
    <!--
		*** @per ***
		An attribute indicating whether a function or expression is interpreted.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-@per
	-->
    <rng:define name="per.attrib">
        <rng:optional>
<rng:attribute name="per" a5:defaultValue="copy" xmlns:a5="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>copy</rng:value>
                    <rng:value>value</rng:value>
                    <rng:value>open</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML rest variables.
            File:       rest_module.xsd Version: 1.0 Last Modification: 2011-07-05 This module
            declares the following       RuleML elements: * repo * resl See
            http://www.ruleml.org/modularization for details about this       modularization
            approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** repo ***
		A positional rest variable.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-repo

		content model: (Var | Plex)
	-->
    <rng:define name="repo.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="repo.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:element name="Plex">
<rng:ref name="Plex-repo.type"/>
</rng:element>
        </rng:choice>
    </rng:define>
    <rng:define name="repo.type">
        <rng:ref name="repo.content"/>
        <rng:ref name="repo.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="repo"/>
</rng:start>
<rng:define name="repo">
<rng:element name="repo">
<rng:ref name="repo.type"/>
</rng:element>
</rng:define>
    <!--
		*** resl ***
		A slotted rest variable.
		
		See http://www.ruleml.org/0.91/glossary/#gloss-resl		

		content model: (Var | Plex)
	-->
    <rng:define name="resl.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="resl.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:element name="Plex">
<rng:ref name="Plex-resl.type"/>
</rng:element>
        </rng:choice>
    </rng:define>
    <rng:define name="resl.type">
        <rng:ref name="resl.content"/>
        <rng:ref name="resl.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="resl"/>
</rng:start>
<rng:define name="resl">
<rng:element name="resl">
<rng:ref name="resl.type"/>
</rng:element>
</rng:define>
    <!-- includes the equalog layer with the 'equality' module -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for equality in RuleML. File:
            equality_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This module
            declares the following RuleML elements and attributes: * Equal * left * right *
            @oriented *       @val See http://www.ruleml.org/modularization for details about this
            modularization approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-02-21T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Equal ***
		An equational formula consisting of two expressions.

		See http://www.ruleml.org/0.91/glossary/#gloss-Equal

		content model:
		in DR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)  )
		)
		in KR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)  )
		)
	-->
    <rng:define name="Equal.attlist">
        <rng:ref name="oriented.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Equal.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:choice>
                
                    <rng:ref name="left"/>
                    <rng:ref name="right"/>
                
                <!-- note that (right, left) is disallowed -->
                
                    <rng:ref name="left.content"/>
                    <rng:ref name="right.content"/>
                
            </rng:choice>
        
    </rng:define>
    <rng:define name="Equal.type">
        <!-- 
			<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Defining equality">
					<sch:rule context=
						"r:Implies/r:then/r:Equal/r:left/r:Expr/r:Fun |
						 r:Implies/r:Equal[2]/r:left/r:Expr/r:Fun |
						 r:Implies/r:then/r:Equal/r:Expr[1]/r:Fun |
						 r:Implies/r:Equal[2]/r:Expr[1]/r:Fun">
						<sch:assert test="@per='yes'">
							A defining equality must have an interpreted left-hand side.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <rng:ref name="Equal.content"/>
        <rng:ref name="Equal.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Equal"/>
</rng:start>
<rng:define name="Equal">
<rng:element name="Equal">
<rng:ref name="Equal.type"/>
</rng:element>
</rng:define>
    <!--
		*** left ***
		The left-hand side of an equational formula.

		See http://www.ruleml.org/1.0/glossary/#gloss-left

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
	-->
    <rng:define name="left.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="left.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="left.type">
        <rng:ref name="left.content"/>
        <rng:ref name="left.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="left"/>
</rng:start>
<rng:define name="left">
<rng:element name="left">
<rng:ref name="left.type"/>
</rng:element>
</rng:define>
    <!--
		*** right***
		The right-hand side of an equational formula.

		See http://www.ruleml.org/1.0/glossary/#gloss-right

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
	-->
    <rng:define name="right.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="right.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="right.type">
        <rng:ref name="right.content"/>
        <rng:ref name="right.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="right"/>
</rng:start>
<rng:define name="right">
<rng:element name="right">
<rng:ref name="right.type"/>
</rng:element>
</rng:define>
    <!--
		*** @oriented ***
		An attribute indicating whether an equation is oriented (directed)
		or unoriented (symmetric).
		
		See http://www.ruleml.org/0.91/glossary/#gloss-@oriented
	-->
    <rng:define name="oriented.attrib">
        <rng:optional>
<rng:attribute name="oriented" a6:defaultValue="no" xmlns:a6="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>yes</rng:value>
                    <rng:value>no</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!-- include from the (spatio-temporal) derivation rule layer of reaction ruleml   -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                  Mode / Transactional / Use
            attribute module.    This is the XML Schema attributes module for Reaction RuleML.
            File: attribute_module.xsd    Version: 1.0    Last Modification: 2011-03-30        This
            module declares the following Reaction RuleML elements and attributes:
            * @mode (mode declaration)                   * @safety (transactional)
            * @per (usage)                   * @all (yes|no)                   * @style (execution
            style)                    * @key and @keyref for modularization of knowledge bases                 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-30T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                      This is the XML Schema currie module for
            Reaction RuleML.       File: currie_module.xsd       Version: 1.0       Last
            Modification: 2011-03-30              This module declares the datatypes supporting
            CURRIEs             
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-30T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <rng:define name="curieOrIRI.datatype">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
            
        </a:documentation>
        <rng:choice>
<rng:ref name="curie.datatype"/>
<rng:data type="anyURI"/>
</rng:choice>
    </rng:define>
    <rng:define name="curieOrAbsIRI.datatype">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
            
        </a:documentation>
        <rng:choice>
<rng:ref name="curie.datatype"/>
<rng:ref name="absIRI.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="termOrCurieOrIRI.datatype">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
            
        </a:documentation>
        <rng:choice>
<rng:ref name="term.datatype"/>
<rng:ref name="curie.datatype"/>
<rng:data type="anyURI"/>
</rng:choice>
    </rng:define>
    <rng:define name="termOrCurieOrAbsIRI">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
            
        </a:documentation>
        <rng:choice>
<rng:ref name="term.datatype"/>
<rng:ref name="curie.datatype"/>
<rng:ref name="absIRI.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="absIRI.datatype">
        <rng:data type="anyURI">
            <rng:param name="pattern">[\i-[:]][\c-[:]]+:.+</rng:param>
        </rng:data>
    </rng:define>
    <rng:define name="curie.datatype">
        <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
            
        </a:documentation>
        <rng:data type="string">
            <rng:param name="minLength">1</rng:param>
            <rng:param name="pattern">(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)</rng:param>
        </rng:data>
    </rng:define>
    <rng:define name="term.datatype">
        <rng:data type="Name">
            <rng:param name="pattern">[\i-[:]][/\c-[:]]*</rng:param>
        </rng:data>
    </rng:define>
    <!--
           *** @mode ***
           A attribute for optionally specifing the intended input-output constellations of the predicate terms with the
           following semantics:
        
           "+" The term is intended to be input
           "-" The term is intended to be output
           "?" The term is undefined (input or output)
		   
		   default="?"
		   optional attribute
-->
    <rng:define name="mode.attrib">
        <rng:optional>
<rng:attribute name="mode" a7:defaultValue="?" xmlns:a7="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>+</rng:value>
                    <rng:value>-</rng:value>
                    <rng:value>?</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
	  *** @safety ***

	     restriction: interrupting, non-interrupting or transactional
		 default: non-interrupting
		 optional attribute
	-->
    <rng:define name="safety.attrib">
        <rng:optional>
<rng:attribute name="safety" a8:defaultValue="non-interrupting" xmlns:a8="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>non-interrupting</rng:value>
                    <rng:value>interrupting</rng:value>
                    <rng:value>transactional</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @per ***
		An attribute indicating whether a function or expression is interpreted.
		
	-->
    <rng:define name="per-effect.attrib">
        <rng:optional>
<rng:attribute name="per" a9:defaultValue="copy" xmlns:a9="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
                    <rng:value>copy</rng:value>
                    <rng:value>value</rng:value>
                    <rng:value>effect</rng:value>
                    <rng:value>modal</rng:value>
                    <rng:value>open</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @size ***
		An attribute indicating the size / number		
		-1 = unbound / all
	-->
    <rng:define name="size.attrib">
        <rng:optional>
<rng:attribute name="size" a10:defaultValue="-1" xmlns:a10="http://relaxng.org/ns/compatibility/annotations/1.0">
<rng:data type="int"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
	 optional attribute
-->
    <rng:define name="style.datatype">
        <rng:choice>
            <rng:value>active</rng:value>
            <rng:value>messaging</rng:value>
            <rng:value>reasoning</rng:value>
        </rng:choice>
    </rng:define>
    <!--
    *** @key ***
    
    
    
	 optinal attribute
-->
    <rng:define name="key.attrib">
        <rng:optional>
<rng:attribute name="key">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @keyref ***
    
    
	 optinal attribute
-->
    <rng:define name="keyref.attrib">
        <rng:optional>
<rng:attribute name="keyref">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                              Rules module part of Reaction RuleML.
            It defines the core            Rule construct used as basis for all types of rules in
            Reaction RuleML                      This is the XML Schema rule module for Reaction
            RuleML.           File: rule_module.xsd           Version: 1.0           Last
            Modification: 2011-03-29                      This schema declares the following
            Reaction RuleML elements and attributes:                      * Rule           * on
            * if           * then           * do           * after                     * else
            * elseDo           * elseAfter                          
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
      *** Rule ***
      The Rule element that provides the basic syntax for rules
      in Reaction RuleML.

      content model: 
 	 
 	 In (temporal) DR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (if, then, else?)? ) )
	 In KR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (if, then, else?)? ) )
	 
      Rule has the following attributes:
      @key @keyref @type @style @closure @direction @material @node 
      
-->
    <rng:define name="Rule.attlist">
        <rng:ref name="style.attrib"/>
        <rng:ref name="type.attrib"/>
        <rng:ref name="Implies.attlist"/>
    </rng:define>
    <rng:define name="Rule.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="rule-implementation.content"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Rule.type">
        <rng:ref name="Rule.content"/>
        <rng:ref name="Rule.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rule"/>
</rng:start>
<rng:define name="Rule">
<rng:element name="Rule">
<rng:ref name="Rule.type"/>
</rng:element>
</rng:define>
    <!--
     *** on ***
     
     content model: 
     DR Reaction RuleMl: (  )
     KR Reaction RuleMl: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
          
-->
    <rng:define name="on.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="on.content">
        <rng:choice>
            <rng:ref name="event_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="on.type">
        <rng:ref name="on.content"/>
        <rng:ref name="on.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="on"/>
</rng:start>
<rng:define name="on">
<rng:element name="on">
<rng:ref name="on.type"/>
</rng:element>
</rng:define>
    <!--
     *** if ***
     *** after ***
     
     content model:   
     DR Reaction RuleML: (Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
     KR Reaction RuleML: (Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation )
         
	-->
    <rng:start combine="choice">
<rng:ref name="after"/>
</rng:start>
<rng:define name="after">
<rng:element name="after">
<rng:ref name="if.type"/>
</rng:element>
</rng:define>
    <!--
	 *** then ***	
     *** else ***
     
     content model: 
     DR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
     KR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation )
     
	-->
    <rng:start combine="choice">
<rng:ref name="else"/>
</rng:start>
<rng:define name="else">
<rng:element name="else">
<rng:ref name="then.type"/>
</rng:element>
</rng:define>
    <!--
     *** do ***
     *** elseDo ***
     
     content model:  
     DR Reaction RuleML: (  )
     KR Reaction RuleML: (  )
-->
    <rng:define name="do.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="do.content">
        <rng:choice>
            <rng:ref name="action_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="do.type">
        <rng:ref name="do.content"/>
        <rng:ref name="do.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="do"/>
</rng:start>
<rng:define name="do">
<rng:element name="do">
<rng:ref name="do.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="elseDo"/>
</rng:start>
<rng:define name="elseDo">
<rng:element name="elseDo">
<rng:ref name="do.type"/>
</rng:element>
</rng:define>
    <!--
  *** Derivation Rule content model ***
  	((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
	-->
    <rng:define name="DerivationRule.content">
        <rng:choice>
            
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:ref name="then"/>
                <rng:ref name="if"/>
            
            
                <rng:ref name="if"/>
                <rng:ref name="then"/>
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
            
            
                <rng:ref name="if.content"/>
                <rng:ref name="then.content"/>
                <rng:optional>
<rng:ref name="then.content"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!--
   *** Production Rule content model ***
   ((elseDo?, do, if) | (if, do, elseDo?)	| (if.content, do.content, do.content?))
-->
    <rng:define name="ProductionRule.content">
        <rng:choice>
            
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:ref name="do"/>
                <rng:ref name="if"/>
            
            
                <rng:ref name="if"/>
                <rng:ref name="do"/>
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
            
            
                <rng:ref name="if.content"/>
                <rng:ref name="do.content"/>
                <rng:optional>
<rng:ref name="do.content"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!--
   *** Reaction Rule content model ***
   (on, (if?, then?, do, after?,else?, elseDo?)? )
-->
    <rng:define name="ReactionRule.content">
        
            <rng:ref name="on"/>
            
                <rng:optional>
<rng:ref name="if"/>
</rng:optional>
                <rng:optional>
<rng:ref name="then"/>
</rng:optional>
                <rng:ref name="do"/>
                <rng:optional>
<rng:ref name="after"/>
</rng:optional>
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
            
        
    </rng:define>
    <!--
   *** Messaging Rule content model ***
   (do)
-->
    <rng:define name="MessagingRule.content">
        
            <rng:ref name="do"/>
        
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Negation module part of Reaction RuleML.   This
            defines the negation elements for Reaction RuleML.   File: negation_module.xsd
            Version: 1.0   Last Modification: 2011-03-22      * Negation  generic polymorphig
            negation   * Naf           negation as failure (inflationary negation in production
            rules), weak negation   * Neg           classical negation, strong negation   * weak
            * strong   * formula        
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Negation ***
		A generic polymorphic negation, which can be specialized by using
		the @type attribute to specify the type of negation and/or 
 		the @iri attribute to point to an external definition of the negation
 		@key, @keyref, @node

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | Naf | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | | Naf | Neg | Time | Interval | Spatial | Event | Situation | Holds | Happens | Initates | Terminates ) )
-->
    <rng:define name="Negation.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Negation.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-negation.type"/>
</rng:element>
                <rng:ref name="formula-negation.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Negation.type">
        <rng:ref name="Negation.content"/>
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Negation"/>
</rng:start>
<rng:define name="Negation">
<rng:element name="Negation">
<rng:ref name="Negation.type"/>
</rng:element>
</rng:define>
    <rng:define name="formula-negation.attlist">
      <rng:empty/>
    </rng:define>
    <rng:define name="formula-negation.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:ref name="Equal"/>
            <rng:ref name="Negation"/>
            <rng:ref name="Naf"/>
            <rng:ref name="Neg"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-negation.type">
        <rng:ref name="formula-negation.content"/>
        <rng:ref name="formula-negation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="formula"/>
</rng:start>
<rng:define name="formula">
<rng:element name="formula">
<rng:ref name="formula-negation.type"/>
</rng:element>
</rng:define>
    <!--
		*** Naf ***
		A "by default" negation of a logical atom (i.e. "weak" negation or
		negation-as-failure).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Naf
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | Naf | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | | Naf | Neg | Time | Interval | Spatial | Event | Situation | Holds | Happens | Initates | Terminates ) )
	-->
    <rng:define name="Naf.attlist">
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:define name="Naf.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                <rng:ref name="weak"/>
                <rng:ref name="weak.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Naf.type">
        <rng:ref name="Naf.content"/>
        <rng:ref name="Naf.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Naf"/>
</rng:start>
<rng:define name="Naf">
<rng:element name="Naf">
<rng:ref name="Naf.type"/>
</rng:element>
</rng:define>
    <!--
		*** weak ***
		A role used for negation as failure.
	
		See http://www.ruleml.org/1.0/glossary/#gloss-weak
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | Naf | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | | Naf | Neg | Time | Interval | Spatial | Event | Situation | Holds | Happens | Initates | Terminates ) )
	-->
    <rng:define name="weak.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="weak.content">
        <rng:choice>
            <rng:ref name="formula-negation.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="weak.type">
        <rng:ref name="weak.content"/>
        <rng:ref name="weak.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="weak"/>
</rng:start>
<rng:define name="weak">
<rng:element name="weak">
<rng:ref name="weak.type"/>
</rng:element>
</rng:define>
    <!--
		*** Neg ***
		A classical negation of a logical atom (i.e. classical or "strong" negation).
		
		See http://www.ruleml.org/1.0/glossary/#gloss-Neg
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | Naf | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | | Naf | Neg | Time | Interval | Spatial | Event | Situation | Holds | Happens | Initates | Terminates ) )
	-->
    <rng:define name="Neg.attlist">
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:define name="Neg.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                <rng:ref name="strong"/>
                <rng:ref name="strong.content"/>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Neg.type">
        <rng:ref name="Neg.content"/>
        <rng:ref name="Neg.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Neg"/>
</rng:start>
<rng:define name="Neg">
<rng:element name="Neg">
<rng:ref name="Neg.type"/>
</rng:element>
</rng:define>
    <!--
		*** strong ***
		A role used for classical negation.
		
		See http://www.ruleml.org/1.0/glossary/#gloss-strong
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | Naf | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Atom | Equal | Negation | | Naf | Neg | Time | Interval | Spatial | Event | Situation | Holds | Happens | Initates | Terminates ) )	-->
    <rng:define name="strong.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="strong.content">
        <rng:choice>
            <rng:ref name="formula-negation.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="strong.type">
        <rng:ref name="strong.content"/>
        <rng:ref name="strong.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="strong"/>
</rng:start>
<rng:define name="strong">
<rng:element name="strong">
<rng:ref name="strong.type"/>
</rng:element>
</rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                         Quantifier module part of
            Reaction RuleML redefining the Forall, Exists and introduce the Quantifier element.
            This is the XML Schema Quantifier element for Reaction RuleML.   File:
            quantifier_module.xsd   Version: 1.0   Last Modification: 2011-03-22       * Quantifier
            generic quantifier   * Forall  predefined inner quantifier (used in quantification
            metatag)   * Exist   predefined inner quantifier (used in qualification metatag)       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Quantifier ***
	Explicit generic quantifier, where the quantifier name can be defined by the 
      @type attribute and the @iri attribute can point to an external definition
      of the quantifier.
		
	content model: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula|Atom|Rule|Negation|Naf|Neg|Equivalent|Equal|And|Or|Exists|Forall|Quantifier)? )
-->
    <rng:define name="Quantifier.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="Var"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-forall.type"/>
</rng:element>
                <rng:ref name="formula-forall.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Quantifier.type">
        <rng:ref name="Quantifier.content"/>
        <rng:ref name="Quantifier.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Quantifier"/>
</rng:start>
<rng:define name="Quantifier">
<rng:element name="Quantifier">
<rng:ref name="Quantifier.type"/>
</rng:element>
</rng:define>
    <!--
	make the quantifier constraint restrictions ("such that") optional
	
	(  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula | Atom|Rule|Negation|Naf|Neg|Equivalent|Equal|And|Or|Exists|Forall|Quantifier)? )
-->
    <rng:define name="Exists-quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-forall.type"/>
</rng:element>
                <rng:ref name="formula-forall.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Exists-quantifier.type">
        <rng:ref name="Exists-quantifier.content"/>
        <rng:ref name="Exists.attlist"/>
    </rng:define>
    <!--
	make the quantifier constraint restrictions ("such that") optional
	
	( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (declare|Var)+, (formula|Atom|Rule|Negation|Naf|Neg|Equivalent|Equal|And|Or|Exists|Forall|Quantifier)? )


-->
    <rng:define name="Forall-quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-forall.type"/>
</rng:element>
                <rng:ref name="formula-forall.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Forall-quantifier.type">
        <rng:ref name="Forall-quantifier.content"/>
        <rng:ref name="Exists.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Profile module part of Reaction RuleML.   This is
            the XML Schema Profile element for Reaction RuleML for describing semantic profiles.
            Semantic Profiles are used to define the interpretation evaluation semantics (under the
            evaluation metatag)    either by referecing external existing profiles or by defining
            them internally.   File: profile_module.xsd   Version: 1.0   Last Modification:
            2011-03-22      * Profile         generic semantic profile       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Profile ***
	Explicit generic semantic profile defining the semantics of the rule. The semantic profile can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the used sematics profile,
      the optional @iri attribute points to an external definition of the semantics profile, and
      the optional @direction attribute indicates the intended direction of the inference / execution
      the optional @safety attribute indicates if the execution / inference is transactional, interrupting, non-interrupting
      the optional @size attribute acts as a generic size boundary / counter in the operational semantic profiles    
		
	content model: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, content(xs:any*)* )-->
    <rng:define name="Profile.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="direction.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="safety.attrib"/>
        <rng:ref name="size.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Profile.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="profile_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Profile.type">
        <rng:ref name="Profile.content"/>
        <rng:ref name="Profile.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Profile"/>
</rng:start>
<rng:define name="Profile">
<rng:element name="Profile">
<rng:ref name="Profile.type"/>
</rng:element>
</rng:define>
    <!--
     *** content ***
     
     content model:  xs:any*
-->
    <rng:define name="profile_anycontent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="profile_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="profile_anycontent.type">
        <rng:ref name="profile_anycontent.content"/>
        <rng:ref name="profile_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Time module part of Reaction RuleML. It
            defines the core     time constructs        This is the XML Schema time module for
            Reaction RuleML.    File: time_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Time    
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Time ***
	Explicit generic Time construct. The time can be represented internally 
      * with positional arguments <arg>, e.g., <arg>
<Data xsi:type="xs:dateTime>2011-10-02T10:45:34-00:00</Data>
</arg>
      * with unpositional slots <slot>, e.g., <slot>
<Ind>year</Ind>
<Ind>2011</Ind>
</slot>
<slot>
<Ind>month</Ind>
<Ind>10</Ind>
</slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
      or externally, where the optional @iri attribute points to an external data definition of the time
      The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
      or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
      Note: Time can be defined absolute or relative.
      		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	KR Reaction RuleML:  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
				((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	-->
    <rng:define name="Time.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Time.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                    
                        <rng:choice>
                            
                                <rng:oneOrMore>
<rng:choice>
                                    <rng:element name="arg">
<rng:ref name="arg_time.type"/>
</rng:element>
                                    <rng:ref name="time_primitives.content"/>
                                </rng:choice>
</rng:oneOrMore>
                                <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                            
                            <rng:ref name="repo"/>
                        </rng:choice>
                        <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                    
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="time_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Time.type">
        <rng:ref name="Time.content"/>
        <rng:ref name="Time.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Time"/>
</rng:start>
<rng:define name="Time">
<rng:element name="Time">
<rng:ref name="Time.type"/>
</rng:element>
</rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Time
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)
     
          
-->
    <rng:define name="arg_time.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_time.content">
        <rng:choice>
            <rng:ref name="time_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_time.type">
        <rng:ref name="arg_time.content"/>
        <rng:ref name="arg_time.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     content model:  xs:any*
-->
    <rng:define name="time_anycontent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="time_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="time_anycontent.type">
        <rng:ref name="time_anycontent.content"/>
        <rng:ref name="time_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Spatial module part of Reaction RuleML. It defines
            the core     spatial constructs        This is the XML Schema spatial module for
            Reaction RuleML.    File: spatial_module.xsd    Version: 1.0    Last Modification:
            2011-03-29        This schema declares the following Reaction RuleML elements and
            attributes:        * Spatial       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Spatial ***
	Explicit generic Spatial construct. The spatial can be represented internally 
      * with positional arguments <arg>
      * with unpositional slots <slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
      or externally, where the optional @iri attribute points to an external data definition of the spatial
      The optional @type attribute defines the type of the spatial
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	-->
    <rng:define name="Spatial.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Spatial.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                    
                        <rng:choice>
                            
                                <rng:oneOrMore>
<rng:choice>
                                    <rng:element name="arg">
<rng:ref name="arg_spatial.type"/>
</rng:element>
                                    <rng:ref name="spatial_primitives.content"/>
                                </rng:choice>
</rng:oneOrMore>
                                <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                            
                            <rng:ref name="repo"/>
                        </rng:choice>
                        <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                    
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="spatial_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
        
    </rng:define>
    <rng:define name="Spatial.type">
        <rng:ref name="Spatial.content"/>
        <rng:ref name="Spatial.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Spatial"/>
</rng:start>
<rng:define name="Spatial">
<rng:element name="Spatial">
<rng:ref name="Spatial.type"/>
</rng:element>
</rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Spatial
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)
     
          
-->
    <rng:define name="arg_spatial.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_spatial.content">
        <rng:choice>
            <rng:ref name="spatial_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_spatial.type">
        <rng:ref name="arg_spatial.content"/>
        <rng:ref name="arg_spatial.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     content model:  xs:any*
-->
    <rng:define name="spatial_anycontent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="spatial_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="spatial_anycontent.type">
        <rng:ref name="spatial_anycontent.content"/>
        <rng:ref name="spatial_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Interval module part of Reaction RuleML. It
            defines the core     Interval construct        This is the XML Schema event module for
            Reaction RuleML.    File: interval_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Interval    
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Interval ***
	Explicit generic Interval. The interval can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the event,
      the optional @iri attribute points to an external definition of the event, and
       An interval can be defined by Events, Times, Spatials, and other Intervals can be typed by the 
       interval ontology of Reaction RuleML (defining different types of intervals).
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [Time,Time?] | [Spatial, Spatial?] | [Interval, Interval?] | [Var, Var?])? 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [Time,Time?] | [Spatial, Spatial?] | [Interval, Interval?] | [Event, Event?], [Situation, Situation?] [Var, Var?])?
	-->
    <rng:define name="Interval.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="node.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Interval.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                <rng:ref name="interval_primitives.content"/>
                <rng:element name="content">
<rng:ref name="interval_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Interval.type">
        <rng:ref name="Interval.content"/>
        <rng:ref name="Interval.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Interval"/>
</rng:start>
<rng:define name="Interval">
<rng:element name="Interval">
<rng:ref name="Interval.type"/>
</rng:element>
</rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Intervals
     
     content model:  
     in DR Reaction RuleML: Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex
     in KR Reaction RuleML: Time | Spatial | Interval |  Event | Situation | Ind | Data | Skolem | Var | Reify | Expr | Plex 
          
-->
    <rng:define name="arg_interval.attlist">
        <rng:ref name="index.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_interval.content">
        <rng:choice>
            <rng:ref name="interval_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_interval.type">
        <rng:ref name="arg_interval.content"/>
        <rng:ref name="arg_interval.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     content model:  xs:any*
-->
    <rng:define name="interval_anycontent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="interval_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="interval_anycontent.type">
        <rng:ref name="interval_anycontent.content"/>
        <rng:ref name="interval_anycontent.attlist"/>
    </rng:define>
    <!--
     metadata group
     
	This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
	
     content model: (meta*, scope*, guard )
          
	-->
    <rng:define name="metadata.content">
        
            <rng:zeroOrMore>
<rng:ref name="meta"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="scope"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="guard"/>
</rng:zeroOrMore>
        
    </rng:define>
    <!--
     interface group
     
     This internal group defines the interface signature and the evaluation semantics
     
     content model: (evaluation*, signature* )
          
	-->
    <rng:define name="interface.content">
        
            <rng:zeroOrMore>
<rng:ref name="evaluation"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="signature"/>
</rng:zeroOrMore>
        
    </rng:define>
    <!--
     instance group
     
     This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
     
     content model: (qualification*, quantification*, oid? )
          
	-->
    <rng:define name="instance.content">
        
            <rng:zeroOrMore>
<rng:ref name="qualification"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="quantification"/>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="oid"/>
</rng:optional>
        
    </rng:define>
    <!--
         
     An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
    
    
     content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
          
	-->
    <rng:define name="meta-roles.content">
        
            <rng:ref name="metadata.content"/>
            <rng:ref name="interface.content"/>
            <rng:ref name="instance.content"/>
        
    </rng:define>
    <!--
         
     An internal group for the implementation of a rule in the Reaction RuleML language
    
    
     content model:
     
     in DR Reaction RuleML: 
     
     ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
          
	-->
    <rng:define name="rule-implementation.content">
        <rng:choice>
            <rng:ref name="DerivationRule.content"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the query connectives in the Reaction RuleML language
    
     content model: (And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <rng:define name="query-connective.content">
        <rng:choice>
            <rng:element name="And">
<rng:ref name="And-query.type"/>
</rng:element>
            <rng:element name="Or">
<rng:ref name="Or-query.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Naf"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the inner connectives in the Reaction RuleML language
    
    
     content model: (And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <rng:define name="inner-connective.content">
        <rng:choice>
            <rng:element name="And">
<rng:ref name="And-inner.type"/>
</rng:element>
            <rng:element name="Or">
<rng:ref name="Or-inner.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Naf"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the outer connectives in the Reaction RuleML language
    
    
     content model: (Negation | Neg | Equal )
          
	-->
    <rng:define name="outer-connective.content">
        <rng:choice>
            <rng:ref name="Negation"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the query quantifiers in the Reaction RuleML language
    
     content model: (Exists | Quantifier)
          
	-->
    <rng:define name="query-quantifier.content">
        <rng:choice>
            <rng:ref name="Exists"/>
            <rng:ref name="Quantifier"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the inner quantifiers in the Reaction RuleML language
    
    
     content model: (Forall | Exists | Quantifier)
          
	-->
    <rng:define name="inner-quantifier.content">
        <rng:choice>
            <rng:element name="Forall">
<rng:ref name="Forall-quantifier.type"/>
</rng:element>
            <rng:element name="Exists">
<rng:ref name="Exists-quantifier.type"/>
</rng:element>
            <rng:ref name="Quantifier"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the outer quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall | Quantifier )
          
	-->
    <rng:define name="outer-quantifier.content">
        <rng:choice>
            <rng:ref name="Forall"/>
            <rng:ref name="Quantifier"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the predicate sorts Time, Spatial and Interval
    
     content model: (Time | Spatial | Interval)
          
	-->
    <rng:define name="extended-signature-predicate-sorts.content">
        <rng:choice>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the function sorts Time, Spatial and Interval
    
     content model: (Time | Spatial | Interval)
          
	-->
    <rng:define name="extended-signature-function-sorts.content">
        <rng:choice>
            <rng:ref name="Time"/>
            <rng:ref name="Spatial"/>
            <rng:ref name="Interval"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the time primitives for interpretation as time
		content model: 
		in DR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
	-->
    <rng:define name="time_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the spatial primitives for interpretation as spatial
		content model: 
		in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
	-->
    <rng:define name="spatial_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- Interval primitives
		content model: 
		in ([Time,Time?] | [Spatial, Spatial?] | [Interval, Interval?] | [(Ind | Data | Skolem | Var | Reify | Expr | Plex | Time | Spatial | Interval), (Ind | Data | Skolem | Var | Reify | Expr | Plex | Time | Spatial | Interval)?]) -->
    <rng:define name="interval_primitives.content">
        <rng:choice>
            
                <rng:ref name="arg.content"/>
                <rng:optional>
<rng:ref name="arg.content"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!-- An internal group for the situation primitives for interpretation as situation
		content model: 
		in DR Reaction RuleML: ()
	-->
    <rng:define name="situation_primitives.content">
        <rng:choice> <rng:notAllowed/></rng:choice>
    </rng:define>
    <!-- An internal group for the event primitives for interpretation as event
		content model: 
		in DR Reaction RuleML: ()
	-->
    <rng:define name="event_primitives.content">
        <rng:choice><rng:notAllowed/> </rng:choice>
    </rng:define>
    <!-- An internal group for the action primitives for interpretation as action
		content model: 
		in DR Reaction RuleML: ()
	-->
    <rng:define name="action_primitives.content">
        <rng:choice><rng:notAllowed/> </rng:choice>
    </rng:define>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: reasoning (in DR Reaction RuleML)
	 optional attribute
-->
    <rng:define name="style.attrib">
        <rng:optional>
<rng:attribute name="style" a11:defaultValue="reasoning" xmlns:a11="http://relaxng.org/ns/compatibility/annotations/1.0">
<rng:ref name="style.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
</rng:grammar>