<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0" ns="http://ruleml.org/spec" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                KR (Knowledge Representation) dialect of Reaction
            RuleML for temporal / event / action / situation reasoning logics        File: kr.xsd
            Version: 1.02    Last Modification: 2015-07-19          
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">KR Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Knowledge Representation (KR) dialect of Reaction
                RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!-- includes the datalog layer of deliberation ruleml -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML performatives.
            File:       performative_module.xsd Version: 1.02        Last Modification: 2015-07-19
            This module declares the       following RuleML elements: * RuleML * Assert * Retract *
            Query * act * formula See       http://www.ruleml.org/modularization for details about
            this modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built performative module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-19T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** RuleML ***
		The n-ary top-level of a RuleML document.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-RuleML

 	 Note: key and keyref object identifier are defined to be unique under the RuleML document root
 	 
 	 @vocab: an IRI that defines the mapping to use when a type term (e.g. a frame signature type) is referenced in an attribute value
 	 @prefix: a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
	-->
    <rng:define name="RuleML.attlist">
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="RuleML.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="do">
<rng:ref name="act.type"/>
</rng:element>
                <rng:ref name="act.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="RuleML.type">
        <rng:ref name="RuleML.content"/>
        <rng:ref name="RuleML.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="RuleML"/>
</rng:start>
<rng:define name="RuleML">
<rng:element name="RuleML">
<rng:ref name="RuleML.type"/>
        <!-- key object identifiers and key object references defined on the top level -->
        
            
            
        
        
            
            
        
    </rng:element>
</rng:define>
    <!--
    *** do ***
    The do role of the root element (<RuleML>).
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-do
  -->
    <rng:define name="act.content">
        <rng:choice>
            <rng:ref name="performative_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="act.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="act.type">
        <rng:ref name="act.content"/>
        <rng:ref name="act.attlist"/>
    </rng:define>
    <!--
      *** Consult ***
      Consult (import) performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Consult
      
      dynamically "consults" (imports) knowledge resource, e.g. a message, documents or external resource (with the @iri attribute).
    -->
    <rng:define name="Consult.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Consult.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="consult_imports.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Consult.type">
        <rng:ref name="Consult.content"/>
        <rng:ref name="Consult.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Consult"/>
</rng:start>
<rng:define name="Consult">
<rng:element name="Consult">
<rng:ref name="Consult.type"/>
</rng:element>
</rng:define>
    <!--
     *** payload ***
     
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-payload
	-->
    <rng:define name="payload.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="payload.content">
        <rng:choice>
            <rng:ref name="RuleML"/>
            <!-- a RuleML knowledge base -->
            <rng:ref name="Reify"/>
            <!-- reified knowledge as payload -->
            <rng:ref name="Var"/>
            <!-- for  binding knowledge to variables in meta programming -->
        </rng:choice>
    </rng:define>
    <rng:define name="payload.type">
        <rng:ref name="payload.content"/>
        <rng:ref name="payload.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="payload"/>
</rng:start>
<rng:define name="payload">
<rng:element name="payload">
<rng:ref name="payload.type"/>
</rng:element>
</rng:define>
    <!--
		*** Assert ***
		A KQML-like performative acting as a wrapper specifying that its content is
		asserted, making an 'implicit <Rulebase>' assumption.

		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Assert   
  -->
    <rng:define name="Assert.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Assert.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                <rng:ref name="formula-assert.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Assert.type">
        <rng:ref name="Assert.content"/>
        <rng:ref name="Assert.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Assert"/>
</rng:start>
<rng:define name="Assert">
<rng:element name="Assert">
<rng:ref name="Assert.type"/>
</rng:element>
</rng:define>
    <!--
		*** Retract ***
		A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
		content is to be deleted, making an 'implicit <Rulebase>' assumption.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Retract
  -->
    <rng:define name="Retract.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Retract.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                <rng:ref name="formula-assert.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Retract.type">
        <rng:ref name="Retract.content"/>
        <rng:ref name="Retract.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Retract"/>
</rng:start>
<rng:define name="Retract">
<rng:element name="Retract">
<rng:ref name="Retract.type"/>
</rng:element>
</rng:define>
    <!--
      *** Update ***
      Update action
      
      See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Update
  -->
    <rng:define name="Update.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Update.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            
                <rng:choice>
                    <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                    <rng:ref name="formula-assert.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                    <rng:ref name="formula-assert.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Update.type">
        <rng:ref name="Update.content"/>
        <rng:ref name="Update.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Update"/>
</rng:start>
<rng:define name="Update">
<rng:element name="Update">
<rng:ref name="Update.type"/>
</rng:element>
</rng:define>
    <!--
		*** Query ***
		A KQML-like performative acting as a wrapper specifying that its content is
		queried, making an 'implicit <Rulebase>' assumption.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Query
  -->
    <rng:define name="Query.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Query.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-query.type"/>
</rng:element>
                <rng:ref name="formula-query.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Query.type">
        <rng:ref name="Query.content"/>
        <rng:ref name="Query.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Query"/>
</rng:start>
<rng:define name="Query">
<rng:element name="Query">
<rng:ref name="Query.type"/>
</rng:element>
</rng:define>
    <!--
      *** Answer ***
      Answer performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Answer
      
      It delivers the answer to a Query . The answer is given in terms of solved formulas, e.g.
      
      as a <Rulebase> that contains just 'solved' equations with the variable bindings
      
	  <Rulebase>
  		<Equal>
<Var>x</Var>
<Ind>a</Ind>
</Equal>
  		<Equal>
<Var>y</Var>
<Ind>b</Ind>
</Equal>
  		<Equal>
<Var>z</Var>
<Ind>c</Ind>
</Equal>
	  </Rulebase>
	  
	  as ground fact <Atom> matching the query / goal 
	  
	  <Atom>
	  	<Rel>p</Rel>
	  	<Ind>a</Ind>
	  	<Ind>b</Ind>
	  	<Ind>c</Ind>
	  </Atom>
	  
	  as solved ground entailments <Entails> of the answer from the queried (ground or instantiated / forward chained) rule base  
	  
	  With the optional <degree> role a truth/uncertainty value (between 0.0 and 1.0; 
	  with the truth values "1" for true and "0" for false in two-valued logics and "0.5" for unknown in three-valued logics) can be assigned to the answer. 
	  
	  An answer maybe be also just referenced by the local @key-@keyref mechanism  
	  or by the optional @iri attribute, in case of externally published answers. 
	  
	  With the optional @type attribute an answer type can be specified. 
	  The @safety optionally defines if the answer (event) is interrupting or non-interrupting 
	  and the @card attribute optionally defines the number of results contained in an Answer.
    -->
    <rng:define name="Answer.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Answer.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-answer.type"/>
</rng:element>
                <rng:ref name="formula-answer.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Answer.type">
        <rng:ref name="Answer.content"/>
        <rng:ref name="Answer.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Answer"/>
</rng:start>
<rng:define name="Answer">
<rng:element name="Answer">
<rng:ref name="Answer.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a performative (<Answer>).
		
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <rng:define name="formula-answer.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:ref name="Entails"/>
            <rng:ref name="query-connective.content"/>
            <rng:ref name="query-quantifier.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-answer.type">
        <rng:ref name="formula-answer.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <!--
		*** formula ***
		The formula role of a performative (<Assert>, <Retract>, <Update>,... or <Query>).

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <rng:define name="formula-assert.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:ref name="Implies"/>
            <rng:ref name="Rule"/>
            <rng:ref name="Equivalent"/>
            <rng:ref name="Entails"/>
            <rng:ref name="rulebase-quantifier.content"/>
            <rng:ref name="rulebase-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-query.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:ref name="Entails"/>
            <rng:ref name="query-connective.content"/>
            <rng:ref name="query-quantifier.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-assert.type">
        <rng:ref name="formula-assert.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-query.type">
        <rng:ref name="formula-query.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for description-related
            RuleML       elements. File: desc_module.xsd Version: 1.02 Last Modification: 2015-05-17
            [Adrian Paschke]       This module declares the following RuleML elements:
            * meta            descriptive metadata        * scope           scope  (e.g. for scoped
            reasoning)        * guard         guard (e.g. for guard constraints in scoped reasoning)
            * evaluation      semantic profile        * signature       interface signature, pattern
            definition,       * qualification   qualification, e.g. priorities, validity, strategy
            * quantification  quantification       * oid              See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-05-17T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
  *** oid ***
  An optional object identifier for an atomic formula, expression or the unifed terms
  of the SWSL branch, as needed for PSOA semantics.
  Note that oids are not required to be unique within a rulebase.
  
  See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-oid
  -->
    <rng:define name="oid.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="oid.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:ref name="Skolem"/>
            <rng:ref name="Reify"/>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="oid.type">
        <rng:ref name="oid.content"/>
        <rng:ref name="oid.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="oid"/>
</rng:start>
<rng:define name="oid">
<rng:element name="oid">
<rng:ref name="oid.type"/>
</rng:element>
</rng:define>
    <!-- 
     *** meta ***     
     
    An optional container for meta-knowledge about a Node.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-meta
-->
    <rng:define name="meta.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="meta.content">
        <rng:choice>
            <rng:ref name="formula-assert.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="meta.type">
        <rng:ref name="meta.content"/>
        <rng:ref name="meta.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="meta"/>
</rng:start>
<rng:define name="meta">
<rng:element name="meta">
<rng:ref name="meta.type"/>
</rng:element>
</rng:define>
    <!--
     *** scope ***
     
     metadata-based scope definition defined over the metadata annotations and the qualifications annotations.
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-scope
     
     Note: scope reasoning can use the metadata scopes to define a constructive view on the knowledge in the KB.    
     
-->
    <rng:define name="scope.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="scope.content">
        <rng:choice>
            <rng:optional>
<rng:ref name="formula-query.content"/>
</rng:optional>
        </rng:choice>
    </rng:define>
    <rng:define name="scope.type">
        <rng:ref name="scope.content"/>
        <rng:ref name="scope.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="scope"/>
</rng:start>
<rng:define name="scope">
<rng:element name="scope">
<rng:ref name="scope.type"/>
</rng:element>
</rng:define>
    <!--
     *** guard ***     
     
	guard constraints 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-guard
 -->
    <rng:define name="guard.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="guard.content">
        <rng:choice>
            <rng:ref name="if.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="guard.type">
        <rng:ref name="guard.content"/>
        <rng:ref name="guard.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="guard"/>
</rng:start>
<rng:define name="guard">
<rng:element name="guard">
<rng:ref name="guard.type"/>
</rng:element>
</rng:define>
    <!--
     *** evaluation ***
     
     The intended evaluation semantics, e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-evaluation

  -->
    <rng:define name="evaluation.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="evaluation.content">
        
            <rng:ref name="Profile"/>
        
    </rng:define>
    <rng:define name="evaluation.type">
        <rng:ref name="evaluation.content"/>
        <rng:ref name="evaluation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="evaluation"/>
</rng:start>
<rng:define name="evaluation">
<rng:element name="evaluation">
<rng:ref name="evaluation.type"/>
</rng:element>
</rng:define>
    <!--
     *** signature ***
     
     The signature defines the signature of knowledge (formula and terms) with optional input / output mode declarations. The signature declaration can act as public interface and
	can be published together with the intended evaluation semantics. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-signature
  -->
    <rng:define name="signature.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="signature.content">
        <rng:choice>
            <rng:ref name="formula-query.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="signature.type">
        <rng:ref name="signature.content"/>
        <rng:ref name="signature.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="signature"/>
</rng:start>
<rng:define name="signature">
<rng:element name="signature">
<rng:ref name="signature.type"/>
</rng:element>
</rng:define>
    <!--
     *** qualification ***
     
    Definition of the qualification (qualifying metadata), e.g. validity time, priorities, etc.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-qualification
-->
    <rng:define name="qualification.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="qualification.content">
        <rng:choice>
            <rng:ref name="formula-assert.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="qualification.type">
        <rng:ref name="qualification.content"/>
        <rng:ref name="qualification.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="qualification"/>
</rng:start>
<rng:define name="qualification">
<rng:element name="qualification">
<rng:ref name="qualification.type"/>
</rng:element>
</rng:define>
    <!--
     *** quantification ***
     
     Definition of the quantifier. 
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-quantification
        
-->
    <rng:define name="quantification.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="quantification.content">
        <rng:choice>
            <rng:ref name="meta-quantifier.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="quantification.type">
        <rng:ref name="quantification.content"/>
        <rng:ref name="quantification.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="quantification"/>
</rng:start>
<rng:define name="quantification">
<rng:element name="quantification">
<rng:ref name="quantification.type"/>
</rng:element>
</rng:define>
    <!-- extended descriptors in Reaction RuleML -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML quantifiers. File:
            quantifier_module.xsd Version: 1.02 Last Modification: 2015-07-16 This module declares
            the       following RuleML elements: * Forall * Exists * declare * formula See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** Forall ***
		Explicit universal quantifier.
		
		See http://www.ruleml.org/1.02/glossary/#gloss-Forall 
  -->
    <rng:define name="Forall.attlist">
        <rng:ref name="quantifier-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Forall.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-forall.type"/>
</rng:element>
                <rng:ref name="formula-forall.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Forall.type">
        <rng:ref name="Forall.content"/>
        <rng:ref name="Forall.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Forall"/>
</rng:start>
<rng:define name="Forall">
<rng:element name="Forall">
<rng:ref name="Forall.type"/>
</rng:element>
</rng:define>
    <!--
		*** Exists ***
		Explicit existential quantifier.

		See http://www.ruleml.org/1.02/glossary/#gloss-Exists
  -->
    <rng:define name="Exists.attlist">
        <rng:ref name="quantifier-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Exists.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-exists.type"/>
</rng:element>
                <rng:ref name="formula-exists.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Exists.type">
        <rng:ref name="Exists.content"/>
        <rng:ref name="Exists.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Exists"/>
</rng:start>
<rng:define name="Exists">
<rng:element name="Exists">
<rng:ref name="Exists.type"/>
</rng:element>
</rng:define>
    <!--
		*** declare ***
		A role used for variables declared within a quantifier.
		
		See http://www.ruleml.org/1.02/glossary/#gloss-declare
	-->
    <rng:define name="declare.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="declare.content">
        
            <rng:ref name="Var"/>
        
    </rng:define>
    <rng:define name="declare.type">
        <rng:ref name="declare.content"/>
        <rng:ref name="declare.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="declare"/>
</rng:start>
<rng:define name="declare">
<rng:element name="declare">
<rng:ref name="declare.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a quantifier (<Forall> or <Exists>).
		
		See http://www.ruleml.org/1.02/glossary/#gloss-formula
	-->
    <rng:define name="formula-forall.content">
        <rng:choice>
            <rng:ref name="Implies"/>
            <rng:ref name="Rule"/>
            <rng:ref name="Equivalent"/>
            <rng:ref name="head-quantifier.content"/>
            <rng:ref name="head-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-forall.type">
        <rng:ref name="formula-forall.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-exists.content">
        <rng:choice>
            <rng:ref name="query-quantifier.content"/>
            <rng:ref name="query-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-exists.type">
        <rng:ref name="formula-exists.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML connectives. File:
            connective_module.xsd Version: 1.02 Last Modification: 2015-02-21 [Tara Athan] This
            module       declares the following RuleML elements and attributes: * Implies * if *
            then * Entails *       Equivalent * torso * Rulebase * And * Or * formula        See
            http://www.ruleml.org/modularization for details       about this modularization
            approach. 
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!-- necessary for schematron -->
    <!-- 
	<xs:appinfo>
		
		<ns prefix="r" uri="http://ruleml.org/spec"/>
	</xs:appinfo> 
	-->
    <!--
		*** Implies ***
		An implication rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Implies
  -->
    <rng:define name="Implies.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="material.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Implies.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:ref name="then"/>
                    <rng:ref name="if"/>
                
                
                    <rng:ref name="if"/>
                    <rng:ref name="then"/>
                
                
                    <rng:ref name="if.content"/>
                    <rng:ref name="then.content"/>
                
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Implies.type">
        <rng:ref name="Implies.content"/>
        <rng:ref name="Implies.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Implies"/>
</rng:start>
<rng:define name="Implies">
<rng:element name="Implies">
<rng:ref name="Implies.type"/>
</rng:element>
</rng:define>
    <!-- 
		*** if ***
		The if of an implication rule containing the premise(s),
		also known as the "antecedent" or "if" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-if
	-->
    <rng:define name="if.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="if.content">
        <rng:choice>
            <rng:ref name="body-quantifier.content"/>
            <rng:ref name="body-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="if-entails.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:ref name="formula-rulebase.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="if.type">
        <rng:ref name="if.content"/>
        <rng:ref name="if.attlist"/>
    </rng:define>
    <rng:define name="if-entails.type">
        <rng:ref name="if-entails.content"/>
        <rng:ref name="if.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="if"/>
</rng:start>
<rng:define name="if">
<rng:element name="if">
<rng:ref name="if.type"/>
</rng:element>
</rng:define>
    <!--
		*** then ***
		The then of an implication rule containing the conclusion,
		also known as the "consequent" or "then" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-then
	-->
    <rng:define name="then.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="then.content">
        <rng:choice>
            <rng:ref name="head-quantifier.content"/>
            <rng:ref name="head-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="then-entails.content">
        <rng:choice>
            <rng:ref name="Rulebase"/>
            <rng:ref name="formula-rulebase.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="then.type">
        <rng:ref name="then.content"/>
        <rng:ref name="then.attlist"/>
    </rng:define>
    <rng:define name="then-entails.type">
        <rng:ref name="then-entails.content"/>
        <rng:ref name="then.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="then"/>
</rng:start>
<rng:define name="then">
<rng:element name="then">
<rng:ref name="then.type"/>
</rng:element>
</rng:define>
    <!--
		*** Entails ***
		Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
		Kowalski/Bowen's object/meta-level-amalgamated logic).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Entails
	-->
    <rng:define name="Entails.attlist">
        <rng:ref name="group-formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Entails.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:element name="if">
<rng:ref name="if-entails.type"/>
</rng:element>
                    <rng:ref name="if-entails.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:element name="then">
<rng:ref name="then-entails.type"/>
</rng:element>
                    <rng:ref name="then-entails.content"/>
                </rng:choice>
            
        
    </rng:define>
    <rng:define name="Entails.type">
        <rng:ref name="Entails.content"/>
        <rng:ref name="Entails.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Entails"/>
</rng:start>
<rng:define name="Entails">
<rng:element name="Entails">
<rng:ref name="Entails.type"/>
</rng:element>
</rng:define>
    <!--
		*** Equivalent ***
		An equivalence expression, which is "syntactic sugar" for a pair
		of conjoined converse implication rules.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equivalent		
  -->
    <rng:define name="Equivalent.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="material.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Equivalent.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            
                <rng:choice>
                    <rng:ref name="torso"/>
                    <rng:ref name="torso.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:ref name="torso"/>
                    <rng:ref name="torso.content"/>
                </rng:choice>
            
        
    </rng:define>
    <rng:define name="Equivalent.type">
        <rng:ref name="Equivalent.content"/>
        <rng:ref name="Equivalent.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Equivalent"/>
</rng:start>
<rng:define name="Equivalent">
<rng:element name="Equivalent">
<rng:ref name="Equivalent.type"/>
</rng:element>
</rng:define>
    <!--
		*** torso ***
		A symmetric role used in an equivalence expression combining
		the asymmetric <then> and <if>.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-torso
	-->
    <rng:define name="torso.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="torso.content">
        <rng:choice>
            <rng:ref name="head-quantifier.content"/>
            <rng:ref name="head-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="torso.type">
        <rng:ref name="torso.content"/>
        <rng:ref name="torso.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="torso"/>
</rng:start>
<rng:define name="torso">
<rng:element name="torso">
<rng:ref name="torso.type"/>
</rng:element>
</rng:define>
    <!--
		*** Rulebase ***
		A collection of rules that can be ordered or unordered, without or with duplicates.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rulebase
		
		@prefix for default prefix definitions 
		@vocab for default vocab definitions
  -->
    <rng:define name="Rulebase.attlist">
        <rng:ref name="group-formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Rulebase.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-rulebase.type"/>
</rng:element>
                <rng:ref name="formula-rulebase.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Rulebase.type">
        <rng:ref name="Rulebase.content"/>
        <rng:ref name="Rulebase.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rulebase"/>
</rng:start>
<rng:define name="Rulebase">
<rng:element name="Rulebase">
<rng:ref name="Rulebase.type"/>
</rng:element>
</rng:define>
    <!--
		*** And ***
		A conjunctive expression, where <And>Atom</And> is equivalent to Atom.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-And
	-->
    <rng:define name="And-body.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="And-query.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="And.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-and-or.type"/>
</rng:element>
                <rng:ref name="formula-and-or.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="And-query.type">
        <rng:ref name="And.content"/>
        <rng:ref name="And-query.attlist"/>
    </rng:define>
    <rng:define name="And-body.type">
        <rng:ref name="And.content"/>
        <rng:ref name="And-body.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="And"/>
</rng:start>
<rng:define name="And">
<rng:element name="And">
<rng:ref name="And-body.type"/>
</rng:element>
</rng:define>
    <!--
		*** Or ***
		A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Or
	-->
    <rng:define name="Or-query.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Or-body.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Or.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-and-or.type"/>
</rng:element>
                <rng:ref name="formula-and-or.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Or-query.type">
        <rng:ref name="Or.content"/>
        <rng:ref name="Or-query.attlist"/>
    </rng:define>
    <rng:define name="Or-body.type">
        <rng:ref name="Or.content"/>
        <rng:ref name="Or-body.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Or"/>
</rng:start>
<rng:define name="Or">
<rng:element name="Or">
<rng:ref name="Or-body.type"/>
</rng:element>
</rng:define>
    <!--
		*** formula ***
		The formula role of a conjunctive/disjunctive expression or a rulebase.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <rng:define name="formula.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="formula-and-or.content">
        <rng:choice>
            <rng:ref name="body-quantifier.content"/>
            <rng:ref name="body-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-rulebase.content">
        <rng:choice>
            <rng:element name="Implies">
<rng:ref name="Implies.type"/>
</rng:element>
            <rng:ref name="Rule"/>
            <rng:element name="Equivalent">
<rng:ref name="Equivalent.type"/>
</rng:element>
            <rng:ref name="rulebase-quantifier.content"/>
            <rng:ref name="rulebase-connective.content"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-and-or.type">
        <rng:ref name="formula-and-or.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <rng:define name="formula-rulebase.type">
        <rng:ref name="formula-rulebase.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       generic operation module of Reaction RuleML.
            This is the XML Schema connective operator module for Reaction RuleML.    File:
            connective_operator_module.xsd    Version: 1.02    Last Modification: 2015-03-22
            This schema declares the following Reaction RuleML elements and attributes:      *
            Operation         The approach is modelled after that used in "Modularization of XHTML
            in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
      *** generic Operation ***
      
      	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Operation
	-->
    <rng:define name="Operation-formula.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Operation-formula-rulebase.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-rulebase.type"/>
</rng:element>
                <rng:ref name="formula-rulebase.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Operation-formula-rulebase.type">
        <rng:ref name="Operation-formula-rulebase.content"/>
        <rng:ref name="Operation-formula.attlist"/>
    </rng:define>
    <rng:define name="Operation-formula-and-or.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-and-or.type"/>
</rng:element>
                <rng:ref name="formula-and-or.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Operation-formula-and-or.type">
        <rng:ref name="Operation-formula-and-or.content"/>
        <rng:ref name="Operation-formula.attlist"/>
    </rng:define>
    <rng:define name="Operation-formula-query.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-query.type"/>
</rng:element>
                <rng:ref name="formula-query.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Operation-formula-query.type">
        <rng:ref name="Operation-formula-query.content"/>
        <rng:ref name="Operation-formula.attlist"/>
    </rng:define>
    <rng:define name="Operation-term.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Operation-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="arg"/>
                <rng:ref name="arg.content"/>
                <rng:element name="content">
<rng:ref name="operation_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Operation-term.type">
        <rng:ref name="Operation-term.content"/>
        <rng:ref name="Operation-term.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
-->
    <rng:define name="operation_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="operation_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="operation_anycontent.type">
        <rng:ref name="operation_anycontent.content"/>
        <rng:ref name="operation_anycontent.attlist"/>
    </rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML atoms. File:
            atom_module.xsd Version: 1.02 Last Modification: 2015-02-21 This module declares
            the following RuleML elements and attributes: * Atom * op * Rel * degree See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>        )
            arguments.   Or a frame object with slots    See
            http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Atom
                <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
        *** Atom ***
		A logical atom , i.e. an expression formed from a predicate
		
	-->
    <rng:define name="Atom.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <!--
		These .extend groups, pointed to by Atom.content, are necessary
		for redefinition to be binary in bindatalog and to add rest
		variables in hornlog.
	-->
    <rng:define name="Atom-repo.extend">
        <rng:choice>
            <rng:ref name="Atom-arg.extend"/>
            <rng:ref name="repo"/>
        </rng:choice>
    </rng:define>
    <rng:define name="Atom-arg.extend">
        
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="arg"/>
                <rng:ref name="arg.content"/>
            </rng:choice>
</rng:oneOrMore>
            <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Atom-slots.extend1">
        
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Atom-slots.extend2">
        
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Atom.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                <!-- operator optional for frame representation -->
                <rng:element name="op">
<rng:ref name="op-atom.type"/>
</rng:element>
                <rng:ref name="op-atom.content"/>
            </rng:choice>
</rng:optional>
            <rng:ref name="Atom-slots.extend1"/>
            <rng:optional>
<rng:choice>
                
                    <rng:ref name="Atom-repo.extend"/>
                    <rng:ref name="Atom-slots.extend1"/>
                
            </rng:choice>
</rng:optional>
            <rng:ref name="Atom-slots.extend2"/>
        
    </rng:define>
    <rng:define name="Atom.type">
        <rng:ref name="Atom.content"/>
        <rng:ref name="Atom.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Atom"/>
</rng:start>
<rng:define name="Atom">
<rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
</rng:define>
    <!--
		*** op ***
		An operator expression including the relation of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-op
	-->
    <rng:define name="op.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="op-atom.content">
        
            <rng:ref name="Rel"/>
        
    </rng:define>
    <rng:define name="op-atom.type">
        <rng:ref name="op-atom.content"/>
        <rng:ref name="op.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="op"/>
</rng:start>
<rng:define name="op">
<rng:element name="op">
<rng:ref name="op-atom.type"/>
</rng:element>
</rng:define>
    <!--
		*** Rel ***
		A relation, i.e. a logical predicate, of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rel		
	-->
    <rng:define name="Rel.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Rel.content">
        <rng:text/>         
    </rng:define>
    <rng:define name="Rel.type">
        <rng:ref name="Rel.content"/>
        <rng:ref name="Rel.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rel"/>
</rng:start>
<rng:define name="Rel">
<rng:element name="Rel">
<rng:ref name="Rel.type"/>
</rng:element>
</rng:define>
    <!-- 
		*** degree ***

		An optional uncertainty value (between 0.0 and 1.0)
		that may be assigned to facts and rules.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-degree

	-->
    <rng:define name="degree.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="degree.content">
        
            <rng:ref name="Data"/>
        
    </rng:define>
    <rng:define name="degree.type">
        <rng:ref name="degree.content"/>
        <rng:ref name="degree.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="degree"/>
</rng:start>
<rng:define name="degree">
<rng:element name="degree">
<rng:ref name="degree.type"/>
</rng:element>
</rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML slots. File:
            slot_module.xsd Version: 1.02 Last Modification: 2015-07-16 This module declares the
            following       RuleML element and attributes: * slot        See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** slot ***
		A user-defined slot consisting of a name (first position) and a filler (second position).
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-slot
	-->
    <rng:define name="slot.attlist">
        <rng:ref name="card.attrib"/>
        <rng:ref name="weight.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="slot-name.extend">
        <rng:choice>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="slot.content">
        
            <rng:ref name="slot-name.extend"/>
            <rng:ref name="arg.content"/>
        
    </rng:define>
    <rng:define name="slot.type">
        <rng:ref name="slot.content"/>
        <rng:ref name="slot.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="slot"/>
</rng:start>
<rng:define name="slot">
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML terms. File:
            term_module.xsd Version: 1.02 Last Modification: 2015-04-03 This module declares the
            following       RuleML elements and attributes: * arg * Ind * Data * Var * Skolem *
            Reify as       well as including a number of complex types for use in expicitly-typed
            data Nodes. See       http://www.ruleml.org/modularization for details about this
            modularization approach.     
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-04-03T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** arg ***
		A role used for the positional arguments of a logical atom.
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg 
	-->
    <rng:define name="arg.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:ref name="Skolem"/>
            <rng:ref name="Reify"/>
            <rng:ref name="extended-signature-function-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg.type">
        <rng:ref name="arg.content"/>
        <rng:ref name="arg.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="arg"/>
</rng:start>
<rng:define name="arg">
<rng:element name="arg">
<rng:ref name="arg.type"/>
</rng:element>
</rng:define>
    <!--
		*** Ind ***
		An individual constant, as in predicate logic, which can also be considered to
		be a fixed argument like RDF resources.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Ind
	-->
    <rng:define name="Ind.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Ind.content">
        <rng:text/>        
    </rng:define>
    <rng:define name="Ind.type">
        <rng:ref name="Ind.content"/>
        <rng:ref name="Ind.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Ind"/>
</rng:start>
<rng:define name="Ind">
<rng:element name="Ind">
<rng:ref name="Ind.type"/>
</rng:element>
</rng:define>
    <!--
		*** Data ***
		A fixed argument like RDF literals, allowing XML data.  It may be
		optionally associated with an XML Schema built-in datatype
		(see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
		using the built-in xsi:type attribute.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Data
  -->
    <rng:start combine="choice">
<rng:ref name="Data"/>
</rng:start>
<rng:define name="Data">
<rng:element name="Data">
<rng:data type="string"/>
</rng:element>
</rng:define>
    <!--
		*** Var ***
		A logical variable, as in logic programming.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Var
	-->
    <rng:define name="Var.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Var.content">
        <rng:text/>        
    </rng:define>
    <rng:define name="Var.type">
        <rng:ref name="Var.content"/>
        <rng:ref name="Var.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Var"/>
</rng:start>
<rng:define name="Var">
<rng:element name="Var">
<rng:ref name="Var.type"/>
</rng:element>
</rng:define>
    <!--
		*** Skolem ***
		A Skolem individual constant, like RDF's blank nodes.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Skolem
	-->
    <rng:define name="Skolem.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Skolem.content">
        <rng:text/>        
    </rng:define>
    <rng:define name="Skolem.type">
        <rng:ref name="Skolem.content"/>
        <rng:ref name="Skolem.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Skolem"/>
</rng:start>
<rng:define name="Skolem">
<rng:element name="Skolem">
<rng:ref name="Skolem.type"/>
</rng:element>
</rng:define>
    <!--
		*** Reify ***
		Supports reification (a kind of instantiation or quasi-quotation). It allows any RuleML tag available within the
		current sublanguage as content, treating it as a term for performing reasoning on.
				
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Reify		
	-->
    <rng:define name="Reify.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Reify.content">
        
            <!--
		  <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/> -->
            <!-- <Reify> only allows valid RuleML -->
            <!--<xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>-->
            <rng:optional>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:optional>
        
    </rng:define>
    <rng:define name="Reify.type">
        <rng:ref name="Reify.content"/>
        <rng:ref name="Reify.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Reify"/>
</rng:start>
<rng:define name="Reify">
<rng:element name="Reify">
<rng:ref name="Reify.type"/>
</rng:element>
</rng:define>
    <!-- includes the hornlog layer with the 'expr' and 'rest' modules -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML expressions. File:
            expr_module.xsd Version: 1.02 Last Modification: 2015-10-05 [Tara Athan] This module
            declares       the following RuleML elements and attributes: * Expr * op * Fun * Plex *
            @per See       http://www.ruleml.org/modularization for details about this
            modularization approach. 
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-10-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
        <!-- necessary for schematron -->
        <!-- 
		<xs:appinfo>

		<sch:ns prefix="r" iri="http://www.deliberation.ruleml.org/1.02/xsd"/>
		-->
    </a:documentation>
    <!--
		*** Expr ***
		A logical function of the form "f(...)" where f is a function name.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Expr
	-->
    <rng:define name="Expr.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Expr.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                <rng:element name="op">
<rng:ref name="op-Expr.type"/>
</rng:element>
                <rng:ref name="op-Expr.content"/>
            </rng:choice>
</rng:optional>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                
                    <rng:choice>
                        
                            <rng:oneOrMore>
<rng:choice>
                                <rng:ref name="arg"/>
                                <rng:ref name="arg.content"/>
                            </rng:choice>
</rng:oneOrMore>
                            <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                        
                        <rng:ref name="repo"/>
                    </rng:choice>
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                
            </rng:choice>
</rng:optional>
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Expr.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Uninterpreted functions">
					<sch:rule context="r:Expr/r:Fun[@per='no']">
						<sch:assert test=
								"not(../r:Expr/r:Fun[@per='yes'] or
									 ../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
					<sch:rule context="r:Expr/r:op/r:Fun[@per='no']">
						<sch:assert test=
								"not(../../r:Expr/r:Fun[@per='yes'] or
									 ../../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <rng:ref name="Expr.content"/>
        <rng:ref name="Expr.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Expr"/>
</rng:start>
<rng:define name="Expr">
<rng:element name="Expr">
<rng:ref name="Expr.type"/>
</rng:element>
</rng:define>
    <!--
		*** op ***
		An operator expression including the function name of an expression.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-op
				
	-->
    <!-- the (empty) attribute list is declared in the atom module -->
    <rng:define name="op-Expr.content">
        
            <rng:ref name="Fun"/>
        
    </rng:define>
    <rng:define name="op-Expr.type">
        <rng:ref name="op-Expr.content"/>
        <rng:ref name="op.attlist"/>
    </rng:define>
    <!--
		*** Fun ***
		A user-defined function name.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Fun
	-->
    <rng:define name="Fun.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Fun.content">
        <rng:text/>         
    </rng:define>
    <rng:define name="Fun.type">
        <rng:ref name="Fun.content"/>
        <rng:ref name="Fun.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Fun"/>
</rng:start>
<rng:define name="Fun">
<rng:element name="Fun">
<rng:ref name="Fun.type"/>
</rng:element>
</rng:define>
    <!--
		*** Plex ***
		An unordered collection of arguments without a constructor.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Plex
	-->
    <rng:define name="Plex.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Plex.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                
                    <rng:oneOrMore>
<rng:choice>
                        <rng:ref name="arg"/>
                        <rng:ref name="arg.content"/>
                    </rng:choice>
</rng:oneOrMore>
                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                
                    <rng:ref name="repo"/>
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                
                    <rng:ref name="resl"/>
                
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Plex-repo.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="arg"/>
                <rng:ref name="arg.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Plex-resl.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Plex.type">
        <rng:ref name="Plex.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:define name="Plex-repo.type">
        <rng:ref name="Plex-repo.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:define name="Plex-resl.type">
        <rng:ref name="Plex-resl.content"/>
        <rng:ref name="Plex.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Plex"/>
</rng:start>
<rng:define name="Plex">
<rng:element name="Plex">
<rng:ref name="Plex.type"/>
</rng:element>
</rng:define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML rest variables.
            File:       rest_module.xsd Version: 1.02 Last Modification: 2015-07-05 This module
            declares the following       RuleML elements: * repo * resl See
            http://www.ruleml.org/modularization for details about this       modularization
            approach. 
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** repo ***
		A positional rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-repo
	-->
    <rng:define name="repo.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="repo.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:element name="Plex">
<rng:ref name="Plex-repo.type"/>
</rng:element>
        </rng:choice>
    </rng:define>
    <rng:define name="repo.type">
        <rng:ref name="repo.content"/>
        <rng:ref name="repo.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="repo"/>
</rng:start>
<rng:define name="repo">
<rng:element name="repo">
<rng:ref name="repo.type"/>
</rng:element>
</rng:define>
    <!--
		*** resl ***
		A slotted rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-resl		
	-->
    <rng:define name="resl.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="resl.content">
        <rng:choice>
            <rng:ref name="Var"/>
            <rng:element name="Plex">
<rng:ref name="Plex-resl.type"/>
</rng:element>
        </rng:choice>
    </rng:define>
    <rng:define name="resl.type">
        <rng:ref name="resl.content"/>
        <rng:ref name="resl.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="resl"/>
</rng:start>
<rng:define name="resl">
<rng:element name="resl">
<rng:ref name="resl.type"/>
</rng:element>
</rng:define>
    <!-- includes the equalog layer with the 'equality' module -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for equality in RuleML. File:
            equality_module.xsd Version: 1.02 Last Modification: 2015-02-21 [Tara Athan] This module
            declares the following RuleML elements and attributes: * Equal * left * right        See
            http://www.ruleml.org/modularization for details about this modularization approach. 
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** Equal ***
		An equational formula consisting of two expressions.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equal

	-->
    <rng:define name="Equal.attlist">
        <rng:ref name="oriented.attrib"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Equal.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:ref name="left"/>
                    <rng:ref name="right"/>
                
                <!-- note that (right, left) is disallowed -->
                
                    <rng:ref name="left.content"/>
                    <rng:ref name="right.content"/>
                
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Equal.type">
        <rng:ref name="Equal.content"/>
        <rng:ref name="Equal.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Equal"/>
</rng:start>
<rng:define name="Equal">
<rng:element name="Equal">
<rng:ref name="Equal.type"/>
</rng:element>
</rng:define>
    <!--
		*** left ***
		The left-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-left
	
	-->
    <rng:define name="left.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="left.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="left.type">
        <rng:ref name="left.content"/>
        <rng:ref name="left.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="left"/>
</rng:start>
<rng:define name="left">
<rng:element name="left">
<rng:ref name="left.type"/>
</rng:element>
</rng:define>
    <!--
		*** right***
		The right-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-right
	-->
    <rng:define name="right.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="right.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="right.type">
        <rng:ref name="right.content"/>
        <rng:ref name="right.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="right"/>
</rng:start>
<rng:define name="right">
<rng:element name="right">
<rng:ref name="right.type"/>
</rng:element>
</rng:define>

    <rng:define name="curieOrIRI.datatype">
        <rng:choice>
<rng:ref name="curie.datatype"/>
<rng:data type="anyURI"/>
</rng:choice>
    </rng:define>
    <rng:define name="curieOrAbsIRI.datatype">
        <rng:choice>
<rng:ref name="curie.datatype"/>
<rng:ref name="absIRI.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="termOrCurieOrIRI.datatype">
        <rng:choice>
<rng:ref name="term.datatype"/>
<rng:ref name="curie.datatype"/>
<rng:data type="anyURI"/>
</rng:choice>
    </rng:define>
    <rng:define name="termOrCurieOrIRIs.datatype">
        <rng:list>
<rng:ref name="termOrCurieOrIRI.datatype"/>
</rng:list>
    </rng:define>
    <rng:define name="termOrCurieOrAbsIRI.datatype">
        <rng:choice>
<rng:ref name="term.datatype"/>
<rng:ref name="curie.datatype"/>
<rng:ref name="absIRI.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="termOrCurieOrAbsIRIs.datatype">
        <rng:list>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
</rng:list>
    </rng:define>
    <rng:define name="absIRI.datatype">
        <rng:data type="anyURI">
            <rng:param name="pattern">[\i-[:]][\c-[:]]+:.+</rng:param>
        </rng:data>
    </rng:define>
    <rng:define name="curie.datatype">
        <rng:data type="string">
            <rng:param name="minLength">1</rng:param>
            <rng:param name="pattern">(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)</rng:param>
        </rng:data>
    </rng:define>
    <rng:define name="term.datatype">
        <rng:data type="Name">
            <rng:param name="pattern">[\i-[:]][/\c-[:]]*</rng:param>
        </rng:data>
    </rng:define>
    <!--
           *** @mode ***
           An attribute for optionally specifying the intended input-output constellations of formulas and terms with the
           following semantics:
        
           "+" The formula/term is intended to be input
           "-" The formula/term is intended to be output
           "?" The formula/term is undefined (input or output)
           "[iri]" the formula/term's mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)  
		   
			By default the mode of formulas when used as conditions, constraints, queries and event patterns is "+" (input)
			and the mode of conclusions, answers and active actions is "-" (output). Variables are "?" (open) by default.
			optional attribute
			
			See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40mode
-->
    <rng:define name="mode.attrib">
        <rng:optional>
<rng:attribute name="mode" a0:defaultValue="?" xmlns:a0="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-modes.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-modes.datatype">
        <rng:choice>
            <rng:value>+</rng:value>
            <rng:value>-</rng:value>
            <rng:value>?</rng:value>
        </rng:choice>
    </rng:define>
    <!--
	  *** @safety ***

	     restriction: interrupting, non-interrupting or transactional or
	     "[iri]" the formula/term's safety mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)
	     
		 default: non-interrupting 
		 optional attribute
		 
		 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40safety
	-->
    <rng:define name="safety.attrib">
        <rng:optional>
<rng:attribute name="safety" a1:defaultValue="non-interrupting" xmlns:a1="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-safety.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-safety.datatype">
        <rng:choice>
            <rng:value>non-interrupting</rng:value>
            <rng:value>interrupting</rng:value>
            <rng:value>transactional</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @per ***
		An optinal attribute indicating how a formulas, terms and operators are interpreted.
		
		Default for formulas is per "value" (truth valuation), for terms per "copy", for modal operators per "modal" and for actions/performatives by "effect".		
		In "reasoning" dialects the default for actions and events is per "value" and in active / messaging dialects it is per "effect".
		In "non-reified" representations as formulas default interpretation per "value" and in "reified" representations as term default interpretation is per copy. 
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40per
	-->
    <rng:define name="per.attrib">
        <rng:optional>
<rng:attribute name="per">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-per.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-per.datatype">
        <rng:choice>
            <rng:value>copy</rng:value>
            <rng:value>value</rng:value>
            <rng:value>effect</rng:value>
            <rng:value>modal</rng:value>
            <rng:value>open</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @size  ***
		An attribute indicating the size of a counter		
		-1 = unbound / all
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40size
	-->
    <!-- 
		
		replaced by card 
		
		<xs:attributeGroup name="size.attrib">
		<xs:attribute name="size" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="mapSize.attrib">
		<xs:attribute name="mapSize" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>-->
    <!--
    *** @style ***
    
    The style attribute defines the styles of the intended semantics. 
    Predefined semantics are "active", "reasoning", "messaging". 
    Further intented semantics can be defined by semantic profiles internally in the <evaluation> role
    or externally. They can be referenced by ther profile name (term) or resource locator (curie or absolute IRI).
    
   restriction: active | messaging | reasoning | "[IRIs]" (vocabulary terms or curies or absolute IRIs)

	 default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40style
	-->
    <rng:define name="style.datatype">
        <rng:choice>
<rng:ref name="termOrCurieOrAbsIRIs.datatype"/>
<rng:ref name="vocab-style.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="vocab-style.datatype">
        <rng:choice>
            <rng:value>active</rng:value>
            <rng:value>messaging</rng:value>
            <rng:value>reasoning</rng:value>
        </rng:choice>
    </rng:define>
    <!--
    *** @key ***
    
    optinal unique local key on all knowledge formulas
    
	 optinal attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40key
	-->
    <rng:define name="key.attrib">
        <rng:optional>
<rng:attribute name="key">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @keyref ***
    
    corresponding reference to a unique local key
    
	 optinal attribute
	 
	 http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40keyref
	-->
    <rng:define name="keyref.attrib">
        <rng:optional>
<rng:attribute name="keyref">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @node ***
    An optional identification label for a Node, creating accessibility within
    the knowledge representation.
    This can help for representing prioritization between rules, for example. 
    The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
    such a label.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40node
    
    content model: (curieOrAbsIRI.datatype)
  -->
    <rng:define name="node.attrib">
        <rng:optional>
<rng:attribute name="node">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @type ***
		An attribute for optionally specifying a (user-defined) type.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40type
		
		Note: In Reaction RuleML the type is changed to Term or Curie or absolute IRI to allow references
		to internal vocabulary terms (e.g. local sort signature definitions) and external vocabulary types (sorts) 
	-->
    <rng:define name="type.attrib">
        <rng:optional>
<rng:attribute name="type">
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @meta ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines descriptive meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <meta> role)
     or external metadata vocabularies.
     
	 By default knowledge is contextually annotated by metadata about the source (@src([Locator])) and the name (@label([OID])),
	 with "Locator" being the source location (location of Reaction RuleML knowledge base in which the knowledge is defined) 
	 and OID being the implicitly or explicitly defined object identifer of the knowledge.
	 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40meta
	-->
    <rng:define name="meta.attrib">
        <rng:optional>
<rng:attribute name="meta">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRIs.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @qualify ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines qualifying meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <qualification> role)
     or external metadata vocabularies.
      
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40qualify
	-->
    <rng:define name="qualify.attrib">
        <rng:optional>
<rng:attribute name="qualify">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRIs.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
    *** @scope ***
    
     restriction: global | local | private | "[iris]" (terms or curies or absolute IRIs)
     
     Defines a scope. Predefined scopes are global, local, private. 
     Internal dynamic scopes defined by metadata views (defined in the <scope> role) can be references by the oid name term (<oid>)
     and externally defined scopes by their IRI.
     
	 default value: "global" for relations and functions and "local" for terms 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40scope
	-->
    <rng:define name="scope-formula.attrib">
        <rng:optional>
<rng:attribute name="scope" a2:defaultValue="global" xmlns:a2="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRIs.datatype"/>
<rng:ref name="vocab-scope.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="scope-term.attrib">
        <rng:optional>
<rng:attribute name="scope" a3:defaultValue="local" xmlns:a3="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRIs.datatype"/>
<rng:ref name="vocab-scope.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-scope.datatype">
        <rng:choice>
            <rng:value>local</rng:value>
            <rng:value>global</rng:value>
            <rng:value>private</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @arity ***
		An optional attribute for specifying the arity of a signature.
		The arity of constants / individual objects is zero.
		The arity of predicates and functions is the number of arguments they have.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40arity
	-->
    <rng:define name="arity.attrib">
        <rng:optional>
<rng:attribute name="arity">
<rng:data type="nonNegativeInteger"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @prefix ***
		
		a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40prefix
		
	-->
    <rng:define name="prefix.attrib">
        <rng:optional>
<rng:attribute name="prefix">
<rng:ref name="prefix.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="prefix.datatype">
        <rng:data type="string">
            <rng:param name="minLength">1</rng:param>
            <rng:param name="pattern">([\i-[:]][\c-[:]]*)?</rng:param>
        </rng:data>
    </rng:define>
    <!--
		*** @vocab ***
		
		an IRI that defines the vocabulary mapping to use when a TERM is referenced in an attribute value.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40vocab
				
	-->
    <rng:define name="vocab.attrib">
        <rng:optional>
<rng:attribute name="vocab">
<rng:data type="anyURI"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @card @minCard @maxCard ***
		An attribute optionally specifying the cardinality.
		
		"-1" = unbound
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40card
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40maxCard
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40minCard
	-->
    <rng:define name="card.attrib">
        <rng:optional>
<rng:attribute name="card">
<rng:data type="int"/>
</rng:attribute>
</rng:optional>
        <rng:optional>
<rng:attribute name="maxCard">
<rng:data type="int"/>
</rng:attribute>
</rng:optional>
        <rng:optional>
<rng:attribute name="minCard">
<rng:data type="nonNegativeInteger"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @weight ***
		An attribute optionally specifying a relative weight.
		The default is "1", i.e. all knowledge has the same weight of "1". 
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40weight		
	-->
    <rng:define name="weight.attrib">
        <rng:optional>
<rng:attribute name="weight">
            
                <rng:data type="decimal">
                    <rng:param name="minInclusive">0</rng:param>
                    <rng:param name="maxInclusive">1</rng:param>
                </rng:data>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @direction ***
		An attribute indicating the intended direction of an implication rule's inferencing.
		default is bidirectional.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40direction
	-->
    <rng:define name="direction.attrib">
        <rng:optional>
<rng:attribute name="direction">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-direction.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-direction.datatype">
        <rng:choice>
            <rng:value>forward</rng:value>
            <rng:value>backward</rng:value>
            <rng:value>bidirectional</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @closure ***
		An attribute indicating how the contained free variables are quantified.
		default is universal closure.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40closure		
	-->
    <rng:define name="closure.attrib">
        <rng:optional>
<rng:attribute name="closure">
            
                <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-closure.datatype"/>
</rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="vocab-closure.datatype">
        <rng:choice>
            <rng:value>universal</rng:value>
            <rng:value>existential</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @material ***
		An attribute indicating the kind of an implication rule.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40material
	-->
    <rng:define name="material.attrib">
        <rng:optional>
<rng:attribute name="material">
<rng:ref name="material.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <rng:define name="material.datatype">
        <rng:choice>
<rng:ref name="termOrCurieOrAbsIRI.datatype"/>
<rng:ref name="vocab-material.datatype"/>
</rng:choice>
    </rng:define>
    <rng:define name="vocab-material.datatype">
        <rng:choice>
            <rng:value>yes</rng:value>
            <rng:value>no</rng:value>
        </rng:choice>
    </rng:define>
    <!--
		*** @iri ***
		An attribute for referring to a Curie or absolute IRI.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40iri
	-->
    <rng:define name="iri.attrib">
        <rng:optional>
<rng:attribute name="iri">
<rng:ref name="curieOrAbsIRI.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @index ***
		An optional attribute for specifying an ordering on roles.
		
		Note: in Reaction RuleML @index is optional
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40index
	-->
    <rng:define name="index.attrib">
        <rng:optional>
<rng:attribute name="index">
<rng:data type="positiveInteger"/>
</rng:attribute>
</rng:optional>
    </rng:define>
    <!--
		*** @oriented ***
		An attribute indicating whether an equation is oriented (directed)
		or unoriented (symmetric).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40oriented
	-->
    <rng:define name="oriented.attrib">
        <rng:optional>
<rng:attribute name="oriented">
            
                <rng:choice>
                    <rng:value>yes</rng:value>
                    <rng:value>no</rng:value>
                </rng:choice>
            
        </rng:attribute>
</rng:optional>
    </rng:define>
    <!-- 
 
  	a group of attributes for all XML elements in Reaction RuleML

	@prefix?, @key?, @keyref?, @xml:id?, @xml:base?
 
  	@key and @keyref attributes for local syntactic modularization of the knowledge base
  	   
  	-->
    <rng:define name="xml.attlist">
        <rng:ref name="prefix.attrib"/>
        <rng:ref name="key.attrib"/>
        <rng:ref name="keyref.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for all XML node elements (type elements) in Reaction RuleML
  	
	@meta?, @qualify?, @node?, @iri?, @vocab?
   	   
  	-->
    <rng:define name="node-element.attlist">
        <rng:ref name="node.attrib"/>
        <rng:ref name="iri.attrib"/>
        <rng:ref name="vocab.attrib"/>
        <rng:ref name="meta.attrib"/>
        <rng:ref name="qualify.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for all XML edge elements (role elements) in Reaction RuleML
  	
	@index?
   	   
  	-->
    <rng:define name="edge-element.attlist">
        <rng:ref name="index.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all grouping formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?  
	
	attributes of grouping formulas are automatically inherited as default attributes to all formulas in the group.
  	-->
    <rng:define name="group-formula-interface.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="material.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all knowledge formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?

   	   
  	-->
    <rng:define name="formula-interface.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="arity.attrib"/>
        <rng:ref name="card.attrib"/>
        <rng:ref name="weight.attrib"/>
        <rng:ref name="style.attrib"/>
        <rng:ref name="direction.attrib"/>
        <rng:ref name="scope-formula.attrib"/>
        <rng:ref name="closure.attrib"/>
        <rng:ref name="mode.attrib"/>
        <rng:ref name="per.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all terms in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?
   	   
  	-->
    <rng:define name="term-interface.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="arity.attrib"/>
        <rng:ref name="card.attrib"/>
        <rng:ref name="weight.attrib"/>
        <rng:ref name="style.attrib"/>
        <rng:ref name="scope-term.attrib"/>
        <rng:ref name="mode.attrib"/>
        <rng:ref name="per.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all quantifiers in Reaction RuleML
  	
	@type?, @card?, @minCard?, @maxCard?, @style?, @scope?
  	-->
    <rng:define name="quantifier-interface.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="card.attrib"/>
        <rng:ref name="style.attrib"/>
        <rng:ref name="scope-formula.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all connectives/operators in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
  	-->
    <rng:define name="operator-interface.attlist">
        <rng:ref name="type.attrib"/>
        <rng:ref name="arity.attrib"/>
        <rng:ref name="card.attrib"/>
        <rng:ref name="weight.attrib"/>
        <rng:ref name="style.attrib"/>
        <rng:ref name="direction.attrib"/>
        <rng:ref name="scope-formula.attrib"/>
        <rng:ref name="mode.attrib"/>
        <rng:ref name="closure.attrib"/>
        <rng:ref name="per.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all action / performatives in Reaction RuleML
  	
	@safety?
  	-->
    <rng:define name="action-interface.attlist">
        <rng:ref name="safety.attrib"/>
    </rng:define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all events in Reaction RuleML
  	
	@safety?
  	-->
    <rng:define name="event-interface.attlist">
        <rng:ref name="safety.attrib"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                              Rules module part of Reaction RuleML.
            It defines the core            Rule construct used as basis for all types of rules in
            Reaction RuleML                      This is the XML Schema rule module for Reaction
            RuleML.           File: rule_module.xsd           Version: 1.02           Last
            Modification: 2015-03-29                      This schema declares the following
            Reaction RuleML elements and attributes:                      * Rule           * on
            * if           * then           * do           * after                     * else
            * elseDo           * elseAfter                          
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
      *** Rule ***
      The Rule element that provides the basic syntax for rules
      in Reaction RuleML.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rule
-->
    <rng:define name="Rule.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="material.attrib"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Rule.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:ref name="rule-implementation.content"/>
</rng:optional>
        
    </rng:define>
    <rng:define name="Rule.type">
        <rng:ref name="Rule.content"/>
        <rng:ref name="Rule.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Rule"/>
</rng:start>
<rng:define name="Rule">
<rng:element name="Rule">
<rng:ref name="Rule.type"/>
</rng:element>
</rng:define>
    <!--
     *** on ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-on
-->
    <rng:define name="on.attlist">
        <rng:ref name="xml.attlist"/>
        <rng:ref name="edge-element.attlist"/>
    </rng:define>
    <rng:define name="on.content">
        <rng:choice>
            <rng:ref name="event_group.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="on.type">
        <rng:ref name="on.content"/>
        <rng:ref name="on.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="on"/>
</rng:start>
<rng:define name="on">
<rng:element name="on">
<rng:ref name="on.type"/>
</rng:element>
</rng:define>
    <!--
     *** if ***
     *** after ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-if
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-after
	-->
    <rng:start combine="choice">
<rng:ref name="after"/>
</rng:start>
<rng:define name="after">
<rng:element name="after">
<rng:ref name="if.type"/>
</rng:element>
</rng:define>
    <!--
	 *** then ***	
     *** else ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-then
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-else
	-->
    <rng:start combine="choice">
<rng:ref name="else"/>
</rng:start>
<rng:define name="else">
<rng:element name="else">
<rng:ref name="then.type"/>
</rng:element>
</rng:define>
    <!--
     *** do ***
     *** elseDo ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-do
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-elseDo
	-->
    <rng:define name="do.attlist">
        <rng:ref name="xml.attlist"/>
        <rng:ref name="edge-element.attlist"/>
    </rng:define>
    <rng:define name="do.content">
        <rng:choice>
            <rng:ref name="action_group.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="do.type">
        <rng:ref name="do.content"/>
        <rng:ref name="do.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="do"/>
</rng:start>
<rng:define name="do">
<rng:element name="do">
<rng:ref name="do.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="elseDo"/>
</rng:start>
<rng:define name="elseDo">
<rng:element name="elseDo">
<rng:ref name="do.type"/>
</rng:element>
</rng:define>
    <!--
  *** Derivation Rule content model ***  	
	-->
    <rng:define name="DerivationRule.content">
        <rng:choice>
            
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:ref name="then"/>
                <rng:ref name="if"/>
            
            
                <rng:ref name="if"/>
                <rng:ref name="then"/>
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
            
            
                <rng:ref name="if.content"/>
                <rng:ref name="then.content"/>
                <rng:optional>
<rng:ref name="then.content"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!--
   *** Production Rule content model ***
	-->
    <rng:define name="ProductionRule.content">
        <rng:choice>
            
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
                <rng:ref name="do"/>
                <rng:ref name="if"/>
            
            
                <rng:ref name="if"/>
                <rng:ref name="do"/>
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!--
   *** Combined DR Production Rule content model ***
    -->
    <rng:define name="DRProductionRule.content">
        <rng:choice>
            
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:ref name="do"/>
                <rng:optional>
<rng:ref name="then"/>
</rng:optional>
                <rng:ref name="if"/>
            
            
                <rng:ref name="if"/>
                <rng:optional>
<rng:ref name="then"/>
</rng:optional>
                <rng:optional>
<rng:ref name="do"/>
</rng:optional>
                <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
            
        </rng:choice>
    </rng:define>
    <!--
   *** ECA Reaction Rule content model ***
    -->
    <rng:define name="ReactionRule.content">
        
            <rng:ref name="on"/>
            <rng:optional>
<rng:choice>
                
                    <rng:optional>
<rng:ref name="if"/>
</rng:optional>
                    <rng:optional>
<rng:ref name="then"/>
</rng:optional>
                    <rng:optional>
<rng:ref name="do"/>
</rng:optional>
                    <rng:optional>
<rng:ref name="after"/>
</rng:optional>
                    <rng:optional>
<rng:ref name="else"/>
</rng:optional>
                    <rng:optional>
<rng:ref name="elseDo"/>
</rng:optional>
                
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <!--
   *** CEP Messaging Rule content model ***
   
   CEP rules allow arbitrary combinations and repititions of the rule's content model
   -->
    <rng:define name="MessagingRule.content">
        
            <rng:oneOrMore>
<rng:choice>
                <rng:ref name="on"/>
                <rng:ref name="if"/>
                <rng:ref name="then"/>
                <rng:ref name="do"/>
                <rng:ref name="after"/>
                <rng:ref name="else"/>
                <rng:ref name="elseDo"/>
            </rng:choice>
</rng:oneOrMore>
        
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Negation module part of Reaction RuleML.   This
            defines the negation elements for Reaction RuleML.   File: negation_module.xsd
            Version: 1.02   Last Modification: 2015-03-22      * Negation  generic polymorphig
            negation   * Naf           negation as failure (inflationary negation in production
            rules), weak negation   * Neg           classical negation, strong negation   * weak
            * strong   * formula        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
		*** Negation ***
		A generic polymorphic negation
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Negation
		
		It can be specialized by using
		the @type attribute to specify the type of negation and/or 
 		the @iri attribute to point to an external definition of the negation
 		@key, @keyref, @node
		-->
    <rng:define name="Negation.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Negation.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-negation.type"/>
</rng:element>
                <rng:ref name="formula-negation.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Negation.type">
        <rng:ref name="Negation.content"/>
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Negation"/>
</rng:start>
<rng:define name="Negation">
<rng:element name="Negation">
<rng:ref name="Negation.type"/>
</rng:element>
</rng:define>
    <rng:define name="formula-negation.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="formula-negation.content">
        <rng:choice>
            <rng:element name="Operation">
<rng:ref name="Operation-formula-and-or.type"/>
</rng:element>
            <rng:ref name="Equal"/>
            <rng:ref name="Negation"/>
            <rng:ref name="Neg"/>
            <rng:ref name="extended-signature-predicate-sorts.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-negation.type">
        <rng:ref name="formula-negation.content"/>
        <rng:ref name="formula-negation.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="formula"/>
</rng:start>
<rng:define name="formula">
<rng:element name="formula">
<rng:ref name="formula-negation.type"/>
</rng:element>
</rng:define>
    <!--
		*** Naf ***
		A "by default" negation of a logical atom (i.e. "weak" negation or
		negation-as-failure).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Naf 
	-->
    <rng:define name="Naf.attlist">
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:define name="Naf.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                <rng:ref name="weak"/>
                <rng:ref name="weak.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Naf.type">
        <rng:ref name="Naf.content"/>
        <rng:ref name="Naf.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Naf"/>
</rng:start>
<rng:define name="Naf">
<rng:element name="Naf">
<rng:ref name="Naf.type"/>
</rng:element>
</rng:define>
    <!--
		*** weak ***
		A role used for negation as failure.
	
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-weak
	-->
    <rng:define name="weak.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="weak.content">
        <rng:choice>
            <rng:ref name="formula-negation.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="weak.type">
        <rng:ref name="weak.content"/>
        <rng:ref name="weak.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="weak"/>
</rng:start>
<rng:define name="weak">
<rng:element name="weak">
<rng:ref name="weak.type"/>
</rng:element>
</rng:define>
    <!--
		*** Neg ***
		A classical negation of a logical atom (i.e. classical or "strong" negation).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Neg 
	-->
    <rng:define name="Neg.attlist">
        <rng:ref name="Negation.attlist"/>
    </rng:define>
    <rng:define name="Neg.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                <rng:ref name="strong"/>
                <rng:ref name="strong.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Neg.type">
        <rng:ref name="Neg.content"/>
        <rng:ref name="Neg.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Neg"/>
</rng:start>
<rng:define name="Neg">
<rng:element name="Neg">
<rng:ref name="Neg.type"/>
</rng:element>
</rng:define>
    <!--
		*** strong ***
		A role used for classical negation.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-strong
	-->
    <rng:define name="strong.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="strong.content">
        <rng:choice>
            <rng:ref name="formula-negation.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="strong.type">
        <rng:ref name="strong.content"/>
        <rng:ref name="strong.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="strong"/>
</rng:start>
<rng:define name="strong">
<rng:element name="strong">
<rng:ref name="strong.type"/>
</rng:element>
</rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                         Quantifier module part of
            Reaction RuleML redefining the Forall, Exists and introduce the Quantifier element.
            This is the XML Schema Quantifier element for Reaction RuleML.   File:
            quantifier_module.xsd   Version: 1.02   Last Modification: 2015-03-22       * Quantifier
            generic quantifier (used in quantification metatag)   * Forall  predefined body
            quantifier (used in quantification metatag)   * Exist   predefined body quantifier (used
            in qualification metatag)       
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Quantifier ***
	Explicit generic quantifier, where the quantifier name can be defined by the 
    @type attribute and the @iri attribute can point to an external definition
    of the quantifier.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Quantifier
    
    Format: "quantifier declare(Var)* such that guard formula(...)?" 
-->
    <rng:define name="Quantifier.attlist">
        <rng:ref name="quantifier-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="Var"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-meta-quantifier.type"/>
</rng:element>
                <rng:ref name="formula-meta-quantifier.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Quantifier.type">
        <rng:ref name="Quantifier.content"/>
        <rng:ref name="Quantifier.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Quantifier"/>
</rng:start>
<rng:define name="Quantifier">
<rng:element name="Quantifier">
<rng:ref name="Quantifier.type"/>
</rng:element>
</rng:define>
    <!-- Exists
	make the quantifier constraint restrictions ("such that") optional
	
	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Exists
    -->
    <rng:define name="Exists-quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-meta-quantifier.type"/>
</rng:element>
                <rng:ref name="formula-meta-quantifier.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Exists-quantifier.type">
        <rng:ref name="Exists-quantifier.content"/>
        <rng:ref name="Quantifier.attlist"/>
    </rng:define>
    <!-- Forall
	make the quantifier constraint restrictions ("such that") optional
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Forall
	-->
    <rng:define name="Forall-quantifier.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="declare"/>
                <rng:ref name="declare.content"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:optional>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-meta-quantifier.type"/>
</rng:element>
                <rng:ref name="formula-meta-quantifier.content"/>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Forall-quantifier.type">
        <rng:ref name="Forall-quantifier.content"/>
        <rng:ref name="Quantifier.attlist"/>
    </rng:define>
    <!--
		*** formula ***
		The 'such that' guard formula role of a quantifier (<Forall> or <Exists>).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <rng:define name="formula-meta-quantifier.content">
        <rng:choice>
            <rng:ref name="guard.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="formula-meta-quantifier.type">
        <rng:ref name="formula-meta-quantifier.content"/>
        <rng:ref name="formula.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Profile module part of Reaction RuleML.   This is
            the XML Schema Profile element for Reaction RuleML for describing semantic profiles.
            Semantic Profiles are used to define the interpretation evaluation semantics (under the
            evaluation metatag)    either by referecing external existing profiles or by defining
            them internally.   File: profile_module.xsd   Version: 1.02   Last Modification:
            2015-03-22      * Profile         generic semantic profile       
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Profile ***
	Explicit generic semantic profile defining the intended semantics for knowledge interpretation, inference and execution. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Profile 
	-->
    <rng:define name="Profile.attlist">
        <rng:ref name="group-formula-interface.attlist"/>
        <rng:ref name="safety.attrib"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Profile.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:element name="formula">
<rng:ref name="formula-assert.type"/>
</rng:element>
                <rng:ref name="formula-assert.content"/>
                <rng:element name="content">
<rng:ref name="profile_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Profile.type">
        <rng:ref name="Profile.content"/>
        <rng:ref name="Profile.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Profile"/>
</rng:start>
<rng:define name="Profile">
<rng:element name="Profile">
<rng:ref name="Profile.type"/>
</rng:element>
</rng:define>
    <!--
     *** content ***
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     the optional @prefix and @vocab are used to define a prefix and a term mapping vocabulary for the XML content (see CURIE to IRI and term to IRI translation)
-->
    <rng:define name="profile_anycontent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="profile_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="profile_anycontent.type">
        <rng:ref name="profile_anycontent.content"/>
        <rng:ref name="profile_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Time module part of Reaction RuleML. It
            defines the core     time constructs        This is the XML Schema time module for
            Reaction RuleML.    File: time_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Time    
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built time module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-19T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Time ***
	Explicit generic Time construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Situation
	
	The time can be represented internally 
      * with positional arguments <arg>, e.g., <arg>
<Data xsi:type="xs:dateTime>2015-10-02T10:45:34-00:00</Data>
</arg>
      * with unpositional slots <slot>, e.g., <slot>
<Ind>year</Ind>
<Ind>2015</Ind>
</slot>
<slot>
<Ind>month</Ind>
<Ind>10</Ind>
</slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
      or externally, where the optional @iri attribute points to an external data definition of the time
      The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
      or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
      Note: Time can be defined absolute or relative.
	-->
    <rng:define name="Time-formula.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Time-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_time.type"/>
</rng:element>
                                        <rng:ref name="arg_time.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="time_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Time-formula.type">
        <rng:ref name="Time-formula.content"/>
        <rng:ref name="Time-formula.attlist"/>
    </rng:define>
    <!-- Time term -->
    <rng:define name="Time-term.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Time-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_time.type"/>
</rng:element>
                                        <rng:ref name="arg_time.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="time_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Time-term.type">
        <rng:ref name="Time-term.content"/>
        <rng:ref name="Time-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Time
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
	-->
    <rng:define name="arg_time.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_time.content">
        <rng:choice>
            <rng:ref name="time_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_time.type">
        <rng:ref name="arg_time.content"/>
        <rng:ref name="arg_time.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
	-->
    <rng:define name="time_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="time_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="time_anycontent.type">
        <rng:ref name="time_anycontent.content"/>
        <rng:ref name="time_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Spatial module part of Reaction RuleML. It defines
            the core     spatial constructs        This is the XML Schema spatial module for
            Reaction RuleML.    File: spatial_module.xsd    Version: 1.02    Last Modification:
            2015-07-19        This schema declares the following Reaction RuleML elements and
            attributes:        * Spatial       
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Spatial ***
	Explicit generic Spatial construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Spatial
	
	The spatial can be represented internally 
      * with positional arguments <arg>
      * with unpositional slots <slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
      or externally, where the optional @iri attribute points to an external data definition of the spatial
      The optional @type attribute defines the type of the spatial
	-->
    <rng:define name="Spatial-formula.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Spatial-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_spatial.type"/>
</rng:element>
                                        <rng:ref name="arg_spatial.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="spatial_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Spatial-formula.type">
        <rng:ref name="Spatial-formula.content"/>
        <rng:ref name="Spatial-formula.attlist"/>
    </rng:define>
    <!-- Spatial term -->
    <rng:define name="Spatial-term.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Spatial-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_spatial.type"/>
</rng:element>
                                        <rng:ref name="arg_spatial.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:zeroOrMore>
<rng:element name="content">
<rng:ref name="spatial_anycontent.type"/>
</rng:element>
</rng:zeroOrMore>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Spatial-term.type">
        <rng:ref name="Spatial-term.content"/>
        <rng:ref name="Spatial-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Spatial
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg  
	-->
    <rng:define name="arg_spatial.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_spatial.content">
        <rng:choice>
            <rng:ref name="spatial_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_spatial.type">
        <rng:ref name="arg_spatial.content"/>
        <rng:ref name="arg_spatial.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
	-->
    <rng:define name="spatial_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="spatial_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="spatial_anycontent.type">
        <rng:ref name="spatial_anycontent.content"/>
        <rng:ref name="spatial_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Interval module part of Reaction RuleML. It
            defines the core     Interval construct        This is the XML Schema interval module
            for Reaction RuleML.    File: interval_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Interval    
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Interval ***
	Explicit generic Interval. 
	
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Interval
	
	The interval can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the interval,
      the optional @iri attribute points to an external definition of the interval, and
       An interval can be defined by Events, Actions,  Times, Spatials, and other Intervals can be typed by the 
       interval ontology of Reaction RuleML (defining different types of intervals).
	-->
    <rng:define name="Interval-formula.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Interval-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            
                <rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:element name="content">
<rng:ref name="interval_anycontent.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:element name="content">
<rng:ref name="interval_anycontent.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Interval-formula.type">
        <rng:ref name="Interval-formula.content"/>
        <rng:ref name="Interval-formula.attlist"/>
    </rng:define>
    <!-- Interval term -->
    <rng:define name="Interval-term.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Interval-term.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Interval-term.type">
        <rng:ref name="Interval-term.content"/>
        <rng:ref name="Interval-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Intervals
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
-->
    <rng:define name="arg_interval.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_interval.content">
        <rng:choice>
            <rng:ref name="interval_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_interval.type">
        <rng:ref name="arg_interval.content"/>
        <rng:ref name="arg_interval.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation

-->
    <rng:define name="interval_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="interval_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="interval_anycontent.type">
        <rng:ref name="interval_anycontent.content"/>
        <rng:ref name="interval_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                spatial-temporal-interval algebra
            module part of Reaction RuleML    This is the XML Schema of the algebra module for
            Reaction RuleML    File: spatial_temporal_interval_algebra_module.xsd    Version: 1.02
            Last Modification: 2015-07-19        This schema declares the following Reaction RuleML
            elements and attributes:                                      Operation (generic
            operator)                   at (general role "at Time | Spatial | Interval)
            Spatial, Temporal, Interval Function Constructs                                       *
            After                   * Before       * Every                   * Any
            * Timer                                                         (Allen's) Interval
            Relations                                      * During                   * Overlaps
            * Starts                   * Precedes                   * Succeeds                   *
            Meets                   * Equal                   * Finishes
            The approach is modelled after that used in "Modularization of XHTML in XML Schema"
            WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-14T17:04:00+0200</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <rng:define name="spatial_temporal_algebra_group.content">
        <rng:choice>
            <rng:ref name="After"/>
            <rng:ref name="Before"/>
            <rng:ref name="Every"/>
            <rng:ref name="Any"/>
            <rng:ref name="Timer"/>
        </rng:choice>
    </rng:define>
    <rng:define name="interval_algebra_group.content">
        <rng:choice>
            <rng:ref name="During"/>
            <rng:ref name="Overlaps"/>
            <rng:ref name="Starts"/>
            <rng:ref name="Precedes"/>
            <rng:ref name="Succeeds"/>
            <rng:ref name="Meets"/>
            <rng:ref name="Finishes"/>
        </rng:choice>
    </rng:define>
    <!--
      *** at ***
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-at
      
	  Note: In Situation Calculus the time is a situation (the history of occured situations as a finite sequence of the events/actions) 	
	-->
    <rng:define name="at.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="at.content">
        <rng:choice>
            <rng:ref name="time_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="at.type">
        <rng:ref name="at.content"/>
        <rng:ref name="at.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="at"/>
</rng:start>
<rng:define name="at">
<rng:element name="at">
<rng:ref name="at.type"/>
</rng:element>
</rng:define>
    <!--
      *** After / Before***

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-After
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Before

      X after Y  / X before Y
      
      Note: Y might be absolute or relative, e.g. "after 2 days", "2 days after X"  
	-->
    <rng:define name="After.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="After.content">
        
            <rng:ref name="Interval-term.content"/>
        
    </rng:define>
    <rng:define name="After.type">
        <rng:ref name="After.content"/>
        <rng:ref name="After.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="After"/>
</rng:start>
<rng:define name="After">
<rng:element name="After">
<rng:ref name="After.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Before"/>
</rng:start>
<rng:define name="Before">
<rng:element name="Before">
<rng:ref name="After.type"/>
</rng:element>
</rng:define>
    <!--
      *** Every ***
      
      Every X 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Every
      
      Note:  X is often a relative, e.g. "every Monday", "every 2 meters" 
	-->
    <rng:define name="Every.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Every.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                <rng:ref name="interval_primitives.content"/>
                <rng:element name="content">
<rng:ref name="interval_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Every.type">
        <rng:ref name="Every.content"/>
        <rng:ref name="Every.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Every"/>
</rng:start>
<rng:define name="Every">
<rng:element name="Every">
<rng:ref name="Every.type"/>
</rng:element>
</rng:define>
    <!--
      *** Any ***
      
      Any X1,..Xn
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Any
            
      e.g. "at any Saturday and Sunday"     
	-->
    <rng:define name="Any.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Any.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                <rng:oneOrMore>
<rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
</rng:oneOrMore>
                <rng:oneOrMore>
<rng:ref name="interval_primitives.content"/>
</rng:oneOrMore>
                <rng:oneOrMore>
<rng:element name="content">
<rng:ref name="interval_anycontent.type"/>
</rng:element>
</rng:oneOrMore>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Any.type">
        <rng:ref name="Any.content"/>
        <rng:ref name="Any.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Any"/>
</rng:start>
<rng:define name="Any">
<rng:element name="Any">
<rng:ref name="Any.type"/>
</rng:element>
</rng:define>
    <!--
      *** (Recurring) Timer ***
      
      After X Every Y
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Recurring
      
      Note: X and Y might be relative, e.g. after 1 hour every hour (recurring timer)
	-->
    <rng:define name="Timer.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Timer.content">
        
            <rng:ref name="Interval-term.content"/>
        
    </rng:define>
    <rng:define name="Timer.type">
        <rng:ref name="Timer.content"/>
        <rng:ref name="Timer.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Timer"/>
</rng:start>
<rng:define name="Timer">
<rng:element name="Timer">
<rng:ref name="Timer.type"/>
</rng:element>
</rng:define>
    <!--
      *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes) ***
      
      operator(Interval, Interval)
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-During
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Overlaps
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Starts
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Precedes
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Succeeds
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Meets
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equal
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Finishes
	-->
    <rng:define name="IntervalAlgebraOperator.attlist">
        <rng:ref name="operator-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="IntervalAlgebraOperator.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            
                <rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:element name="arg">
<rng:ref name="arg_interval.type"/>
</rng:element>
                    <rng:ref name="arg_interval.content"/>
                </rng:choice>
            
        
    </rng:define>
    <rng:define name="IntervalAlgebraOperator.type">
        <rng:ref name="IntervalAlgebraOperator.content"/>
        <rng:ref name="IntervalAlgebraOperator.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="During"/>
</rng:start>
<rng:define name="During">
<rng:element name="During">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Overlaps"/>
</rng:start>
<rng:define name="Overlaps">
<rng:element name="Overlaps">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Starts"/>
</rng:start>
<rng:define name="Starts">
<rng:element name="Starts">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Precedes"/>
</rng:start>
<rng:define name="Precedes">
<rng:element name="Precedes">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Succeeds"/>
</rng:start>
<rng:define name="Succeeds">
<rng:element name="Succeeds">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Meets"/>
</rng:start>
<rng:define name="Meets">
<rng:element name="Meets">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <rng:start combine="choice">
<rng:ref name="Finishes"/>
</rng:start>
<rng:define name="Finishes">
<rng:element name="Finishes">
<rng:ref name="IntervalAlgebraOperator.type"/>
</rng:element>
</rng:define>
    <!-- include from the knowledge representation (KR) rule layer of reaction ruleml   -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Situation module part of Reaction RuleML. It
            defines the core     situation constructs        This is the XML Schema situation module
            for Reaction RuleML.    File: situation_module.xsd    Version: 1.02    Last
            Modification: 2015-03-29     This schema declares the following Reaction RuleML elements
            and attributes:       * Situation    
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-22T29:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Situation ***
	Explicit generic Situation. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Situation
	
	The situation can be defined internally 
	   	* with positional arguments <arg>, e.g., <arg>
<Ind>s1</Ind>
</arg>
      	* with unpositional slots <slot>, e.g., <slot>
<Ind>name</Ind>
<Ind>s1</Ind>
</slot>
<slot>
<Ind>occursAt</Ind>
<Time>....</Time>
</slot>
      	* by the any content model (<content>xs:any Element</content>), which acts as an extension point
      or externally, where the optional @iri attribute points to an external definition of the situation.
      The optional @type attribute defines the type of the situation.
      
      The situation instance (aka situation occurence is defined by its <arg>uments, <slot>s, as a situation interpretation <formula>, 
      or arbitrary <content>. A situation pattern, as used, e.g., in a query or condition of a rule, is defined in the <signature> 
      as situation template, e.g. <Situation>
<signature>...</signature>
</Situation>.
      
      Note: It is possible to interpret intervals, time (in the reaction layers also events and actions) as situations,
            e.g., <Situation>
<Time>...</Time>
</Situation>. 
	-->
    <rng:define name="Situation-formula.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Situation-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_situation.type"/>
</rng:element>
                                        <rng:ref name="arg_situation.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="situation_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Situation-formula.type">
        <rng:ref name="Situation-formula.content"/>
        <rng:ref name="Situation-formula.attlist"/>
    </rng:define>
    <!-- Situation term -->
    <rng:define name="Situation-term.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Situation-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_situation.type"/>
</rng:element>
                                        <rng:ref name="arg_situation.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="situation_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Situation-term.type">
        <rng:ref name="Situation-term.content"/>
        <rng:ref name="Situation-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Situation
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg     
-->
    <rng:define name="arg_situation.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_situation.content">
        <rng:choice>
            <rng:ref name="situation_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_situation.type">
        <rng:ref name="arg_situation.content"/>
        <rng:ref name="arg_situation.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix ais used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
-->
    <rng:define name="situation_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="situation_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="situation_anycontent.type">
        <rng:ref name="situation_anycontent.content"/>
        <rng:ref name="situation_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       KR situation reasoning module part of
            Reaction RuleML.     This is the XML Schema KR module for Reaction RuleML.    File:
            situation_module.xsd    Version: 1.02    Last Modification: 2015-07-22     This schema
            declares the following Reaction RuleML elements and attributes:      * Happens     *
            Initiates     * Terminates     * fluent     * Fluent     * Holds     * Situation     *
            Do        The approach is modelled after that used in "Modularization of XHTML in XML
            Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated
            with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-22T29:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
      *** fluent ***
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-fluent
      
      A fluent is a fluent situation which holds true or false as a condition which changes over time - a changeable situation. 
      In Situation Calculus, fluents (changable situations) are expressions which hold true or false and take an occured situation (as a history of action events; note: there is no distinction in events and actions in such calculi) 
      as their final argument (see Holds below).
      
 	  Note: we allow reification of fluents and situations in Reaction RuleML also for Situation Calculus serialization. 
		The transformation of such XML reifications in Reaction RuleML would be translated into a predicate in the concrete language of a Situation Calculus rule language or first-order logic 
	-->
    <rng:define name="fluent.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="fluent.content">
        <rng:choice>
            <rng:ref name="situation_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="fluent.type">
        <rng:ref name="fluent.content"/>
        <rng:ref name="fluent.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="fluent"/>
</rng:start>
<rng:define name="fluent">
<rng:element name="fluent">
<rng:ref name="fluent.type"/>
</rng:element>
</rng:define>
    <!--     *** Do ***
		
	  The function do maps (reified) actions into situations; Do: A x S -> S
	  
	  see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Do
	-->
    <rng:define name="Do.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Do.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:ref name="do"/>
                    <rng:ref name="do.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:ref name="at"/>
                    <rng:ref name="at.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Do.type">
        <rng:ref name="Do.content"/>
        <rng:ref name="Do.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Do"/>
</rng:start>
<rng:define name="Do">
<rng:element name="Do">
<rng:ref name="Do.type"/>
</rng:element>
</rng:define>
    <!--     *** Happens ***
		
		Different happens / happenings can be defined by pointing to an external vocabulary with @iri, e.g. a vocabulary for a calculi
		which distinguishes between events which acutally happen and other event relations to time or situations  (e.g. poss, planned, etc.)
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Happens
		
		In Situation Calculus happens can be used to define action effects. 
		
 		Note: we allow reification of fluents and situations in Reaction RuleML also for Situation Calculus serialization. 
		The transformation of such XML reifications in Reaction RuleML would be translated into a predicate in the concrete language of a Situation Calculus rule language or first-order logic      
	-->
    <rng:define name="Happens.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Happens.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:ref name="on"/>
                    <rng:ref name="on.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:ref name="at"/>
                    <rng:ref name="at.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Happens.type">
        <rng:ref name="Happens.content"/>
        <rng:ref name="Happens.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Happens"/>
</rng:start>
<rng:define name="Happens">
<rng:element name="Happens">
<rng:ref name="Happens.type"/>
</rng:element>
</rng:define>
    <!--     *** Initiates ***
 		
 		 see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Initiates 
 	-->
    <rng:define name="Initiates.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Initiates.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:ref name="on"/>
                    <rng:ref name="on.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:ref name="fluent"/>
                    <rng:ref name="fluent.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:ref name="at"/>
                    <rng:ref name="at.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Initiates.type">
        <rng:ref name="Initiates.content"/>
        <rng:ref name="Initiates.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Initiates"/>
</rng:start>
<rng:define name="Initiates">
<rng:element name="Initiates">
<rng:ref name="Initiates.type"/>
</rng:element>
</rng:define>
    <!--
      *** Terminates ***
      
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Terminates
	-->
    <rng:define name="Terminates.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Terminates.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:ref name="on"/>
                    <rng:ref name="on.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:ref name="fluent"/>
                    <rng:ref name="fluent.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:ref name="at"/>
                    <rng:ref name="at.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Terminates.type">
        <rng:ref name="Terminates.content"/>
        <rng:ref name="Terminates.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Terminates"/>
</rng:start>
<rng:define name="Terminates">
<rng:element name="Terminates">
<rng:ref name="Terminates.type"/>
</rng:element>
</rng:define>
    <!--
      *** Holds ***
 
       see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Holds
      
      In Event Calculus, Feature and Fluent Calculus reified fluents hold at a time. 
      In reified Situation Calculus a Fluent Situation (a statement whose truth value may change) holds at a particular Situation 
      
  		Note: we allow reification of fluents and situations in Reaction RuleML also for Situation Calculus serialization. 
		The transformation of such XML reifications in Reaction RuleML would be translated into a predicate in the concrete language of a Situation Calculus rule language or first-order logic
	-->
    <rng:define name="Holds.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Holds.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:ref name="fluent"/>
                    <rng:ref name="fluent.content"/>
                </rng:choice>
                <rng:optional>
<rng:choice>
                    <rng:ref name="at"/>
                    <rng:ref name="at.content"/>
                </rng:choice>
</rng:optional>
            
        
    </rng:define>
    <rng:define name="Holds.type">
        <rng:ref name="Holds.content"/>
        <rng:ref name="Holds.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Holds"/>
</rng:start>
<rng:define name="Holds">
<rng:element name="Holds">
<rng:ref name="Holds.type"/>
</rng:element>
</rng:define>
    <!--
	*** Fluent ***
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Fluent		
	-->
    <rng:define name="Fluent-formula.attlist">
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Fluent-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_fluent.type"/>
</rng:element>
                                        <rng:ref name="arg_fluent.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="fluent_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Fluent-formula.type">
        <rng:ref name="Fluent-formula.content"/>
        <rng:ref name="Fluent-formula.attlist"/>
    </rng:define>
    <rng:define name="Fluent-term.attlist">
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Fluent-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_fluent.type"/>
</rng:element>
                                        <rng:ref name="arg_fluent.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="fluent_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Fluent-term.type">
        <rng:ref name="Fluent-term.content"/>
        <rng:ref name="Fluent-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Fluent

    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg         
	-->
    <rng:define name="arg_fluent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_fluent.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_fluent.type">
        <rng:ref name="arg_fluent.content"/>
        <rng:ref name="arg_fluent.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
         see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
-->
    <rng:define name="fluent_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="fluent_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="fluent_anycontent.type">
        <rng:ref name="fluent_anycontent.content"/>
        <rng:ref name="fluent_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Event module part of Reaction RuleML. It
            defines the core     event constructs        This is the XML Schema event module for
            Reaction RuleML.    File: event_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Event    
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-07-19T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
	*** Event ***
	  Explicit generic Event. 
	  
	  See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Event
	  
	  The event can be defined internally 
     	* with positional arguments <arg>, e.g., <arg>
<Ind>e1</Ind>
</arg>
      	* with unpositional slots <slot>, e.g., <slot>
<Ind>name</Ind>
<Ind>e1</Ind>
</slot>
<slot>
<Ind>processingDate</Ind>
<Time>....</Time>
</slot>
      	* as interpretation as event with <on>, e.g., <on>
<Atom>...</Atom>
</on>
      	* by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for events
      or externally, where the optional @iri attribute points to an external definition of the event.
      The optional @type attribute defines the type of the event,
      the optional @safety attribute indicates if this is an interrupting, non-interrupting, transactional event
      the optional @size attribute acts as a generic size counter for the number of events to be received 
      Definitions of time and spatial events are simplified by makeing the assumption that a time/spatial object can be interpreted as event, 
      e.g. <Event>
<arg>
<Time>...</Time>
</arg>
</Event>.
      
      The event instance is defined by its <arg>uments, <slot>s, as an event interpretation <on>, or arbitrary <content>.
      An event pattern (as used, e.g., in the <on> part of a reaction rule) is defined in the <signature> 
      of the event as event template, e.g. <Event>
<signature>...</signature>
</Event>.

	-->
    <rng:define name="Event-formula.attlist">
        <rng:ref name="event-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Event-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_event.type"/>
</rng:element>
                                        <rng:ref name="arg_event.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="event_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Event-formula.type">
        <rng:ref name="Event-formula.content"/>
        <rng:ref name="Event-formula.attlist"/>
    </rng:define>
    <!-- event term -->
    <rng:define name="Event-term.attlist">
        <rng:ref name="event-interface.attlist"/>
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Event-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_event.type"/>
</rng:element>
                                        <rng:ref name="arg_event.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:element name="slot">
<rng:ref name="slot.type"/>
</rng:element>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="event_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Event-term.type">
        <rng:ref name="Event-term.content"/>
        <rng:ref name="Event-term.attlist"/>
    </rng:define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Event
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
     
-->
    <rng:define name="arg_event.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_event.content">
        <rng:choice>
            <rng:ref name="event_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_event.type">
        <rng:ref name="arg_event.content"/>
        <rng:ref name="arg_event.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
         
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation

    -->
    <rng:define name="event_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="event_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="event_anycontent.type">
        <rng:ref name="event_anycontent.content"/>
        <rng:ref name="event_anycontent.attlist"/>
    </rng:define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Action module part of Reaction RuleML. It defines
            the core     action constructs        This is the XML Schema event module for Reaction
            RuleML.    File: action_module.xsd    Version: 1.02    Last Modification: 2015-07-19
            This schema declares the following Reaction RuleML elements and attributes:        *
            Action       
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
     *** arg ***
     
     Definition of the the arg role for Action


     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
     
-->
    <rng:define name="arg_action.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="arg_action.content">
        <rng:choice>
            <rng:ref name="action_primitives.content"/>
        </rng:choice>
    </rng:define>
    <rng:define name="arg_action.type">
        <rng:ref name="arg_action.content"/>
        <rng:ref name="arg_action.attlist"/>
    </rng:define>
    <!--
     *** content ***
     
     content model:  xs:any*
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
          
    -->
    <rng:define name="action_anycontent.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="action_anycontent.content">
        <rng:choice>
            <rng:zeroOrMore>
<rng:element>
<rng:anyName/>
<rng:text/>
</rng:element>
</rng:zeroOrMore>
        </rng:choice>
    </rng:define>
    <rng:define name="action_anycontent.type">
        <rng:ref name="action_anycontent.content"/>
        <rng:ref name="action_anycontent.attlist"/>
    </rng:define>
    <!--
	*** Action ***
	
	  Explicit generic Action. The action can be defined internally 
     	* with positional arguments <arg>, e.g., <arg>
<Ind>a1</Ind>
</arg> (atomic actions | complex actions)
      	* with unpositional slots <slot>, e.g., <slot>
<Ind>name</Ind>
<Ind>a1</Ind>
</slot>
<slot>
<Ind>processingDate</Ind>
<Time>....</Time>
</slot>
      	* as interpretation as event with <do>, e.g., <do>
<Atom>...</Atom>
</do>
      	* by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for actions
      or externally, where the optional @iri attribute points to an external definition of the action.
      The optional @type attribute defines the type of the action,
      the optional @safety attribute indicates if this is an interrupting, non-interrupting, transactional action
      the optional @size attribute acts as a generic size counter for the number of actions to be done 
      optional @closure defines the default quantification
             

	  See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Action	                
	-->
    <rng:define name="Action-formula.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Action-formula.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:ref name="degree"/>
</rng:optional>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:ref name="slot"/>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_action.type"/>
</rng:element>
                                        <rng:ref name="arg_action.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:ref name="slot"/>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="action_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Action-formula.type">
        <rng:ref name="Action-formula.content"/>
        <rng:ref name="Action-formula.attlist"/>
    </rng:define>
    <!-- action term -->
    <rng:define name="Action-term.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="term-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Action-term.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:optional>
<rng:choice>
                
                    <rng:zeroOrMore>
<rng:ref name="slot"/>
</rng:zeroOrMore>
                    <rng:optional>
<rng:choice>
                        
                            <rng:choice>
                                
                                    <rng:oneOrMore>
<rng:choice>
                                        <rng:element name="arg">
<rng:ref name="arg_action.type"/>
</rng:element>
                                        <rng:ref name="arg_action.content"/>
                                    </rng:choice>
</rng:oneOrMore>
                                    <rng:optional>
<rng:ref name="repo"/>
</rng:optional>
                                
                                <rng:ref name="repo"/>
                            </rng:choice>
                            <rng:zeroOrMore>
<rng:ref name="slot"/>
</rng:zeroOrMore>
                        
                    </rng:choice>
</rng:optional>
                    <rng:optional>
<rng:ref name="resl"/>
</rng:optional>
                
                <rng:element name="content">
<rng:ref name="action_anycontent.type"/>
</rng:element>
            </rng:choice>
</rng:optional>
        
    </rng:define>
    <rng:define name="Action-term.type">
        <rng:ref name="Action-term.content"/>
        <rng:ref name="Action-term.attlist"/>
    </rng:define>
    <!-- include test suites   -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Test and Proof module part of Reaction RuleML.
            This is the XML Schema Test module for Reaction RuleML.    File: test_module.xsd
            Version: 1.02    Last Modification: 2015-07-20        Further information - see RBSLA
            project (http://rbsla.ruleml.org)    ContractLog framework VVI Testing:
            http://rbsla.ruleml.org/docs/ContractLog_VVI.pdf        This schema declares the
            following Reaction RuleML elements and attributes:            * Test    * vvi    *
            TestSuite    * testbase    * TestItem    * Answer     * formula (Answer)    *
            expectedResult        The approach is modelled after that used in "Modularization of
            XHTML in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].       
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.02</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2015-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dc:rights xmlns:dc="http://purl.org/dc/elements/1.1/">'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://reaction.ruleml.org</dc:relation>
        
    </a:documentation>
    <!--
      *** Test ***
      A Test action/primitive that provides the syntax for Verification, Validation and Integrity (VVI) Testing.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Test
      
      An optional scope (<scope>) can be defined so that the test applies only to the scope (constructed view) on the knowledge base.   
	-->
    <rng:define name="Test.attlist">
        <rng:ref name="action-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="Test.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="vvi"/>
                <rng:ref name="vvi.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="Test.type">
        <rng:ref name="Test.content"/>
        <rng:ref name="Test.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="Test"/>
</rng:start>
<rng:define name="Test">
<rng:element name="Test">
<rng:ref name="Test.type"/>
</rng:element>
</rng:define>
    <!--
     *** vvi ***
     
     vvi role - "verification, validation, integrity" tests
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-vvi 
	-->
    <rng:define name="vvi.attlist">
        <rng:ref name="edge-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="vvi.content">
        <rng:choice>
            <rng:ref name="Entails"/>
            <rng:ref name="TestSuite"/>
            <rng:ref name="TestItem"/>
        </rng:choice>
    </rng:define>
    <rng:define name="vvi.type">
        <rng:ref name="vvi.content"/>
        <rng:ref name="vvi.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="vvi"/>
</rng:start>
<rng:define name="vvi">
<rng:element name="vvi">
<rng:ref name="vvi.type"/>
</rng:element>
</rng:define>
    <!--
     *** testsbase ***
     
     base role for the test assertion | consultation base
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-testbase
	-->
    <rng:define name="testbase.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="testbase.content">
        <rng:choice>
            <rng:ref name="Consult"/>
            <rng:ref name="Assert"/>
        </rng:choice>
    </rng:define>
    <rng:define name="testbase.type">
        <rng:ref name="testbase.content"/>
        <rng:ref name="testbase.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="testbase"/>
</rng:start>
<rng:define name="testbase">
<rng:element name="testbase">
<rng:ref name="testbase.type"/>
</rng:element>
</rng:define>
    <!--
      *** TestSuite ***
      A TestSuite consisting of the assertion | consultation base (test assertions) and the VVI tests (integrity entailments, test items or nested test suites 

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-TestSuite
	-->
    <rng:define name="TestSuite.attlist">
        <rng:ref name="group-formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="TestSuite.content">
        
            <rng:ref name="meta-roles.content"/>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="testbase"/>
                <rng:ref name="Assert"/>
                <rng:ref name="Consult"/>
            </rng:choice>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:choice>
                <rng:ref name="vvi"/>
                <rng:ref name="vvi.content"/>
            </rng:choice>
</rng:zeroOrMore>
        
    </rng:define>
    <rng:define name="TestSuite.type">
        <rng:ref name="TestSuite.content"/>
        <rng:ref name="TestSuite.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="TestSuite"/>
</rng:start>
<rng:define name="TestSuite">
<rng:element name="TestSuite">
<rng:ref name="TestSuite.type"/>
</rng:element>
</rng:define>
    <!--
      *** TestItem ***
      TestItem describing one particular test consisting of the test act (typically a Query) and the expected result (the expected Answer with the predefined expected truth valuation (<degree>) and results/variable bindings)
      
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-TestItem
    -->
    <rng:define name="TestItem.attlist">
        <rng:ref name="group-formula-interface.attlist"/>
        <rng:ref name="node-element.attlist"/>
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="TestItem.content">
        
            <rng:ref name="meta-roles.content"/>
            
                <rng:choice>
                    <rng:element name="do">
<rng:ref name="act.type"/>
</rng:element>
                    <rng:ref name="act.content"/>
                </rng:choice>
                <rng:choice>
                    <rng:ref name="expectedResult"/>
                    <rng:ref name="expectedResult.content"/>
                </rng:choice>
            
        
    </rng:define>
    <rng:define name="TestItem.type">
        <rng:ref name="TestItem.content"/>
        <rng:ref name="TestItem.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="TestItem"/>
</rng:start>
<rng:define name="TestItem">
<rng:element name="TestItem">
<rng:ref name="TestItem.type"/>
</rng:element>
</rng:define>
    <!--
     *** expectedResult***
     
     Definition of the the enclosed role for Send and Receive actions
     
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-expectedResult

-->
    <rng:define name="expectedResult.attlist">
        <rng:ref name="xml.attlist"/>
    </rng:define>
    <rng:define name="expectedResult.content">
        <rng:choice>
            <rng:ref name="Answer"/>
        </rng:choice>
    </rng:define>
    <rng:define name="expectedResult.type">
        <rng:ref name="expectedResult.content"/>
        <rng:ref name="expectedResult.attlist"/>
    </rng:define>
    <rng:start combine="choice">
<rng:ref name="expectedResult"/>
</rng:start>
<rng:define name="expectedResult">
<rng:element name="expectedResult">
<rng:ref name="expectedResult.type"/>
</rng:element>
</rng:define>
    <!--
     metadata group
     
	This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
	
     content model: (meta*, scope*, guard )
          
	-->
    <rng:define name="metadata.content">
        
            <rng:zeroOrMore>
<rng:ref name="meta"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="scope"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="guard"/>
</rng:zeroOrMore>
        
    </rng:define>
    <!--
     interface group
     
     This internal group defines the interface signature and the evaluation semantics
     
     content model: (evaluation*, signature* )
          
	-->
    <rng:define name="interface.content">
        
            <rng:zeroOrMore>
<rng:ref name="evaluation"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="signature"/>
</rng:zeroOrMore>
        
    </rng:define>
    <!--
     instance group
     
     This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
     
     content model: (qualification*, quantification*, oid? )
          
	-->
    <rng:define name="instance.content">
        
            <rng:zeroOrMore>
<rng:ref name="qualification"/>
</rng:zeroOrMore>
            <rng:zeroOrMore>
<rng:ref name="quantification"/>
</rng:zeroOrMore>
            <rng:optional>
<rng:ref name="oid"/>
</rng:optional>
        
    </rng:define>
    <!--
         
     An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
    
    
     content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
          
	-->
    <rng:define name="meta-roles.content">
        
            <rng:ref name="metadata.content"/>
            <rng:ref name="interface.content"/>
            <rng:ref name="instance.content"/>
        
    </rng:define>
    <!--
         
     An internal group for the implementation of a rule in the Reaction RuleML language
    
     content model:
     
     in KR Reaction RuleML: ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
          
	-->
    <rng:define name="rule-implementation.content">
        <rng:choice>
            <rng:ref name="DerivationRule.content"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the query connectives in the Reaction RuleML language
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <rng:define name="query-connective.content">
        <rng:choice>
            <rng:element name="Operation">
<rng:ref name="Operation-formula-query.type"/>
</rng:element>
            <rng:element name="And">
<rng:ref name="And-query.type"/>
</rng:element>
            <rng:element name="Or">
<rng:ref name="Or-query.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Naf"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the rulebase connectives in the Reaction RuleML language
    
    
     content model: (Operation | Negation | Neg | Equal )
          
	-->
    <rng:define name="rulebase-connective.content">
        <rng:choice>
            <rng:element name="Operation">
<rng:ref name="Operation-formula-rulebase.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the body connectives in the Reaction RuleML language
    
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <rng:define name="body-connective.content">
        <rng:choice>
            <rng:element name="Operation">
<rng:ref name="Operation-formula-and-or.type"/>
</rng:element>
            <rng:element name="And">
<rng:ref name="And-body.type"/>
</rng:element>
            <rng:element name="Or">
<rng:ref name="Or-body.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Naf"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the head connectives in the Reaction RuleML language
    
    
     content model: (Operation | Negation | Neg | Equal )
          
	-->
    <rng:define name="head-connective.content">
        <rng:choice>
            <rng:element name="Operation">
<rng:ref name="Operation-formula-and-or.type"/>
</rng:element>
            <rng:ref name="Negation"/>
            <rng:ref name="Neg"/>
            <rng:ref name="Equal"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the query quantifiers in the Reaction RuleML language
    
     content model: (Exists )
          
	-->
    <rng:define name="query-quantifier.content">
        <rng:choice>
            <rng:ref name="Exists"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the body quantifiers in the Reaction RuleML language
    
    
     content model: (Forall | Exists | Quantifier)
          
	-->
    <rng:define name="meta-quantifier.content">
        <rng:choice>
            <rng:element name="Forall">
<rng:ref name="Forall-quantifier.type"/>
</rng:element>
            <rng:element name="Exists">
<rng:ref name="Exists-quantifier.type"/>
</rng:element>
            <rng:ref name="Quantifier"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the rulebase quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall  )
          
	-->
    <rng:define name="rulebase-quantifier.content">
        <rng:choice>
            <rng:ref name="Forall"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the head quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall  )
          
	-->
    <rng:define name="head-quantifier.content">
        <rng:choice>
            <rng:ref name="Forall"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the body quantifier in the Reaction RuleML language
    
    
     content model: ( Exist )
          
	-->
    <rng:define name="body-quantifier.content">
        <rng:choice>
            <rng:ref name="Exists"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
    
     In the KR dialect of Reaction RuleML the signature contains the predicate sorts Time, Spatial, Interval, Event, Action, Situation, Holds, Initiates, Terminates, Happens
    
     content model: (Atom | Time | Spatial | Interval | Event | Action | Situation | Fluent | Holds | Initiates | Terminates | Happens | (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes | Operation))
          
	-->
    <rng:define name="extended-signature-predicate-sorts.content">
        <rng:choice>
            <rng:element name="Atom">
<rng:ref name="Atom.type"/>
</rng:element>
            <rng:element name="Time">
<rng:ref name="Time-formula.type"/>
</rng:element>
            <rng:element name="Spatial">
<rng:ref name="Spatial-formula.type"/>
</rng:element>
            <rng:element name="Interval">
<rng:ref name="Interval-formula.type"/>
</rng:element>
            <rng:element name="Event">
<rng:ref name="Event-formula.type"/>
</rng:element>
            <rng:element name="Action">
<rng:ref name="Action-formula.type"/>
</rng:element>
            <rng:element name="Situation">
<rng:ref name="Situation-formula.type"/>
</rng:element>
            <rng:element name="Fluent">
<rng:ref name="Fluent-formula.type"/>
</rng:element>
            <!-- only used in non-reified calculi as predicate -->
            <rng:ref name="Holds"/>
            <rng:ref name="Initiates"/>
            <rng:ref name="Terminates"/>
            <rng:ref name="Happens"/>
            <rng:ref name="interval_algebra_group.content"/>
        </rng:choice>
    </rng:define>
    <!--
         
     An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
    
     In the KR dialect of Reaction RuleML the signature contains the function sorts Time, Spatial, Interval, Event, Action, and Situation
    
     content model: (Ind | Data | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent | (After | Before | Any | Every | Timer | Operation))
          
	-->
    <rng:define name="extended-signature-function-sorts.content">
        <rng:choice>
            <rng:ref name="Ind"/>
            <rng:ref name="Data"/>
            <rng:ref name="Expr"/>
            <rng:ref name="Plex"/>
            <rng:element name="Time">
<rng:ref name="Time-term.type"/>
</rng:element>
            <rng:element name="Spatial">
<rng:ref name="Spatial-term.type"/>
</rng:element>
            <rng:element name="Interval">
<rng:ref name="Interval-term.type"/>
</rng:element>
            <rng:element name="Event">
<rng:ref name="Event-term.type"/>
</rng:element>
            <rng:element name="Action">
<rng:ref name="Action-term.type"/>
</rng:element>
            <rng:element name="Situation">
<rng:ref name="Situation-term.type"/>
</rng:element>
            <rng:element name="Fluent">
<rng:ref name="Fluent-term.type"/>
</rng:element>
            <!-- in reified calculi used as function -->
            <rng:ref name="spatial_temporal_algebra_group.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the time primitives for interpretation as time
		content model: 
		in KR RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval  | Event | Action | Situation | Fluent) )
	-->
    <rng:define name="time_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the spatial primitives for interpretation as spatial
		content model: 
		in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent) 
	-->
    <rng:define name="spatial_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- Interval primitives
		content model: 
		in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent)  -->
    <rng:define name="interval_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the situation primitives for interpretation as situation
		content model: 
		in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent | Do)
	-->
    <rng:define name="situation_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
            <rng:ref name="Do"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the event primitives for interpretation as event
		content model: 
		in KR Reaction RuleML:  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent)
	-->
    <rng:define name="event_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for events
		content model:
		KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent )-->
    <rng:define name="event_group.content">
        <rng:choice>
            <rng:ref name="event_primitives.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the action primitives for interpretation as action
		content model: 
		in KR Reaction RuleML:  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent)
	-->
    <rng:define name="action_primitives.content">
        <rng:choice>
            <rng:ref name="arg.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for actions
		content model:
		KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | Fluent )-->
    <rng:define name="action_group.content">
        <rng:choice>
            <rng:ref name="action_primitives.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the imports of the consult primitive
		content model: 
		in KR Reaction RuleML: (payload | RuleML | Reify | Var)
	-->
    <rng:define name="consult_imports.content">
        <rng:choice>
            <rng:ref name="payload"/>
            <rng:ref name="payload.content"/>
        </rng:choice>
    </rng:define>
    <!-- An internal group for the performative primitives
		content model: 
		in KR Reaction RuleML: (Consult|Assert|Retract|Query|Answer|Test)
	-->
    <rng:define name="performative_primitives.content">
        <rng:choice>
            <rng:ref name="Consult"/>
            <rng:ref name="Assert"/>
            <rng:ref name="Retract"/>
            <rng:ref name="Query"/>
            <rng:ref name="Answer"/>
            <rng:ref name="Test"/>
        </rng:choice>
    </rng:define>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: reasoning (in KR Reaction RuleML)
	 optional attribute
-->
    <rng:define name="style.attrib">
        <rng:optional>
<rng:attribute name="style">
<rng:ref name="style.datatype"/>
</rng:attribute>
</rng:optional>
    </rng:define>
</rng:grammar>