namespace dc = "http://purl.org/dc/elements/1.1/"
namespace dcterms = "http://purl.org/dc/terms/"

dc:title [ "Reaction RuleML for DR" ]
dc:version [ "1.0" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:creator [ "Adrian Paschke" ]
dc:subject [ "RuleML, Reaction, Deliberation" ]
dc:description [
  "The expansion module for reserved spatial and temporal predicates and relations."
]
dc:language [ "en" ]
dcterms:rights [ "TBD" ]
dc:relation [ "http://reaction.ruleml.org" ]
start |= notAllowed
formula-assert.content = formula_AssertRetract.content
formula-query.content = formula_Query.content

commonInit.attlist &= key.attrib?
commonInit.attlist &= keyref.attrib?



## An internal group for the implementation of a rule in the Reaction RuleML language
rule-implementation.content = DerivationRule.content
 
## An internal group for the inner quantifiers in the Reaction RuleML language
inner-quantifier.content =
  element Forall { Forall-quantifier.type }
  | element Exists { Exists-quantifier.type }
  | Quantifier

## An internal group for the time primitives for interpretation as time
time_primitives.content = arg.content | spatial_temporal_algebra_group.content

## An internal group for the spatial primitives for interpretation as spatial
spatial_primitives.content = arg.content | spatial_temporal_algebra_group.content

## Interval primitives
interval_primitives.content = arg.content | interval_algebra_group.content

# extended descriptors in Reaction RuleML

# *** Forall ***
## <Forall>: "forall declared variables [such that formula]". See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Forall
Forall = Forall-node.choice
Forall-node.choice |= Quantifier
# *** Exists ***
## <Exists>: "exists declared variables [such that formula]". See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Forall
Exists = Exists-node.choice
Exists-node.choice |= Quantifier
# needed for Quantifier and quantification
formula-forall.type = formula_Forall.content, formula_Forall.attlist
formula-forall = element formula { formula-forall.type }
# *** Implies ***
Implies = Implies-node.choice
# *** then ***
then.content = head_Implies.content
then.type = head_Implies.attlist? & head_Implies.content
# *** Entails ***
Entails = Entails-node.choice
# *** Equivalent ***
Equivalent = Equivalent-node.choice
# *** Rulebase ***
Rulebase = Rulebase-node.choice
# *** And ***
And = And-node.choice
And-Query.main |= formula_And-query-edge.choice*

## an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  
formula_And-query-edge.choice |= formula_And-query.edge.def

## The formula role of a conjunctive (<And>) expression, 
## Within And ...
formula_And-query.edge.def =
  
  ## <formula>: contains a single formula. See  
  ## http://www.ruleml.org/1.0/glossary/#gloss-formula
  element formula { formula_And.attlist? & formula_And-query.content }

## Formulas within conjunctions consist of a single formula
formula_And-query.content |= AndQueryFormula.choice

## formulas allowed to participate in conjunctions. 
AndQueryFormula.choice |=
  SimpleFormula-node.choice
  | And-Query-node.choice
  | Or-Query-node.choice
  | Negation-node.choice
  | NegationAsFailure-node.choice
  | Implication-fo-node.choice
  | Forall-fo-node.choice
  | Exists-fo-node.choice
# *** Or ***
Or = Or-node.choice
Or-Query.main |= formula_Or-query-edge.choice*

## an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  
formula_Or-query-edge.choice |= formula_Or-query.edge.def

## The formula role of a conjunctive (<Or>) expression, 
## Within Or ...
formula_Or-query.edge.def =
  
  ## <formula>: contains a single formula. See  
  ## http://www.ruleml.org/1.0/glossary/#gloss-formula
  element formula { formula_Or.attlist? & formula_Or-query.content }

## Formulas within conjunctions consist of a single formula
formula_Or-query.content |= OrQueryFormula.choice

## formulas allowed to participate in conjunctions. 
OrQueryFormula.choice |=
  SimpleFormula-node.choice
  | And-Query-node.choice
  | Or-Query-node.choice
  | Negation-node.choice
  | NegationAsFailure-node.choice
  | Implication-fo-node.choice
  | Forall-fo-node.choice
  | Exists-fo-node.choice
# *** @mapMaterial ***
mapMaterial.attrib = mapMaterial-att-inf.choice
# *** @material ***
material.attrib = material-att-inf.choice
# *** @mapDirection ***
mapDirection.attrib = mapDirection-att-inf.choice
# *** @direction ***
direction.attrib = direction-att-inf.choice
# *** @mapClosure ***
mapClosure.attrib = mapClosure-att.choice?
# *** @closure ***
closure.attrib = closure-att.choice?
# *** Atom ***
Atom = Atom-node.choice
# *** Rel ***
reRel.attlist &= per-effect.attrib?
# *** slot ***
slot = slot-edge.choice
# *** arg ***
arg = positionalArgument-edge.choice
# *** Data ***
Data = DataTerm.choice
#	*** Var with mode attribute ***
Var = Variable-node.choice
reVar.attlist &= mode.attrib
# *** repo ***
repo = restOfPositionalArguments-edge.choice
# *** resl ***
resl = restOfSlots-edge.choice
# *** Equal ***
Equal = Equal-node.choice
# in time module
SimpleKeyTerm.choice |= Time_term
SimpleFormula-node.choice |= Time_formula
# in spatial module
SimpleKeyTerm.choice |= Spatial_term
SimpleFormula-node.choice |= Spatial_formula
# in interval module
SimpleKeyTerm.choice |= Interval_term
SimpleFormula-node.choice |= Interval_formula
#	    *** Assert ***
reAssert.attlist &= commonNode.attlist?
reAssert.attlist &= mapClosure-att.choice?
reAssert.attlist &= safety.attrib?
reAssert.attlist &= size.attrib?

## data type definition 
curieOrIRI.datatype = curie.datatype | xsd:anyURI

## data type definition         
curieOrAbsIRI.datatype = curie.datatype | absIRI.datatype

## data type definition         
termOrCurieOrIRI.datatype = term.datatype | curie.datatype | xsd:anyURI

## data type definition         
termOrCurieOrAbsIRI = term.datatype | curie.datatype | absIRI.datatype
absIRI.datatype = xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }

## data type definition         
curie.datatype =
  xsd:string {
    minLength = "1"
    pattern = "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
  }
term.datatype = xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }

# This module declares the following Reaction RuleML elements:
#   * meta            descriptive metadata 
#   * scope           scope  (e.g. for scoped reasoning)	
#   * guard			  guard (e.g. for guard constraints in scoped reasoning)
#   * evaluation      semantic profile for evaluation 
#   * signature       interface signature, pattern definition,
#   * qualification   qualification, e.g. priorities, validity, strategy
#   * quantification  quantification
#   * oid             object id     

# *** oid ***
## <oid>: defines the object id. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-oid
oid = objectIdentifier-edge.choice

#  *** meta ***
## <meta>: defines a descriptive metadata annotation. See 
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-meta
meta = metaKnowledge-edge.choice

# *** scope ***
## the attribute list of the scope edge
scope.attlist = index-attrib.choice?, commonInit.attlist?
scope.content = formula-query.content?
scope.type = scope.content, scope.attlist
scope = 
    ## <scope>: allows defining a metadata-based scope on the knowledge base for scoped reasoning. See 
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-scope 
    element scope { scope.type }
edge.choice |= scope


# *** guard ***     
## the attribute list of the guard edge
guard.attlist = index-attrib.choice?, commonInit.attlist?
guard.content = PremiseFormula.choice
guard.type = guard.content, guard.attlist
guard =
    ## <guard>: a guard defines a simple pre-constraint which applies before the main reasoning. See 
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-guard 
    element guard { guard.type }
edge.choice |= guard

# *** evaluation ***
## the attribute list of the evaluation edge
evaluation.attlist = index-attrib.choice?, commonInit.attlist?
evaluation.content = Profile
evaluation.type = evaluation.content, evaluation.attlist
evaluation =
    ## <evaluation>: defines the intended evaluation semantics as semantic <Profile>. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-evaluation
    element evaluation { evaluation.type }
edge.choice |= evaluation

# *** signature ***
## the attribute list of the signature edge
signature.attlist = index-attrib.choice?, commonInit.attlist?
signature.content = formula-query.content
signature.type = signature.content, signature.attlist
signature = 
    ## <signature>: defines the signature which can be used as public interface or pattern definition. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-signature
    element signature { signature.type }
edge.choice |= signature

#  *** qualification ***
## the attribute list of the qualification edge
qualification.attlist = index-attrib.choice?, commonInit.attlist?
qualification.content = formula-assert.content
qualification.type = qualification.content, qualification.attlist
qualification =
    ## <qualification>: defines the qualification (qualifying metadata). See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-qualification
    element qualification { qualification.type }
edge.choice |= qualification

# *** quantification ***
## the attribute list of the quantification
quantification.attlist = index-attrib.choice?, commonInit.attlist?
quantification.content = inner-quantifier.content
quantification.type = quantification.content, quantification.attlist
quantification =
    ## <quantification>: defines the quantification (quantifier). See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-quantification
    element quantification { quantification.type }
edge.choice |= quantification

# This module declares the following Reaction RuleML attributes:
#    * @mode (mode declaration)
#    * @safety (transactional)
#    * @per (usage)
#    * @all (yes|no)
#    * @style (execution style)	
#    * @key and @keyref for modularization of knowledge bases

# *** @mode ***
## @mode: input-output mode declaration of the arguments in predicates and functions. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@mode
mode.attrib = attribute mode { "+" | "-" | "?" }?

# *** @safety ***
## @safety: attribute defining the safety of the execution semantics for events, actions and primitives. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@safety    
safety.attrib = attribute safety { "non-interrupting" | "interrupting" | "transactional" }?

# *** @per ***
## @per: an attribute indicating the execution/interpretation semantics of a function or expression. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@per
per-effect.attrib = attribute per { "copy" | "value" | "effect" | "modal" | "open" }?

# *** @size ***
## @size: an attribute acting as a counter for the number of occurences of events, actions and updates. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@size
size.attrib = attribute size { xsd:int }?

# *** @key ***
## @key: defines a unique key attribute which can be used for distributed referencing from a keyref attribute. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@key
key.attrib = attribute key { curieOrAbsIRI.datatype }?

## @keyref: defines a reference to a corresponding unique key. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@keyref
keyref.attrib = attribute keyref { curieOrAbsIRI.datatype }?

# *** @style ***
#  when absent, equivalent to: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
style.datatype |= "active" | "messaging" | "reasoning"
style.attrib = style-att.choice
## @style: defines a reference to a corresponding unique key. See
## http://www.reaction.ruleml.org/1.0/glossary/#gloss-@style
style-att.choice |= attribute style { style.datatype }


# This module declares the following Reaction RuleML elements:
# * Rule
# * if
# * then
# * else

# *** Rule ***
##
Rule-datt.choice |= direction-att-inf.choice & material-att-inf.choice
reRule.attlist &= style.attrib?
reRule.attlist &= closure.attrib?
reRule.attlist &= Type.attlist?
reRule.attlist &= commonNode.attlist?
Rule.content = Node.header, rule-implementation.content?
Rule.type = Rule.content, (Rule-datt.choice & reRule.attlist)
Rule =
    ## <Rule>: defines a rule in Reaction RuleML. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Rule
    element Rule { Rule.type }
Node.choice |= Rule
AssertRetractFormula.choice |= Rule
ForallFormula.choice |= Rule
RulebaseFormula.choice |= Rule

# *** else ***
else =
    ## <else>: edge defining an alternative conclusion in a if-then-else rule. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-else
    element else { then.type }
edge.choice |= else

# This module declares the following Reaction RuleML elements:
# * Negation		generic polymorphig negation
# * Naf           negation as failure (inflationary negation in production rules), weak negation
# * Neg           classical negation, strong negation
		
# *** Negation ***
## the Negation attribute list
Negation.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Negation.content = Node.header, formula-negation.choice
formula-negation.choice |= formula-negation
Negation.type = Negation.content, Negation.attlist
Negation =
    ## <Negation>: a generic polymorphic negation, which is interpreted by the intended semantics (i.e. semantic profile). See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Negation
    element Negation { Negation.type }
Node.choice |= Negation
Negation-node.choice |= Negation
#
formula-negation.attlist &= commonInit.attlist?
formula-negation.content |= NegFormula.choice
formula-negation.type = formula-negation.content, formula-negation.attlist
formula-negation = element formula { formula-negation.type }
edge.choice |= formula-negation

# *** Naf ***
Naf = NegationAsFailure-node.choice
reNaf.attlist &= iri-att.choice?, Type.attlist
NafFormula.choice |= NegationAsFailure-node.choice
# *** Neg ***
reNeg.attlist &= iri-att.choice?, Type.attlist
NegFormula.choice |= NegationAsFailure-node.choice


# This module declares the following Reaction RuleML elements:
# * Quantifier  generic quantifier
# * Forall		predefined inner quantifier (used in quantification metatag)
# * Exist		predefined inner quantifier (used in qualification metatag)
    
# *** Quantifier ***
## Quantifier attribute list with the @type and @iri
Quantifier.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Quantifier.content = Quantifier.header, Quantifier.main
Quantifier.header &= Node.header
Quantifier.main |= boundVariables.choice, formula-quant.choice?
formula-quant.choice |= formula-quant
formula-quant = element formula { formula-forall.type }
Quantifier.type = Quantifier.content, Quantifier.attlist
Quantifier =
    ## <Quantifier>: a generic quantifier - "quantify over declared variables such that ...".See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Quantifier
    element Quantifier { Quantifier.type }
Node.choice |= Quantifier
# make the quantifier constraint restrictions ("such that") optional
Exists-quantifier.content = Exists.header, Exists-quantifier.main
Exists-quantifier.main = boundVariables.choice, formula-quant.choice?
Exists-quantifier.type = (Exists-datt.choice & reExists.attlist), Exists-quantifier.content
# make the quantifier constraint restrictions ("such that") optional
Forall-quantifier.content = Forall.header, Forall-quantifier.main
Forall-quantifier.main = boundVariables.choice, formula-quant.choice?
Forall-quantifier.type = (Forall-datt.choice & reForall.attlist), Forall-quantifier.content

# This module declares the following Reaction RuleML elements:
# * Profile         generic semantic profile

#   *** Profile ***
## Profile attribute list with @type, @iri, @direction, @safety, @size
Profile.attlist =
  iri-att.choice?, direction.attrib, Type.attlist, commonNode.attlist, safety.attrib, size.attrib
Profile.content = Node.header, formula_Profile-edge.choice*
formula_Profile-edge.choice |= formula_AssertRetract-edge.choice
# relaxed
# formula_Profile-edge.choice |= profile_anycontent
Profile.type = Profile.content, Profile.attlist
Node.choice |= Profile
Profile =
    ## <Profile>: defines (or references) the intended semantics as a semantic profile. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Quantifier
    element Profile { Profile.type }

# This module declares the following Reaction RuleML elements:
# * Time

Time.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Time.content = Node.header, argumentsForTime.sequence
argumentsForTime.sequence |= arg_time.choice*, repo?, slot*, resl?
arg_time.choice |= arg_time
Time.type = Time.content, Time.attlist
Node.choice |= Time_formula
Time_term =
    ## <Time>: generic Time element. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Time
    element Time { Time.type }
Time_formula = element Time { Time.type }

# *** arg ***
arg_time.attlist = index-attrib.choice?, commonInit.attlist?
arg_time.content = time_primitives.content
arg_time.type = arg_time.content, arg_time.attlist
arg_time = element arg { arg_time.type }
edge.choice |= arg_time

# This module declares the following Reaction RuleML elements:
# * Spatial

#   *** Spatial ***
Spatial.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Spatial.content = Node.header, argumentsForSpatial.sequence
argumentsForSpatial.sequence |= arg_spatial.choice*, repo?, slot*, resl?
arg_spatial.choice |= arg_spatial
Node.choice |= Spatial_formula
Spatial.type = Spatial.content, Spatial.attlist
Spatial_term = 
    ## <Spatial>: generic Spatial element. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Spatial
    element Spatial { Spatial.type }
Spatial_formula = element Spatial { Spatial.type }

# *** arg ***
arg_spatial.attlist = index-attrib.choice?, commonInit.attlist?
arg_spatial.content = spatial_primitives.content
arg_spatial.type = arg_spatial.content, arg_spatial.attlist
arg_spatial = element arg { arg_spatial.type }
edge.choice |= arg_spatial

# This module declares the following Reaction RuleML elements:
# * Interval

#   *** Interval ***
Interval.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
arg_interval.choice |= arg_interval
Interval_term.content = Node.header, arg_interval.choice, arg_interval.choice?
Interval_formula.content = Node.header, arg_interval.choice, arg_interval.choice?
#
Interval_term.type = Interval_term.content, Interval.attlist
Interval_formula.type = Interval_formula.content, Interval.attlist
Node.choice |= Interval_formula
Interval_term =
    ## <Time>: generic Interval element. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Interval
    element Interval { Interval_term.type }
Interval_formula = element Interval { Interval_formula.type }

# *** arg ***
arg_interval.attlist = index-attrib.choice?, commonInit.attlist?
arg_interval.content = interval_primitives.content
arg_interval.type = arg_interval.content, arg_interval.attlist
arg_interval = element arg { arg_interval.type }
edge.choice |= arg_interval

# This module declares the following Reaction RuleML elements:
#                 * Operator (generic operator)
#                  
#                  Spatial, Temporal, Interval Function Constructs 
#                  
#                  * After
#                  * Before
#				  * Every
#                  * Any
#                  * Timer
#                  
#                  
#                  (Allen's) Interval Relations
#                  
#                  * During
#                  * Overlaps
#                  * Starts
#                  * Precedes
#                  * Succeeds
#                  * Meets
#                  * Equal
#                  * Finishes

# (After | Before | Any | Every | Timer | Operator)
spatial_temporal_algebra_group.content = After | Before | Every | Any | Timer | Operator_any
Operator_any =
    ## <Operator>: a generic Operator element which can be overloaded. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Operator    
    element Operator { Any.type }
Node.choice |= Operator_any

# (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equals | Finishes | Operator)
interval_algebra_group.content =
  During
  | Overlaps
  | Starts
  | Precedes
  | Succeeds
  | Meets
  | IntervalAlgebraEqual
  | Finishes
  | IntervalAlgebraOperator
IntervalAlgebraEqual = element Equal { IntervalAlgebraOperator.type }
IntervalAlgebraOperator = element Operator { IntervalAlgebraOperator.type }

# *** After / Before***
After.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
After.content = Interval_term.content
After.type = After.content, After.attlist
Node.choice |= After
After =
    ## <After>: a temporal operator "t2 after t1". See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-After  
    element After { After.type }
Node.choice |= Before
Before =
    ## <Before>: a temporal operator "t1 before t2". See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-After
    element Before { After.type }
    
# *** Every ***
Every.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Every.content = Node.header, arg_interval.choice?
Every.type = Every.content, Every.attlist
Node.choice |= Every
Every = 
    ## <Every>: a temporal operator "every t". See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Every
    element Every { Every.type }
    
# *** Any ***
Any.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Any.content = Node.header, arg_interval.choice*
Any.type = Any.content, Any.attlist
Node.choice |= Any
Any =
    ## <Any>: a temporal operator "any t1, .., tn". See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Any
    element Any { Any.type }
    
# *** (Recurring) Timer ***
Timer.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
Timer.content = Interval_term.content
Timer.type = Timer.content, Timer.attlist
Node.choice |= Timer
Timer =
    ## <Timer>: a temporal operator "After t Every tx". See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Timer
    element Timer { Timer.type }
    
# *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equals | Finishes) ***
IntervalAlgebraOperator.attlist = iri-att.choice?, Type.attlist, commonNode.attlist
IntervalAlgebraOperator.content = Node.header, arg_interval.choice, arg_interval.choice
IntervalAlgebraOperator.type = IntervalAlgebraOperator.content, IntervalAlgebraOperator.attlist
Node.choice |= During
During =
    ## <During>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-During
    element During { IntervalAlgebraOperator.type }
Node.choice |= Overlaps
Overlaps =
    ## <Overlaps>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Overlaps
    element Overlaps { IntervalAlgebraOperator.type }
Node.choice |= Starts
Starts =
    ## <Starts>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Starts
    element Starts { IntervalAlgebraOperator.type }
Node.choice |= Precedes
Precedes =
    ## <Precedes>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Precedes
    element Precedes { IntervalAlgebraOperator.type }
Node.choice |= Succeeds
Succeeds =
    ## <Succeeds>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Succeeds
    element Succeeds { IntervalAlgebraOperator.type }
Node.choice |= Meets
Meets =
    ## <Meets>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Meets
    element Meets { IntervalAlgebraOperator.type }
Node.choice |= Finishes
Finishes =
    ## <Finishes>: an interval operator. See
    ## http://www.reaction.ruleml.org/1.0/glossary/#gloss-Finishes
    element Finishes { IntervalAlgebraOperator.type }
