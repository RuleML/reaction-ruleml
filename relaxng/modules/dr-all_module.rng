<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://ruleml.org/1.0/designPattern/include_expansion_schema.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<grammar xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns:dcterms="http://purl.org/dc/terms/" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <dc:title>Reaction RuleML for DR</dc:title>
  <dc:version>1.0</dc:version>
  <dc:creator>Tara Athan (taraathan AT gmail.com</dc:creator>
  <dc:creator>Adrian Paschke</dc:creator>
  <dc:subject>RuleML, Reaction, Deliberation</dc:subject>
  <dc:description>The expansion module for reserved spatial and temporal predicates and relations.</dc:description>
  <dc:language>en</dc:language>
  <dcterms:rights>TBD</dcterms:rights>
  <dc:relation>http://reaction.ruleml.org</dc:relation>
  <start combine="choice">
    <notAllowed/>
  </start>
  <define name="formula-assert.content" combine="choice">
    <ref name="formula_AssertRetract.content"/>
  </define>
  <define name="formula-query.content" combine="choice">
    <ref name="formula_Query.content"/>
  </define>
  <define name="commonInit.attlist" combine="interleave">
    <optional>
      <ref name="key-att.choice"/>
    </optional>
  </define>
  <define name="commonInit.attlist" combine="interleave">
    <optional>
      <ref name="keyref-att.choice"/>
    </optional>
  </define>
  <define name="rule-implementation.content" combine="choice">
    <a:documentation>An internal group for the implementation of a rule in the Reaction RuleML language</a:documentation>
    <ref name="DerivationRule.content"/>
  </define>
  <define name="inner-quantifier.content" combine="choice">
    <a:documentation>An internal group for the inner quantifiers in the Reaction RuleML language</a:documentation>
    <choice>
      <element name="Forall">
        <ref name="Forall-quantifier.type.def"/>
      </element>
      <element name="Exists">
        <ref name="Exists-quantifier.type.def"/>
      </element>
      <ref name="Quantifier"/>
    </choice>
  </define>
  <define name="time_primitives.content" combine="choice">
    <a:documentation>An internal group for the time primitives for interpretation as time</a:documentation>
    <choice>
      <ref name="arg.content"/>
      <ref name="spatial_temporal_algebra_group.content"/>
    </choice>
  </define>
  <define name="spatial_primitives.content" combine="choice">
    <a:documentation>An internal group for the spatial primitives for interpretation as spatial</a:documentation>
    <choice>
      <ref name="arg.content"/>
      <ref name="spatial_temporal_algebra_group.content"/>
    </choice>
  </define>
  <define name="interval_primitives.content" combine="choice">
    <a:documentation>Interval primitives</a:documentation>
    <choice>
      <ref name="arg.content"/>
      <ref name="interval_algebra_group.content"/>
    </choice>
  </define>
  <!-- extended descriptors in Reaction RuleML -->
  <!-- *** Forall *** -->
  <define name="Forall">
    <a:documentation>&lt;Forall&gt;: "forall declared variables [such that formula]". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Forall</a:documentation>
    <ref name="Forall-node.choice"/>
  </define>
  <define name="Forall-node.choice" combine="choice">
    <ref name="Quantifier"/>
  </define>
  <!-- *** Exists *** -->
  <define name="Exists">
    <a:documentation>&lt;Exists&gt;: "exists declared variables [such that formula]". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Forall</a:documentation>
    <ref name="Exists-node.choice"/>
  </define>
  <define name="Exists-node.choice" combine="choice">
    <ref name="Quantifier"/>
  </define>
  <!-- needed for Quantifier and quantification -->
  <define name="formula-forall.type.def">
    <ref name="formula_Forall.content"/>
    <ref name="formula_Forall.attlist"/>
  </define>
  <define name="formula-forall">
    <element name="formula">
      <ref name="formula-forall.type.def"/>
    </element>
  </define>
  <!-- *** Implies *** -->
  <define name="Implies">
    <ref name="Implies-node.choice"/>
  </define>
  <!-- *** then *** -->
  <define name="then.content" combine="choice">
    <ref name="head_Implies.content"/>
  </define>
  <define name="then.type.def">
    <interleave>
      <optional>
        <ref name="head_Implies.attlist"/>
      </optional>
      <ref name="head_Implies.content"/>
    </interleave>
  </define>
  <!-- *** Entails *** -->
  <define name="Entails">
    <ref name="Entails-node.choice"/>
  </define>
  <!-- *** Equivalent *** -->
  <define name="Equivalent">
    <ref name="Equivalent-node.choice"/>
  </define>
  <!-- *** Rulebase *** -->
  <define name="Rulebase">
    <ref name="Rulebase-node.choice"/>
  </define>
  <!-- *** And *** -->
  <define name="And">
    <ref name="And-node.choice"/>
  </define>
  <define name="And-Query.main" combine="choice">
    <zeroOrMore>
      <ref name="formula_And-query-edge.choice"/>
    </zeroOrMore>
  </define>
  <define name="formula_And-query-edge.choice" combine="choice">
    <a:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  </a:documentation>
    <ref name="formula_And-query.edge.def"/>
  </define>
  <define name="formula_And-query.edge.def">
    <a:documentation>The formula role of a conjunctive (&lt;And&gt;) expression, 
Within And ...</a:documentation>
    <element name="formula">
      <a:documentation>&lt;formula&gt;: contains a single formula. See  
http://www.ruleml.org/1.0/glossary/#gloss-formula</a:documentation>
      <interleave>
        <optional>
          <ref name="formula_And.attlist"/>
        </optional>
        <ref name="formula_And-query.content"/>
      </interleave>
    </element>
  </define>
  <define name="formula_And-query.content" combine="choice">
    <a:documentation>Formulas within conjunctions consist of a single formula</a:documentation>
    <ref name="AndQueryFormula.choice"/>
  </define>
  <define name="AndQueryFormula.choice" combine="choice">
    <a:documentation>formulas allowed to participate in conjunctions. </a:documentation>
    <choice>
      <ref name="SimpleFormula-node.choice"/>
      <ref name="And-Query-node.choice"/>
      <ref name="Or-Query-node.choice"/>
      <ref name="Negation-node.choice"/>
      <ref name="NegationAsFailure-node.choice"/>
      <ref name="Implication-fo-node.choice"/>
      <ref name="Forall-fo-node.choice"/>
      <ref name="Exists-fo-node.choice"/>
    </choice>
  </define>
  <!-- *** Or *** -->
  <define name="Or">
    <ref name="Or-node.choice"/>
  </define>
  <define name="Or-Query.main" combine="choice">
    <zeroOrMore>
      <ref name="formula_Or-query-edge.choice"/>
    </zeroOrMore>
  </define>
  <define name="formula_Or-query-edge.choice" combine="choice">
    <a:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  </a:documentation>
    <ref name="formula_Or-query.edge.def"/>
  </define>
  <define name="formula_Or-query.edge.def">
    <a:documentation>The formula role of a conjunctive (&lt;Or&gt;) expression, 
Within Or ...</a:documentation>
    <element name="formula">
      <a:documentation>&lt;formula&gt;: contains a single formula. See  
http://www.ruleml.org/1.0/glossary/#gloss-formula</a:documentation>
      <interleave>
        <optional>
          <ref name="formula_Or.attlist"/>
        </optional>
        <ref name="formula_Or-query.content"/>
      </interleave>
    </element>
  </define>
  <define name="formula_Or-query.content" combine="choice">
    <a:documentation>Formulas within conjunctions consist of a single formula</a:documentation>
    <ref name="OrQueryFormula.choice"/>
  </define>
  <define name="OrQueryFormula.choice" combine="choice">
    <a:documentation>formulas allowed to participate in conjunctions. </a:documentation>
    <choice>
      <ref name="SimpleFormula-node.choice"/>
      <ref name="And-Query-node.choice"/>
      <ref name="Or-Query-node.choice"/>
      <ref name="Negation-node.choice"/>
      <ref name="NegationAsFailure-node.choice"/>
      <ref name="Implication-fo-node.choice"/>
      <ref name="Forall-fo-node.choice"/>
      <ref name="Exists-fo-node.choice"/>
    </choice>
  </define>
  <!-- *** @mapMaterial *** -->
  <define name="mapMaterial.attrib">
    <ref name="mapMaterial-att-inf.choice"/>
  </define>
  <!-- *** @material *** -->
  <define name="material.attrib">
    <ref name="material-att-inf.choice"/>
  </define>
  <!-- *** @mapDirection *** -->
  <define name="mapDirection.attrib">
    <ref name="mapDirection-att-inf.choice"/>
  </define>
  <!-- *** @direction *** -->
  <define name="direction.attrib">
    <ref name="direction-att-inf.choice"/>
  </define>
  <!-- *** @mapClosure *** -->
  <define name="mapClosure.attrib">
    <optional>
      <ref name="mapClosure-att.choice"/>
    </optional>
  </define>
  <!-- *** @closure *** -->
  <define name="closure.attrib">
    <optional>
      <ref name="closure-att.choice"/>
    </optional>
  </define>
  <!-- *** Atom *** -->
  <define name="Atom">
    <ref name="Atom-node.choice"/>
  </define>
  <!-- *** Rel *** -->
  <define name="reRel.attlist" combine="interleave">
    <optional>
      <ref name="per-effect-att.choice"/>
    </optional>
  </define>
  <!-- *** slot *** -->
  <define name="slot">
    <ref name="slot-edge.choice"/>
  </define>
  <!-- *** arg *** -->
  <define name="arg">
    <ref name="positionalArgument-edge.choice"/>
  </define>
  <!-- *** Data *** -->
  <define name="Data">
    <ref name="DataTerm.choice"/>
  </define>
  <!-- 	*** Var with mode attribute *** -->
  <define name="Var">
    <ref name="Variable-node.choice"/>
  </define>
  <define name="reVar.attlist" combine="interleave">
    <optional>
      <ref name="mode-att.choice"/>
    </optional>
  </define>
  <!-- *** repo *** -->
  <define name="repo">
    <ref name="restOfPositionalArguments-edge.choice"/>
  </define>
  <!-- *** resl *** -->
  <define name="resl">
    <ref name="restOfSlots-edge.choice"/>
  </define>
  <!-- *** Equal *** -->
  <define name="Equal">
    <ref name="Equal-node.choice"/>
  </define>
  <!-- in time module -->
  <define name="SimpleKeyTerm.choice" combine="choice">
    <ref name="Time_term"/>
  </define>
  <define name="SimpleFormula-node.choice" combine="choice">
    <ref name="Time_formula"/>
  </define>
  <!-- in spatial module -->
  <define name="SimpleKeyTerm.choice" combine="choice">
    <ref name="Spatial_term"/>
  </define>
  <define name="SimpleFormula-node.choice" combine="choice">
    <ref name="Spatial_formula"/>
  </define>
  <!-- in interval module -->
  <define name="SimpleKeyTerm.choice" combine="choice">
    <ref name="Interval_term"/>
  </define>
  <define name="SimpleFormula-node.choice" combine="choice">
    <ref name="Interval_formula"/>
  </define>
  <!-- 	    *** Assert *** -->
  <define name="reAssert.attlist" combine="interleave">
    <optional>
      <ref name="commonNode.attlist"/>
    </optional>
  </define>
  <define name="reAssert.attlist" combine="interleave">
    <optional>
      <ref name="mapClosure-att.choice"/>
    </optional>
  </define>
  <define name="reAssert.attlist" combine="interleave">
    <optional>
      <ref name="safety-att.choice"/>
    </optional>
  </define>
  <define name="reAssert.attlist" combine="interleave">
    <optional>
      <ref name="size-att.choice"/>
    </optional>
  </define>
  <define name="curieOrIRI.datatype" combine="choice">
    <a:documentation>data type definition </a:documentation>
    <choice>
      <ref name="curie.datatype"/>
      <data type="anyURI"/>
    </choice>
  </define>
  <define name="curieOrAbsIRI.datatype" combine="choice">
    <a:documentation>data type definition         </a:documentation>
    <choice>
      <ref name="curie.datatype"/>
      <ref name="absIRI.datatype"/>
    </choice>
  </define>
  <define name="termOrCurieOrIRI.datatype" combine="choice">
    <a:documentation>data type definition         </a:documentation>
    <choice>
      <ref name="term.datatype"/>
      <ref name="curie.datatype"/>
      <data type="anyURI"/>
    </choice>
  </define>
  <define name="termOrCurieOrAbsIRI">
    <a:documentation>data type definition         </a:documentation>
    <choice>
      <ref name="term.datatype"/>
      <ref name="curie.datatype"/>
      <ref name="absIRI.datatype"/>
    </choice>
  </define>
  <define name="absIRI.datatype" combine="choice">
    <data type="anyURI">
      <param name="pattern">[\i-[:]][\c-[:]]+:.+</param>
    </data>
  </define>
  <define name="curie.datatype" combine="choice">
    <a:documentation>data type definition         </a:documentation>
    <data type="string">
      <param name="minLength">1</param>
      <param name="pattern">(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)</param>
    </data>
  </define>
  <define name="term.datatype" combine="choice">
    <data type="Name">
      <param name="pattern">[\i-[:]][/\c-[:]]*</param>
    </data>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
      * meta            descriptive metadata 
      * scope           scope  (e.g. for scoped reasoning)	
      * guard			  guard (e.g. for guard constraints in scoped reasoning)
      * evaluation      semantic profile for evaluation 
      * signature       interface signature, pattern definition,
      * qualification   qualification, e.g. priorities, validity, strategy
      * quantification  quantification
      * oid             object id     
  -->
  <!-- *** oid *** -->
  <define name="oid">
    <a:documentation>&lt;oid&gt;: defines the object id. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-oid</a:documentation>
    <ref name="objectIdentifier-edge.choice"/>
  </define>
  <!--  *** meta *** -->
  <define name="meta">
    <a:documentation>&lt;meta&gt;: defines a descriptive metadata annotation. See 
http://www.reaction.ruleml.org/1.0/glossary/#gloss-meta</a:documentation>
    <ref name="metaKnowledge-edge.choice"/>
  </define>
  <define name="header.attlist" combine="interleave">
    <a:documentation>the typical attribute list of edges in the header</a:documentation>
    <optional>
      <ref name="index-attrib.choice"/>
    </optional>
  </define>
  <define name="header.attlist" combine="interleave">
    <optional>
      <ref name="commonInit.attlist"/>
    </optional>
  </define>
  <!-- *** scope *** -->
  <define name="scope.attlist" combine="interleave">
    <a:documentation/>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="scope.content" combine="choice">
    <optional>
      <ref name="formula-query.content"/>
    </optional>
  </define>
  <define name="scope.type.def">
    <ref name="scope.content"/>
    <ref name="scope.attlist"/>
  </define>
  <define name="scope">
    <element name="scope">
      <a:documentation>&lt;scope&gt;: allows defining a metadata-based scope on the knowledge base for scoped reasoning. See 
http://www.reaction.ruleml.org/1.0/glossary/#gloss-scope </a:documentation>
      <ref name="scope.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="scope"/>
  </define>
  <!-- *** guard ***     -->
  <define name="guard.attlist" combine="interleave">
    <a:documentation>the attribute list of the guard edge</a:documentation>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="guard.content" combine="choice">
    <ref name="PremiseFormula.choice"/>
  </define>
  <define name="guard.type.def">
    <ref name="guard.content"/>
    <ref name="guard.attlist"/>
  </define>
  <define name="guard">
    <element name="guard">
      <a:documentation>&lt;guard&gt;: a guard defines a simple pre-constraint which applies before the main reasoning. See 
http://www.reaction.ruleml.org/1.0/glossary/#gloss-guard </a:documentation>
      <ref name="guard.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="guard"/>
  </define>
  <!-- *** evaluation *** -->
  <define name="evaluation.attlist" combine="interleave">
    <a:documentation>the attribute list of the evaluation edge</a:documentation>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="evaluation.content" combine="choice">
    <ref name="Profile"/>
  </define>
  <define name="evaluation.type.def">
    <ref name="evaluation.content"/>
    <ref name="evaluation.attlist"/>
  </define>
  <define name="evaluation">
    <element name="evaluation">
      <a:documentation>&lt;evaluation&gt;: defines the intended evaluation semantics as semantic &lt;Profile&gt;. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-evaluation</a:documentation>
      <ref name="evaluation.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="evaluation"/>
  </define>
  <!-- *** signature *** -->
  <define name="signature.attlist" combine="interleave">
    <a:documentation>the attribute list of the signature edge</a:documentation>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="signature.content" combine="choice">
    <ref name="formula-query.content"/>
  </define>
  <define name="signature.type.def">
    <ref name="signature.content"/>
    <ref name="signature.attlist"/>
  </define>
  <define name="signature">
    <element name="signature">
      <a:documentation>&lt;signature&gt;: defines the signature which can be used as public interface or pattern definition. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-signature</a:documentation>
      <ref name="signature.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="signature"/>
  </define>
  <!--  *** qualification *** -->
  <define name="qualification.attlist" combine="interleave">
    <a:documentation>the attribute list of the qualification edge</a:documentation>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="qualification.content" combine="choice">
    <ref name="formula-assert.content"/>
  </define>
  <define name="qualification.type.def">
    <ref name="qualification.content"/>
    <ref name="qualification.attlist"/>
  </define>
  <define name="qualification">
    <element name="qualification">
      <a:documentation>&lt;qualification&gt;: defines the qualification (qualifying metadata). See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-qualification</a:documentation>
      <ref name="qualification.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="qualification"/>
  </define>
  <!-- *** quantification *** -->
  <define name="quantification.attlist" combine="interleave">
    <a:documentation>the attribute list of the quantification</a:documentation>
    <optional>
      <ref name="header.attlist"/>
    </optional>
  </define>
  <define name="quantification.content" combine="choice">
    <ref name="inner-quantifier.content"/>
  </define>
  <define name="quantification.type.def">
    <ref name="quantification.content"/>
    <ref name="quantification.attlist"/>
  </define>
  <define name="quantification">
    <element name="quantification">
      <a:documentation>&lt;quantification&gt;: defines the quantification (quantifier). See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-quantification</a:documentation>
      <ref name="quantification.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="quantification"/>
  </define>
  <!--
    This module declares the following Reaction RuleML attributes:
       * @mode (mode declaration)
       * @safety (transactional)
       * @per (usage)
       * @all (yes|no)
       * @style (execution style)	
       * @key and @keyref for modularization of knowledge bases
  -->
  <!-- *** @mode *** -->
  <define name="mode-att.choice" combine="choice">
    <a:documentation>@mode: input-output mode declaration of the arguments in predicates and functions. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@mode</a:documentation>
    <ref name="mode.attrib.def"/>
  </define>
  <define name="mode.attrib.def">
    <attribute name="mode">
      <ref name="mode.datatype"/>
    </attribute>
  </define>
  <define name="mode.datatype" combine="choice">
    <choice>
      <value>+</value>
      <value>-</value>
      <value>?</value>
    </choice>
  </define>
  <!-- *** @safety *** -->
  <define name="safety-att.choice" combine="choice">
    <a:documentation>@safety: attribute defining the safety of the execution semantics for events, actions and primitives. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@safety    </a:documentation>
    <ref name="safety.attrib.def"/>
  </define>
  <define name="safety.attrib.def">
    <attribute name="safety">
      <ref name="safety.datatype"/>
    </attribute>
  </define>
  <define name="safety.datatype" combine="choice">
    <choice>
      <value>non-interrupting</value>
      <value>interrupting</value>
      <value>transactional</value>
    </choice>
  </define>
  <!-- *** @per *** -->
  <define name="interpretation_non-default.value" combine="choice">
    <a:documentation>the interpretation attribute may also have the "effect" value, indicating an effectful evaluation</a:documentation>
    <value>effect</value>
  </define>
  <define name="per-effect-att.choice" combine="choice">
    <a:documentation>@per: an attribute indicating the execution/interpretation semantics of a function or expression. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@per</a:documentation>
    <ref name="per-effect.attrib.def"/>
  </define>
  <define name="per-effect.attrib.def">
    <attribute name="per">
      <ref name="per-effect.datatype"/>
    </attribute>
  </define>
  <define name="per-effect.datatype" combine="choice">
    <a:documentation>the interpretation attribute on relations can take all values allowed for the
interpretation attribute on functions</a:documentation>
    <ref name="interpretation_non-default.value"/>
  </define>
  <define name="per-effect.datatype" combine="choice">
    <a:documentation>the interpretation attribute on relations can also have a value "modal",
indicating interpretation as a modal operator</a:documentation>
    <value>modal</value>
  </define>
  <!-- *** @size *** -->
  <define name="size-att.choice" combine="choice">
    <a:documentation>@size: an attribute acting as a counter for the number of occurences of events, actions and updates. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@size</a:documentation>
    <ref name="size.attrib.def"/>
  </define>
  <define name="size.attrib.def">
    <attribute name="size">
      <ref name="size.datatype"/>
    </attribute>
  </define>
  <define name="size.datatype" combine="choice">
    <data type="int"/>
  </define>
  <!-- *** @key *** -->
  <define name="key-att.choice" combine="choice">
    <a:documentation>@key: defines a unique key attribute which can be used for distributed referencing from a keyref attribute. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@key</a:documentation>
    <ref name="key.attrib.def"/>
  </define>
  <define name="key.attrib.def">
    <attribute name="key">
      <ref name="key.datatype"/>
    </attribute>
  </define>
  <define name="key.datatype" combine="choice">
    <ref name="curieOrAbsIRI.datatype"/>
  </define>
  <define name="keyref-att.choice" combine="choice">
    <a:documentation>@keyref: defines a reference to a corresponding unique key. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@keyref</a:documentation>
    <ref name="keyref.attrib.def"/>
  </define>
  <define name="keyref.attrib.def">
    <attribute name="keyref">
      <ref name="keyref.datatype"/>
    </attribute>
  </define>
  <define name="keyref.datatype" combine="choice">
    <ref name="curieOrAbsIRI.datatype"/>
  </define>
  <!--
    *** @style ***
     when absent, equivalent to: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
  -->
  <define name="style.attrib">
    <ref name="style-att.choice"/>
  </define>
  <define name="style-att.choice" combine="choice">
    <a:documentation>@style: defines a reference to a corresponding unique key. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-@style</a:documentation>
    <ref name="style.attrib.def"/>
  </define>
  <define name="style.attrib.def">
    <attribute name="style">
      <ref name="style.datatype"/>
    </attribute>
  </define>
  <define name="style.datatype" combine="choice">
    <choice>
      <value>active</value>
      <value>messaging</value>
      <value>reasoning</value>
    </choice>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Rule
    * if
    * then
    * else
  -->
  <!-- *** Rule *** -->
  <define name="Rule-datt.choice" combine="choice">
    <a:documentation/>
    <interleave>
      <ref name="direction-att-inf.choice"/>
      <ref name="material-att-inf.choice"/>
    </interleave>
  </define>
  <define name="reRule.attlist" combine="interleave">
    <optional>
      <ref name="style-att.choice"/>
    </optional>
  </define>
  <define name="reRule.attlist" combine="interleave">
    <optional>
      <ref name="closure-att.choice"/>
    </optional>
  </define>
  <define name="reRule.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <define name="reRule.attlist" combine="interleave">
    <optional>
      <ref name="commonNode.attlist"/>
    </optional>
  </define>
  <define name="Rule.content" combine="choice">
    <ref name="Node.header"/>
    <optional>
      <ref name="rule-implementation.content"/>
    </optional>
  </define>
  <define name="Rule.type.def">
    <ref name="Rule.content"/>
    <interleave>
      <ref name="Rule-datt.choice"/>
      <ref name="reRule.attlist"/>
    </interleave>
  </define>
  <define name="Rule">
    <element name="Rule">
      <a:documentation>&lt;Rule&gt;: defines a rule in Reaction RuleML. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Rule</a:documentation>
      <ref name="Rule.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Rule"/>
  </define>
  <define name="AssertRetractFormula.choice" combine="choice">
    <ref name="Rule"/>
  </define>
  <define name="ForallFormula.choice" combine="choice">
    <ref name="Rule"/>
  </define>
  <define name="RulebaseFormula.choice" combine="choice">
    <ref name="Rule"/>
  </define>
  <!-- *** else *** -->
  <define name="else">
    <element name="else">
      <a:documentation>&lt;else&gt;: edge defining an alternative conclusion in a if-then-else rule. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-else</a:documentation>
      <ref name="then.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="else"/>
  </define>
  <define name="generic-Node.attlist" combine="interleave">
    <a:documentation/>
    <optional>
      <ref name="iri-att.choice"/>
    </optional>
  </define>
  <define name="generic-Node.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <define name="generic-Node.attlist" combine="interleave">
    <optional>
      <ref name="commonNode.attlist"/>
    </optional>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Negation		generic polymorphig negation
    * Naf           negation as failure (inflationary negation in production rules), weak negation
    * Neg           classical negation, strong negation
  -->
  <!-- *** Negation *** -->
  <define name="Negation.attlist" combine="interleave">
    <a:documentation>the Negation attribute list</a:documentation>
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <define name="Negation.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="formula-negation.choice"/>
  </define>
  <define name="formula-negation.choice" combine="choice">
    <ref name="formula-negation"/>
  </define>
  <define name="Negation.type.def">
    <ref name="Negation.content"/>
    <ref name="Negation.attlist"/>
  </define>
  <define name="Negation">
    <element name="Negation">
      <a:documentation>&lt;Negation&gt;: a generic polymorphic negation, which is interpreted by the intended semantics (i.e. semantic profile). See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Negation</a:documentation>
      <ref name="Negation.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Negation"/>
  </define>
  <define name="Negation-node.choice" combine="choice">
    <ref name="Negation"/>
  </define>
  <!---->
  <define name="formula-negation.attlist" combine="interleave">
    <optional>
      <ref name="commonInit.attlist"/>
    </optional>
  </define>
  <define name="formula-negation.content" combine="choice">
    <ref name="NegFormula.choice"/>
  </define>
  <define name="formula-negation.type.def">
    <ref name="formula-negation.content"/>
    <ref name="formula-negation.attlist"/>
  </define>
  <define name="formula-negation">
    <element name="formula">
      <ref name="formula-negation.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="formula-negation"/>
  </define>
  <!-- *** Naf *** -->
  <define name="Naf">
    <ref name="NegationAsFailure-node.choice"/>
  </define>
  <define name="reNaf.attlist" combine="interleave">
    <optional>
      <ref name="iri-att.choice"/>
    </optional>
  </define>
  <define name="reNaf.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <define name="NafFormula.choice" combine="choice">
    <ref name="NegationAsFailure-node.choice"/>
  </define>
  <!-- *** Neg *** -->
  <define name="reNeg.attlist" combine="interleave">
    <optional>
      <ref name="iri-att.choice"/>
    </optional>
  </define>
  <define name="reNeg.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <define name="NegFormula.choice" combine="choice">
    <ref name="NegationAsFailure-node.choice"/>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Quantifier  generic quantifier
    * Forall		predefined inner quantifier (used in quantification metatag)
    * Exist		predefined inner quantifier (used in qualification metatag)
  -->
  <!-- *** Quantifier *** -->
  <define name="Quantifier.attlist" combine="interleave">
    <a:documentation>Quantifier attribute list with the @type and @iri</a:documentation>
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <define name="Quantifier.content" combine="choice">
    <ref name="Quantifier.header"/>
    <ref name="Quantifier.main"/>
  </define>
  <define name="Quantifier.header" combine="interleave">
    <optional>
      <ref name="Node.header"/>
    </optional>
  </define>
  <define name="Quantifier.main" combine="choice">
    <ref name="boundVariables.choice"/>
    <optional>
      <ref name="formula-quant.choice"/>
    </optional>
  </define>
  <define name="formula-quant.choice" combine="choice">
    <ref name="formula-quant"/>
  </define>
  <define name="formula-quant">
    <element name="formula">
      <ref name="formula-forall.type.def"/>
    </element>
  </define>
  <define name="Quantifier.type.def">
    <ref name="Quantifier.content"/>
    <ref name="Quantifier.attlist"/>
  </define>
  <define name="Quantifier">
    <element name="Quantifier">
      <a:documentation>&lt;Quantifier&gt;: a generic quantifier - "quantify over declared variables such that ...".See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Quantifier</a:documentation>
      <ref name="Quantifier.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Quantifier"/>
  </define>
  <!-- make the quantifier constraint restrictions ("such that") optional -->
  <define name="Exists-quantifier.content" combine="choice">
    <ref name="Exists.header"/>
    <ref name="Exists-quantifier.main"/>
  </define>
  <define name="Exists-quantifier.main" combine="choice">
    <ref name="boundVariables.choice"/>
    <optional>
      <ref name="formula-quant.choice"/>
    </optional>
  </define>
  <define name="Exists-quantifier.type.def">
    <interleave>
      <ref name="Exists-datt.choice"/>
      <ref name="reExists.attlist"/>
    </interleave>
    <ref name="Exists-quantifier.content"/>
  </define>
  <!-- make the quantifier constraint restrictions ("such that") optional -->
  <define name="Forall-quantifier.content" combine="choice">
    <ref name="Forall.header"/>
    <ref name="Forall-quantifier.main"/>
  </define>
  <define name="Forall-quantifier.main" combine="choice">
    <ref name="boundVariables.choice"/>
    <optional>
      <ref name="formula-quant.choice"/>
    </optional>
  </define>
  <define name="Forall-quantifier.type.def">
    <interleave>
      <ref name="Forall-datt.choice"/>
      <ref name="reForall.attlist"/>
    </interleave>
    <ref name="Forall-quantifier.content"/>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Profile         generic semantic profile
  -->
  <!--   *** Profile *** -->
  <define name="Profile.attlist" combine="interleave">
    <a:documentation>Profile attribute list with @type, @iri, @direction, @safety, @size</a:documentation>
    <optional>
      <ref name="iri-att.choice"/>
    </optional>
  </define>
  <define name="Profile.attlist" combine="interleave">
    <optional>
      <ref name="direction.attrib"/>
    </optional>
  </define>
  <define name="Profile.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <define name="Profile.attlist" combine="interleave">
    <optional>
      <ref name="commonNode.attlist"/>
    </optional>
  </define>
  <define name="Profile.attlist" combine="interleave">
    <optional>
      <ref name="safety-att.choice"/>
    </optional>
  </define>
  <define name="Profile.attlist" combine="interleave">
    <optional>
      <ref name="size-att.choice"/>
    </optional>
  </define>
  <define name="Profile.content" combine="choice">
    <ref name="Node.header"/>
    <zeroOrMore>
      <ref name="formula_Profile-edge.choice"/>
    </zeroOrMore>
  </define>
  <define name="formula_Profile-edge.choice" combine="choice">
    <ref name="formula_AssertRetract-edge.choice"/>
  </define>
  <!--
    relaxed
    formula_Profile-edge.choice |= profile_anycontent
  -->
  <define name="Profile.type.def">
    <ref name="Profile.content"/>
    <ref name="Profile.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Profile"/>
  </define>
  <define name="Profile">
    <element name="Profile">
      <a:documentation>&lt;Profile&gt;: defines (or references) the intended semantics as a semantic profile. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Quantifier</a:documentation>
      <ref name="Profile.type.def"/>
    </element>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Time
  -->
  <define name="Time.attlist" combine="interleave">
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <define name="Time.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="argumentsForTime.sequence"/>
  </define>
  <define name="argumentsForTime.sequence" combine="choice">
    <zeroOrMore>
      <ref name="arg_time.choice"/>
    </zeroOrMore>
    <optional>
      <ref name="repo"/>
    </optional>
    <zeroOrMore>
      <ref name="slot"/>
    </zeroOrMore>
    <optional>
      <ref name="resl"/>
    </optional>
  </define>
  <define name="arg_time.choice" combine="choice">
    <ref name="arg_time"/>
  </define>
  <define name="Time.type.def">
    <ref name="Time.content"/>
    <ref name="Time.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Time_formula"/>
  </define>
  <define name="Time_term">
    <element name="Time">
      <a:documentation>&lt;Time&gt;: generic Time element. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Time</a:documentation>
      <ref name="Time.type.def"/>
    </element>
  </define>
  <define name="Time_formula">
    <element name="Time">
      <ref name="Time.type.def"/>
    </element>
  </define>
  <!-- *** arg *** -->
  <define name="arg_time.attlist" combine="interleave">
    <optional>
      <ref name="index-attrib.choice"/>
    </optional>
  </define>
  <define name="arg_time.attlist" combine="interleave">
    <optional>
      <ref name="commonInit.attlist"/>
    </optional>
  </define>
  <define name="arg_time.content" combine="choice">
    <ref name="time_primitives.content"/>
  </define>
  <define name="arg_time.type.def">
    <ref name="arg_time.content"/>
    <ref name="arg_time.attlist"/>
  </define>
  <define name="arg_time">
    <element name="arg">
      <ref name="arg_time.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="arg_time"/>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Spatial
  -->
  <!--   *** Spatial *** -->
  <define name="Spatial.attlist" combine="interleave">
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <define name="Spatial.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="argumentsForSpatial.sequence"/>
  </define>
  <define name="argumentsForSpatial.sequence" combine="choice">
    <zeroOrMore>
      <ref name="arg_spatial.choice"/>
    </zeroOrMore>
    <optional>
      <ref name="repo"/>
    </optional>
    <zeroOrMore>
      <ref name="slot"/>
    </zeroOrMore>
    <optional>
      <ref name="resl"/>
    </optional>
  </define>
  <define name="arg_spatial.choice" combine="choice">
    <ref name="arg_spatial"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Spatial_formula"/>
  </define>
  <define name="Spatial.type.def">
    <ref name="Spatial.content"/>
    <ref name="Spatial.attlist"/>
  </define>
  <define name="Spatial_term">
    <element name="Spatial">
      <a:documentation>&lt;Spatial&gt;: generic Spatial element. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Spatial</a:documentation>
      <ref name="Spatial.type.def"/>
    </element>
  </define>
  <define name="Spatial_formula">
    <element name="Spatial">
      <ref name="Spatial.type.def"/>
    </element>
  </define>
  <!-- *** arg *** -->
  <define name="arg_spatial.attlist" combine="interleave">
    <optional>
      <ref name="index-attrib.choice"/>
    </optional>
  </define>
  <define name="arg_spatial.attlist" combine="interleave">
    <optional>
      <ref name="commonInit.attlist"/>
    </optional>
  </define>
  <define name="arg_spatial.content" combine="choice">
    <ref name="spatial_primitives.content"/>
  </define>
  <define name="arg_spatial.type.def">
    <ref name="arg_spatial.content"/>
    <ref name="arg_spatial.attlist"/>
  </define>
  <define name="arg_spatial">
    <element name="arg">
      <ref name="arg_spatial.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="arg_spatial"/>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
    * Interval
  -->
  <!--   *** Interval *** -->
  <define name="Interval.attlist" combine="interleave">
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <define name="arg_interval.choice" combine="choice">
    <ref name="arg_interval"/>
  </define>
  <define name="Interval_term.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="arg_interval.choice"/>
    <optional>
      <ref name="arg_interval.choice"/>
    </optional>
  </define>
  <define name="Interval_formula.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="arg_interval.choice"/>
    <optional>
      <ref name="arg_interval.choice"/>
    </optional>
  </define>
  <!---->
  <define name="Interval_term.type.def">
    <ref name="Interval_term.content"/>
    <ref name="Interval.attlist"/>
  </define>
  <define name="Interval_formula.type.def">
    <ref name="Interval_formula.content"/>
    <ref name="Interval.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Interval_formula"/>
  </define>
  <define name="Interval_term">
    <element name="Interval">
      <a:documentation>&lt;Time&gt;: generic Interval element. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Interval</a:documentation>
      <ref name="Interval_term.type.def"/>
    </element>
  </define>
  <define name="Interval_formula">
    <element name="Interval">
      <ref name="Interval_formula.type.def"/>
    </element>
  </define>
  <!-- *** arg *** -->
  <define name="arg_interval.attlist" combine="interleave">
    <optional>
      <ref name="index-attrib.choice"/>
    </optional>
  </define>
  <define name="arg_interval.attlist" combine="interleave">
    <optional>
      <ref name="commonInit.attlist"/>
    </optional>
  </define>
  <define name="arg_interval.content" combine="choice">
    <ref name="interval_primitives.content"/>
  </define>
  <define name="arg_interval.type.def">
    <ref name="arg_interval.content"/>
    <ref name="arg_interval.attlist"/>
  </define>
  <define name="arg_interval">
    <element name="arg">
      <ref name="arg_interval.type.def"/>
    </element>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="arg_interval"/>
  </define>
  <!--
    This module declares the following Reaction RuleML elements:
                    * Operator (generic operator)
                     
                     Spatial, Temporal, Interval Function Constructs 
                     
                     * After
                     * Before
    				  * Every
                     * Any
                     * Timer
                     
                     
                     (Allen's) Interval Relations
                     
                     * During
                     * Overlaps
                     * Starts
                     * Precedes
                     * Succeeds
                     * Meets
                     * Equal
                     * Finishes
  -->
  <!-- (After | Before | Any | Every | Timer | Operator) -->
  <define name="spatial_temporal_algebra_group.content" combine="choice">
    <choice>
      <ref name="After"/>
      <ref name="Before"/>
      <ref name="Every"/>
      <ref name="Any"/>
      <ref name="Timer"/>
      <ref name="Operator_any"/>
    </choice>
  </define>
  <define name="Operator_any">
    <element name="Operator">
      <a:documentation>&lt;Operator&gt;: a generic Operator element which can be overloaded. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Operator    </a:documentation>
      <ref name="Any.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Operator_any"/>
  </define>
  <!-- (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equals | Finishes | Operator) -->
  <define name="interval_algebra_group.content" combine="choice">
    <choice>
      <ref name="During"/>
      <ref name="Overlaps"/>
      <ref name="Starts"/>
      <ref name="Precedes"/>
      <ref name="Succeeds"/>
      <ref name="Meets"/>
      <ref name="IntervalAlgebraEqual"/>
      <ref name="Finishes"/>
      <ref name="IntervalAlgebraOperator"/>
    </choice>
  </define>
  <define name="IntervalAlgebraEqual">
    <element name="Equal">
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="IntervalAlgebraOperator">
    <element name="Operator">
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="IntervalAlgebraOperator.attlist" combine="interleave">
    <optional>
      <ref name="generic-Node.attlist"/>
    </optional>
  </define>
  <!-- *** After / Before*** -->
  <define name="After.attlist" combine="interleave">
    <optional>
      <ref name="IntervalAlgebraOperator.attlist"/>
    </optional>
  </define>
  <define name="After.content" combine="choice">
    <ref name="Interval_term.content"/>
  </define>
  <define name="After.type.def">
    <ref name="After.content"/>
    <ref name="After.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="After"/>
  </define>
  <define name="After">
    <element name="After">
      <a:documentation>&lt;After&gt;: a temporal operator "t2 after t1". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-After  </a:documentation>
      <ref name="After.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Before"/>
  </define>
  <define name="Before">
    <element name="Before">
      <a:documentation>&lt;Before&gt;: a temporal operator "t1 before t2". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-After</a:documentation>
      <ref name="After.type.def"/>
    </element>
  </define>
  <!-- *** Every *** -->
  <define name="Every.attlist" combine="interleave">
    <optional>
      <ref name="IntervalAlgebraOperator.attlist"/>
    </optional>
  </define>
  <define name="Every.content" combine="choice">
    <ref name="Node.header"/>
    <optional>
      <ref name="arg_interval.choice"/>
    </optional>
  </define>
  <define name="Every.type.def">
    <ref name="Every.content"/>
    <ref name="Every.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Every"/>
  </define>
  <define name="Every">
    <element name="Every">
      <a:documentation>&lt;Every&gt;: a temporal operator "every t". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Every</a:documentation>
      <ref name="Every.type.def"/>
    </element>
  </define>
  <!-- *** Any *** -->
  <define name="Any.attlist" combine="interleave">
    <optional>
      <ref name="IntervalAlgebraOperator.attlist"/>
    </optional>
  </define>
  <define name="Any.content" combine="choice">
    <ref name="Node.header"/>
    <zeroOrMore>
      <ref name="arg_interval.choice"/>
    </zeroOrMore>
  </define>
  <define name="Any.type.def">
    <ref name="Any.content"/>
    <ref name="Any.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Any"/>
  </define>
  <define name="Any">
    <element name="Any">
      <a:documentation>&lt;Any&gt;: a temporal operator "any t1, .., tn". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Any</a:documentation>
      <ref name="Any.type.def"/>
    </element>
  </define>
  <!-- *** (Recurring) Timer *** -->
  <define name="Timer.attlist" combine="interleave">
    <optional>
      <ref name="IntervalAlgebraOperator.attlist"/>
    </optional>
  </define>
  <define name="Timer.content" combine="choice">
    <ref name="Interval_term.content"/>
  </define>
  <define name="Timer.type.def">
    <ref name="Timer.content"/>
    <ref name="Timer.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Timer"/>
  </define>
  <define name="Timer">
    <element name="Timer">
      <a:documentation>&lt;Timer&gt;: a temporal operator "After t Every tx". See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Timer</a:documentation>
      <ref name="Timer.type.def"/>
    </element>
  </define>
  <!-- *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equals | Finishes) *** -->
  <define name="IntervalAlgebraOperator.content" combine="choice">
    <ref name="Node.header"/>
    <ref name="arg_interval.choice"/>
    <ref name="arg_interval.choice"/>
  </define>
  <define name="IntervalAlgebraOperator.type.def">
    <ref name="IntervalAlgebraOperator.content"/>
    <ref name="IntervalAlgebraOperator.attlist"/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="During"/>
  </define>
  <define name="During">
    <element name="During">
      <a:documentation>&lt;During&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-During</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Overlaps"/>
  </define>
  <define name="Overlaps">
    <element name="Overlaps">
      <a:documentation>&lt;Overlaps&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Overlaps</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Starts"/>
  </define>
  <define name="Starts">
    <element name="Starts">
      <a:documentation>&lt;Starts&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Starts</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Precedes"/>
  </define>
  <define name="Precedes">
    <element name="Precedes">
      <a:documentation>&lt;Precedes&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Precedes</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Succeeds"/>
  </define>
  <define name="Succeeds">
    <element name="Succeeds">
      <a:documentation>&lt;Succeeds&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Succeeds</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Meets"/>
  </define>
  <define name="Meets">
    <element name="Meets">
      <a:documentation>&lt;Meets&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Meets</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Finishes"/>
  </define>
  <define name="Finishes">
    <element name="Finishes">
      <a:documentation>&lt;Finishes&gt;: an interval operator. See
http://www.reaction.ruleml.org/1.0/glossary/#gloss-Finishes</a:documentation>
      <ref name="IntervalAlgebraOperator.type.def"/>
    </element>
  </define>
</grammar>
