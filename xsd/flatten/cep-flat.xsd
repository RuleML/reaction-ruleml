<?xml version="1.0" encoding="UTF-8"?>
<xs:schema elementFormDefault="qualified" targetNamespace="http://ruleml.org/spec"
    xmlns="http://ruleml.org/spec" xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xh11d="http://www.w3.org/1999/xhtml/datatypes/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation xml:lang="en">                       Complex Event Processing (CEP)
            dialect of Reaction RuleML           File: cep.xsd    Version: 1.02    Last
            Modification: 2015-07-19       </xs:documentation>
        <xs:appinfo>
            <dc:title>CEP Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>Reaction RuleML 1.02</dc:subject>
            <dc:description>spatio-temporal Derivation Rule dialect of Reaction
                RuleML</dc:description>
            <dc:date>2015-03-22T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!-- includes the datalog layer of deliberation ruleml -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML performatives.
            File:       performative_module.xsd Version: 1.02        Last Modification: 2015-07-19
            This module declares the       following RuleML elements: * RuleML * Assert * Retract *
            Query * act * formula See       http://www.ruleml.org/modularization for details about
            this modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built performative module for Reaction RuleML</dc:description>
            <dc:date>2015-07-19T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** RuleML ***
		The n-ary top-level of a RuleML document.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-RuleML

 	 Note: key and keyref object identifier are defined to be unique under the RuleML document root
 	 
 	 @vocab: an IRI that defines the mapping to use when a type term (e.g. a frame signature type) is referenced in an attribute value
 	 @prefix: a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
	-->
    <xs:attributeGroup name="RuleML.attlist">
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="RuleML.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="do" type="act.type"/>
                <xs:group ref="act.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="RuleML.type">
        <xs:group ref="RuleML.content"/>
        <xs:attributeGroup ref="RuleML.attlist"/>
    </xs:complexType>
    <xs:element name="RuleML" type="RuleML.type">
        <!-- key object identifiers and key object references defined on the top level -->
        <xs:unique name="keyOID">
            <xs:selector xpath=".//*"/>
            <xs:field xpath="@key"/>
        </xs:unique>
        <xs:keyref name="keyOIDref" refer="keyOID">
            <xs:selector xpath=".//*"/>
            <xs:field xpath="@keyref"/>
        </xs:keyref>
    </xs:element>
    <!--
    *** do ***
    The do role of the root element (<RuleML>).
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-do
  -->
    <xs:group name="act.content">
        <xs:choice>
            <xs:group ref="performative_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:attributeGroup name="act.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="act.type">
        <xs:group ref="act.content"/>
        <xs:attributeGroup ref="act.attlist"/>
    </xs:complexType>
    <!--
      *** Consult ***
      Consult (import) performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Consult
      
      dynamically "consults" (imports) knowledge resource, e.g. a message, documents or external resource (with the @iri attribute).
    -->
    <xs:attributeGroup name="Consult.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Consult.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:group ref="consult_imports.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Consult.type">
        <xs:group ref="Consult.content"/>
        <xs:attributeGroup ref="Consult.attlist"/>
    </xs:complexType>
    <xs:element name="Consult" type="Consult.type"/>
    <!--
     *** payload ***
     
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-payload
	-->
    <xs:attributeGroup name="payload.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="payload.content">
        <xs:choice>
            <xs:element ref="RuleML"/>
            <!-- a RuleML knowledge base -->
            <xs:element ref="Reify"/>
            <!-- reified knowledge as payload -->
            <xs:element ref="Var"/>
            <!-- for  binding knowledge to variables in meta programming -->
        </xs:choice>
    </xs:group>
    <xs:complexType name="payload.type">
        <xs:group ref="payload.content"/>
        <xs:attributeGroup ref="payload.attlist"/>
    </xs:complexType>
    <xs:element name="payload" type="payload.type"/>
    <!--
		*** Assert ***
		A KQML-like performative acting as a wrapper specifying that its content is
		asserted, making an 'implicit <Rulebase>' assumption.

		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Assert   
  -->
    <xs:attributeGroup name="Assert.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Assert.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Assert.type">
        <xs:group ref="Assert.content"/>
        <xs:attributeGroup ref="Assert.attlist"/>
    </xs:complexType>
    <xs:element name="Assert" type="Assert.type"/>
    <!--
		*** Retract ***
		A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
		content is to be deleted, making an 'implicit <Rulebase>' assumption.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Retract
  -->
    <xs:attributeGroup name="Retract.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Retract.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Retract.type">
        <xs:group ref="Retract.content"/>
        <xs:attributeGroup ref="Retract.attlist"/>
    </xs:complexType>
    <xs:element name="Retract" type="Retract.type"/>
    <!--
      *** Update ***
      Update action
      
      See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Update
  -->
    <xs:attributeGroup name="Update.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Update.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                    <xs:group ref="formula-assert.content"/>
                </xs:choice>
                <xs:choice minOccurs="0">
                    <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                    <xs:group ref="formula-assert.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Update.type">
        <xs:group ref="Update.content"/>
        <xs:attributeGroup ref="Update.attlist"/>
    </xs:complexType>
    <xs:element name="Update" type="Update.type"/>
    <!--
		*** Query ***
		A KQML-like performative acting as a wrapper specifying that its content is
		queried, making an 'implicit <Rulebase>' assumption.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Query
  -->
    <xs:attributeGroup name="Query.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Query.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-query.type"/>
                <xs:group ref="formula-query.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Query.type">
        <xs:group ref="Query.content"/>
        <xs:attributeGroup ref="Query.attlist"/>
    </xs:complexType>
    <xs:element name="Query" type="Query.type"/>
    <!--
      *** Answer ***
      Answer performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Answer
      
      It delivers the answer to a Query . The answer is given in terms of solved formulas, e.g.
      
      as a <Rulebase> that contains just 'solved' equations with the variable bindings
      
	  <Rulebase>
  		<Equal><Var>x</Var><Ind>a</Ind></Equal>
  		<Equal><Var>y</Var><Ind>b</Ind></Equal>
  		<Equal><Var>z</Var><Ind>c</Ind></Equal>
	  </Rulebase>
	  
	  as ground fact <Atom> matching the query / goal 
	  
	  <Atom>
	  	<Rel>p</Rel>
	  	<Ind>a</Ind>
	  	<Ind>b</Ind>
	  	<Ind>c</Ind>
	  </Atom>
	  
	  as solved ground entailments <Entails> of the answer from the queried (ground or instantiated / forward chained) rule base  
	  
	  With the optional <degree> role a truth/uncertainty value (between 0.0 and 1.0; 
	  with the truth values "1" for true and "0" for false in two-valued logics and "0.5" for unknown in three-valued logics) can be assigned to the answer. 
	  
	  An answer maybe be also just referenced by the local @key-@keyref mechanism  
	  or by the optional @iri attribute, in case of externally published answers. 
	  
	  With the optional @type attribute an answer type can be specified. 
	  The @safety optionally defines if the answer (event) is interrupting or non-interrupting 
	  and the @card attribute optionally defines the number of results contained in an Answer.
    -->
    <xs:attributeGroup name="Answer.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Answer.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-answer.type"/>
                <xs:group ref="formula-answer.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Answer.type">
        <xs:group ref="Answer.content"/>
        <xs:attributeGroup ref="Answer.attlist"/>
    </xs:complexType>
    <xs:element name="Answer" type="Answer.type"/>
    <!--
		*** formula ***
		The formula role of a performative (<Answer>).
		
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <xs:group name="formula-answer.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Entails"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-answer.type">
        <xs:group ref="formula-answer.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <!--
		*** formula ***
		The formula role of a performative (<Assert>, <Retract>, <Update>,... or <Query>).

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <xs:group name="formula-assert.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Implies"/>
            <xs:element ref="Rule"/>
            <xs:element ref="Equivalent"/>
            <xs:element ref="Entails"/>
            <xs:group ref="rulebase-quantifier.content"/>
            <xs:group ref="rulebase-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula-query.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Entails"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-assert.type">
        <xs:group ref="formula-assert.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:complexType name="formula-query.type">
        <xs:group ref="formula-query.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for description-related
            RuleML       elements. File: desc_module.xsd Version: 1.02 Last Modification: 2015-05-17
            [Adrian Paschke]       This module declares the following RuleML elements:
            * meta            descriptive metadata        * scope           scope  (e.g. for scoped
            reasoning)        * guard         guard (e.g. for guard constraints in scoped reasoning)
            * evaluation      semantic profile        * signature       interface signature, pattern
            definition,       * qualification   qualification, e.g. priorities, validity, strategy
            * quantification  quantification       * oid              See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-05-17T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
  *** oid ***
  An optional object identifier for an atomic formula, expression or the unifed terms
  of the SWSL branch, as needed for PSOA semantics.
  Note that oids are not required to be unique within a rulebase.
  
  See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-oid
  -->
    <xs:attributeGroup name="oid.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="oid.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element ref="Skolem"/>
            <xs:element ref="Reify"/>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="oid.type">
        <xs:group ref="oid.content"/>
        <xs:attributeGroup ref="oid.attlist"/>
    </xs:complexType>
    <xs:element name="oid" type="oid.type"/>
    <!-- 
     *** meta ***     
     
    An optional container for meta-knowledge about a Node.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-meta
-->
    <xs:attributeGroup name="meta.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="meta.content">
        <xs:choice>
            <xs:group ref="formula-assert.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="meta.type">
        <xs:group ref="meta.content"/>
        <xs:attributeGroup ref="meta.attlist"/>
    </xs:complexType>
    <xs:element name="meta" type="meta.type"/>
    <!--
     *** scope ***
     
     metadata-based scope definition defined over the metadata annotations and the qualifications annotations.
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-scope
     
     Note: scope reasoning can use the metadata scopes to define a constructive view on the knowledge in the KB.    
     
-->
    <xs:attributeGroup name="scope.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="scope.content">
        <xs:choice>
            <xs:group minOccurs="0" ref="formula-query.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="scope.type">
        <xs:group ref="scope.content"/>
        <xs:attributeGroup ref="scope.attlist"/>
    </xs:complexType>
    <xs:element name="scope" type="scope.type"/>
    <!--
     *** guard ***     
     
	guard constraints 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-guard
 -->
    <xs:attributeGroup name="guard.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="guard.content">
        <xs:choice>
            <xs:group ref="if.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="guard.type">
        <xs:group ref="guard.content"/>
        <xs:attributeGroup ref="guard.attlist"/>
    </xs:complexType>
    <xs:element name="guard" type="guard.type"/>
    <!--
     *** evaluation ***
     
     The intended evaluation semantics, e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-evaluation

  -->
    <xs:attributeGroup name="evaluation.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="evaluation.content">
        <xs:sequence>
            <xs:element ref="Profile"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="evaluation.type">
        <xs:group ref="evaluation.content"/>
        <xs:attributeGroup ref="evaluation.attlist"/>
    </xs:complexType>
    <xs:element name="evaluation" type="evaluation.type"/>
    <!--
     *** signature ***
     
     The signature defines the signature of knowledge (formula and terms) with optional input / output mode declarations. The signature declaration can act as public interface and
	can be published together with the intended evaluation semantics. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-signature
  -->
    <xs:attributeGroup name="signature.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="signature.content">
        <xs:choice>
            <xs:group ref="formula-query.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="signature.type">
        <xs:group ref="signature.content"/>
        <xs:attributeGroup ref="signature.attlist"/>
    </xs:complexType>
    <xs:element name="signature" type="signature.type"/>
    <!--
     *** qualification ***
     
    Definition of the qualification (qualifying metadata), e.g. validity time, priorities, etc.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-qualification
-->
    <xs:attributeGroup name="qualification.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="qualification.content">
        <xs:choice>
            <xs:group ref="formula-assert.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="qualification.type">
        <xs:group ref="qualification.content"/>
        <xs:attributeGroup ref="qualification.attlist"/>
    </xs:complexType>
    <xs:element name="qualification" type="qualification.type"/>
    <!--
     *** quantification ***
     
     Definition of the quantifier. 
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-quantification
        
-->
    <xs:attributeGroup name="quantification.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="quantification.content">
        <xs:choice>
            <xs:group ref="meta-quantifier.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="quantification.type">
        <xs:group ref="quantification.content"/>
        <xs:attributeGroup ref="quantification.attlist"/>
    </xs:complexType>
    <xs:element name="quantification" type="quantification.type"/>
    <!-- extended descriptors in Reaction RuleML -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML quantifiers. File:
            quantifier_module.xsd Version: 1.02 Last Modification: 2015-07-16 This module declares
            the       following RuleML elements: * Forall * Exists * declare * formula See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Forall ***
		Explicit universal quantifier.
		
		See http://www.ruleml.org/1.02/glossary/#gloss-Forall 
  -->
    <xs:attributeGroup name="Forall.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Forall.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-forall.type"/>
                <xs:group ref="formula-forall.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Forall.type">
        <xs:group ref="Forall.content"/>
        <xs:attributeGroup ref="Forall.attlist"/>
    </xs:complexType>
    <xs:element name="Forall" type="Forall.type"/>
    <!--
		*** Exists ***
		Explicit existential quantifier.

		See http://www.ruleml.org/1.02/glossary/#gloss-Exists
  -->
    <xs:attributeGroup name="Exists.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Exists.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-exists.type"/>
                <xs:group ref="formula-exists.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists.type">
        <xs:group ref="Exists.content"/>
        <xs:attributeGroup ref="Exists.attlist"/>
    </xs:complexType>
    <xs:element name="Exists" type="Exists.type"/>
    <!--
		*** declare ***
		A role used for variables declared within a quantifier.
		
		See http://www.ruleml.org/1.02/glossary/#gloss-declare
	-->
    <xs:attributeGroup name="declare.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="declare.content">
        <xs:sequence>
            <xs:element ref="Var"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="declare.type">
        <xs:group ref="declare.content"/>
        <xs:attributeGroup ref="declare.attlist"/>
    </xs:complexType>
    <xs:element name="declare" type="declare.type"/>
    <!--
		*** formula ***
		The formula role of a quantifier (<Forall> or <Exists>).
		
		See http://www.ruleml.org/1.02/glossary/#gloss-formula
	-->
    <xs:group name="formula-forall.content">
        <xs:choice>
            <xs:element ref="Implies"/>
            <xs:element ref="Rule"/>
            <xs:element ref="Equivalent"/>
            <xs:group ref="head-quantifier.content"/>
            <xs:group ref="head-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-forall.type">
        <xs:group ref="formula-forall.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:group name="formula-exists.content">
        <xs:choice>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-exists.type">
        <xs:group ref="formula-exists.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML connectives. File:
            connective_module.xsd Version: 1.02 Last Modification: 2015-02-21 [Tara Athan] This
            module       declares the following RuleML elements and attributes: * Implies * if *
            then * Entails *       Equivalent * torso * Rulebase * And * Or * formula        See
            http://www.ruleml.org/modularization for details       about this modularization
            approach. </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!-- necessary for schematron -->
    <!-- 
	<xs:appinfo>
		
		<ns prefix="r" uri="http://ruleml.org/spec"/>
	</xs:appinfo> 
	-->
    <!--
		*** Implies ***
		An implication rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Implies
  -->
    <xs:attributeGroup name="Implies.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Implies.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element ref="then"/>
                    <xs:element ref="if"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="if"/>
                    <xs:element ref="then"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:group ref="if.content"/>
                    <xs:group ref="then.content"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Implies.type">
        <xs:group ref="Implies.content"/>
        <xs:attributeGroup ref="Implies.attlist"/>
    </xs:complexType>
    <xs:element name="Implies" type="Implies.type"/>
    <!-- 
		*** if ***
		The if of an implication rule containing the premise(s),
		also known as the "antecedent" or "if" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-if
	-->
    <xs:attributeGroup name="if.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="if.content">
        <xs:choice>
            <xs:group ref="body-quantifier.content"/>
            <xs:group ref="body-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="if-entails.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:group ref="formula-rulebase.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="if.type">
        <xs:group ref="if.content"/>
        <xs:attributeGroup ref="if.attlist"/>
    </xs:complexType>
    <xs:complexType name="if-entails.type">
        <xs:group ref="if-entails.content"/>
        <xs:attributeGroup ref="if.attlist"/>
    </xs:complexType>
    <xs:element name="if" type="if.type"/>
    <!--
		*** then ***
		The then of an implication rule containing the conclusion,
		also known as the "consequent" or "then" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-then
	-->
    <xs:attributeGroup name="then.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="then.content">
        <xs:choice>
            <xs:group ref="head-quantifier.content"/>
            <xs:group ref="head-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="then-entails.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:group ref="formula-rulebase.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="then.type">
        <xs:group ref="then.content"/>
        <xs:attributeGroup ref="then.attlist"/>
    </xs:complexType>
    <xs:complexType name="then-entails.type">
        <xs:group ref="then-entails.content"/>
        <xs:attributeGroup ref="then.attlist"/>
    </xs:complexType>
    <xs:element name="then" type="then.type"/>
    <!--
		*** Entails ***
		Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
		Kowalski/Bowen's object/meta-level-amalgamated logic).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Entails
	-->
    <xs:attributeGroup name="Entails.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Entails.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="if" type="if-entails.type"/>
                    <xs:group ref="if-entails.content"/>
                </xs:choice>
                <xs:choice>
                    <xs:element form="qualified" name="then" type="then-entails.type"/>
                    <xs:group ref="then-entails.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Entails.type">
        <xs:group ref="Entails.content"/>
        <xs:attributeGroup ref="Entails.attlist"/>
    </xs:complexType>
    <xs:element name="Entails" type="Entails.type"/>
    <!--
		*** Equivalent ***
		An equivalence expression, which is "syntactic sugar" for a pair
		of conjoined converse implication rules.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equivalent		
  -->
    <xs:attributeGroup name="Equivalent.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Equivalent.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element ref="torso"/>
                    <xs:group ref="torso.content"/>
                </xs:choice>
                <xs:choice>
                    <xs:element ref="torso"/>
                    <xs:group ref="torso.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Equivalent.type">
        <xs:group ref="Equivalent.content"/>
        <xs:attributeGroup ref="Equivalent.attlist"/>
    </xs:complexType>
    <xs:element name="Equivalent" type="Equivalent.type"/>
    <!--
		*** torso ***
		A symmetric role used in an equivalence expression combining
		the asymmetric <then> and <if>.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-torso
	-->
    <xs:attributeGroup name="torso.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="torso.content">
        <xs:choice>
            <xs:group ref="head-quantifier.content"/>
            <xs:group ref="head-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="torso.type">
        <xs:group ref="torso.content"/>
        <xs:attributeGroup ref="torso.attlist"/>
    </xs:complexType>
    <xs:element name="torso" type="torso.type"/>
    <!--
		*** Rulebase ***
		A collection of rules that can be ordered or unordered, without or with duplicates.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rulebase
		
		@prefix for default prefix definitions 
		@vocab for default vocab definitions
  -->
    <xs:attributeGroup name="Rulebase.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rulebase.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-rulebase.type"/>
                <xs:group ref="formula-rulebase.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Rulebase.type">
        <xs:group ref="Rulebase.content"/>
        <xs:attributeGroup ref="Rulebase.attlist"/>
    </xs:complexType>
    <xs:element name="Rulebase" type="Rulebase.type"/>
    <!--
		*** And ***
		A conjunctive expression, where <And>Atom</And> is equivalent to Atom.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-And
	-->
    <xs:attributeGroup name="And-body.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="And-query.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="And.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-and-or.type"/>
                <xs:group ref="formula-and-or.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="And-query.type">
        <xs:group ref="And.content"/>
        <xs:attributeGroup ref="And-query.attlist"/>
    </xs:complexType>
    <xs:complexType name="And-body.type">
        <xs:group ref="And.content"/>
        <xs:attributeGroup ref="And-body.attlist"/>
    </xs:complexType>
    <xs:element name="And" type="And-body.type"/>
    <!--
		*** Or ***
		A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Or
	-->
    <xs:attributeGroup name="Or-query.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="Or-body.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Or.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-and-or.type"/>
                <xs:group ref="formula-and-or.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Or-query.type">
        <xs:group ref="Or.content"/>
        <xs:attributeGroup ref="Or-query.attlist"/>
    </xs:complexType>
    <xs:complexType name="Or-body.type">
        <xs:group ref="Or.content"/>
        <xs:attributeGroup ref="Or-body.attlist"/>
    </xs:complexType>
    <xs:element name="Or" type="Or-body.type"/>
    <!--
		*** formula ***
		The formula role of a conjunctive/disjunctive expression or a rulebase.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <xs:attributeGroup name="formula.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula-and-or.content">
        <xs:choice>
            <xs:group ref="body-quantifier.content"/>
            <xs:group ref="body-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula-rulebase.content">
        <xs:choice>
            <xs:element form="qualified" name="Implies" type="Implies.type"/>
            <xs:element ref="Rule"/>
            <xs:element form="qualified" name="Equivalent" type="Equivalent.type"/>
            <xs:group ref="rulebase-quantifier.content"/>
            <xs:group ref="rulebase-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-and-or.type">
        <xs:group ref="formula-and-or.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:complexType name="formula-rulebase.type">
        <xs:group ref="formula-rulebase.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               generic operation module of Reaction RuleML.
            This is the XML Schema connective operator module for Reaction RuleML.    File:
            connective_operator_module.xsd    Version: 1.02    Last Modification: 2015-03-22
            This schema declares the following Reaction RuleML elements and attributes:      *
            Operation         The approach is modelled after that used in "Modularization of XHTML
            in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** generic Operation ***
      
      	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Operation
	-->
    <xs:attributeGroup name="Operation-formula.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Operation-formula-rulebase.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-rulebase.type"/>
                <xs:group ref="formula-rulebase.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Operation-formula-rulebase.type">
        <xs:group ref="Operation-formula-rulebase.content"/>
        <xs:attributeGroup ref="Operation-formula.attlist"/>
    </xs:complexType>
    <xs:element name="Operation" type="Operation-formula-rulebase.type"/>
    <xs:group name="Operation-formula-and-or.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-and-or.type"/>
                <xs:group ref="formula-and-or.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Operation-formula-and-or.type">
        <xs:group ref="Operation-formula-and-or.content"/>
        <xs:attributeGroup ref="Operation-formula.attlist"/>
    </xs:complexType>
    <xs:group name="Operation-formula-query.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-query.type"/>
                <xs:group ref="formula-query.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Operation-formula-query.type">
        <xs:group ref="Operation-formula-query.content"/>
        <xs:attributeGroup ref="Operation-formula.attlist"/>
    </xs:complexType>
    <xs:attributeGroup name="Operation-term.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Operation-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="arg"/>
                <xs:group ref="arg.content"/>
                <xs:element form="qualified" name="content" type="operation_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Operation-term.type">
        <xs:group ref="Operation-term.content"/>
        <xs:attributeGroup ref="Operation-term.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
-->
    <xs:attributeGroup name="operation_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="operation_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="operation_anycontent.type">
        <xs:group ref="operation_anycontent.content"/>
        <xs:attributeGroup ref="operation_anycontent.attlist"/>
    </xs:complexType>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML atoms. File:
            atom_module.xsd Version: 1.02 Last Modification: 2015-02-21 This module declares
            the following RuleML elements and attributes: * Atom * op * Rel * degree See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>        )
            arguments.   Or a frame object with slots    See
            http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Atom
                <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
        *** Atom ***
		A logical atom , i.e. an expression formed from a predicate
		
	-->
    <xs:attributeGroup name="Atom.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <!--
		These .extend groups, pointed to by Atom.content, are necessary
		for redefinition to be binary in bindatalog and to add rest
		variables in hornlog.
	-->
    <xs:group name="Atom-repo.extend">
        <xs:choice>
            <xs:group ref="Atom-arg.extend"/>
            <xs:element ref="repo"/>
        </xs:choice>
    </xs:group>
    <xs:group name="Atom-arg.extend">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="arg"/>
                <xs:group ref="arg.content"/>
            </xs:choice>
            <xs:element minOccurs="0" ref="repo"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom-slots.extend1">
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom-slots.extend2">
        <xs:sequence>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <!-- operator optional for frame representation -->
                <xs:element form="qualified" name="op" type="op-atom.type"/>
                <xs:group ref="op-atom.content"/>
            </xs:choice>
            <xs:group ref="Atom-slots.extend1"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:group ref="Atom-repo.extend"/>
                    <xs:group ref="Atom-slots.extend1"/>
                </xs:sequence>
            </xs:choice>
            <xs:group ref="Atom-slots.extend2"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Atom.type">
        <xs:group ref="Atom.content"/>
        <xs:attributeGroup ref="Atom.attlist"/>
    </xs:complexType>
    <xs:element name="Atom" type="Atom.type"/>
    <!--
		*** op ***
		An operator expression including the relation of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-op
	-->
    <xs:attributeGroup name="op.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="op-atom.content">
        <xs:sequence>
            <xs:element ref="Rel"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="op-atom.type">
        <xs:group ref="op-atom.content"/>
        <xs:attributeGroup ref="op.attlist"/>
    </xs:complexType>
    <xs:element name="op" type="op-atom.type"/>
    <!--
		*** Rel ***
		A relation, i.e. a logical predicate, of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rel		
	-->
    <xs:attributeGroup name="Rel.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rel.content">
        <xs:sequence> </xs:sequence>
    </xs:group>
    <xs:complexType mixed="true" name="Rel.type">
        <xs:group ref="Rel.content"/>
        <xs:attributeGroup ref="Rel.attlist"/>
    </xs:complexType>
    <xs:element name="Rel" type="Rel.type"/>
    <!-- 
		*** degree ***

		An optional uncertainty value (between 0.0 and 1.0)
		that may be assigned to facts and rules.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-degree

	-->
    <xs:attributeGroup name="degree.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="degree.content">
        <xs:sequence>
            <xs:element ref="Data"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="degree.type">
        <xs:group ref="degree.content"/>
        <xs:attributeGroup ref="degree.attlist"/>
    </xs:complexType>
    <xs:element name="degree" type="degree.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML slots. File:
            slot_module.xsd Version: 1.02 Last Modification: 2015-07-16 This module declares the
            following       RuleML element and attributes: * slot        See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-16T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** slot ***
		A user-defined slot consisting of a name (first position) and a filler (second position).
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-slot
	-->
    <xs:attributeGroup name="slot.attlist">
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="slot-name.extend">
        <xs:choice>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="slot.content">
        <xs:sequence>
            <xs:group ref="slot-name.extend"/>
            <xs:group ref="arg.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="slot.type">
        <xs:group ref="slot.content"/>
        <xs:attributeGroup ref="slot.attlist"/>
    </xs:complexType>
    <xs:element name="slot" type="slot.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML terms. File:
            term_module.xsd Version: 1.02 Last Modification: 2015-04-03 This module declares the
            following       RuleML elements and attributes: * arg * Ind * Data * Var * Skolem *
            Reify as       well as including a number of complex types for use in expicitly-typed
            data Nodes. See       http://www.ruleml.org/modularization for details about this
            modularization approach.     </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-04-03T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** arg ***
		A role used for the positional arguments of a logical atom.
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg 
	-->
    <xs:attributeGroup name="arg.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element ref="Skolem"/>
            <xs:element ref="Reify"/>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg.type">
        <xs:group ref="arg.content"/>
        <xs:attributeGroup ref="arg.attlist"/>
    </xs:complexType>
    <xs:element name="arg" type="arg.type"/>
    <!--
		*** Ind ***
		An individual constant, as in predicate logic, which can also be considered to
		be a fixed argument like RDF resources.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Ind
	-->
    <xs:attributeGroup name="Ind.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Ind.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Ind.type">
        <xs:group ref="Ind.content"/>
        <xs:attributeGroup ref="Ind.attlist"/>
    </xs:complexType>
    <xs:element name="Ind" type="Ind.type"/>
    <!--
		*** Data ***
		A fixed argument like RDF literals, allowing XML data.  It may be
		optionally associated with an XML Schema built-in datatype
		(see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
		using the built-in xsi:type attribute.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Data
  -->
    <xs:element name="Data" type="xs:anyType"/>
    <!--
		*** Var ***
		A logical variable, as in logic programming.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Var
	-->
    <xs:attributeGroup name="Var.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Var.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Var.type">
        <xs:group ref="Var.content"/>
        <xs:attributeGroup ref="Var.attlist"/>
    </xs:complexType>
    <xs:element name="Var" type="Var.type"/>
    <!--
		*** Skolem ***
		A Skolem individual constant, like RDF's blank nodes.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Skolem
	-->
    <xs:attributeGroup name="Skolem.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Skolem.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Skolem.type">
        <xs:group ref="Skolem.content"/>
        <xs:attributeGroup ref="Skolem.attlist"/>
    </xs:complexType>
    <xs:element name="Skolem" type="Skolem.type"/>
    <!--
		*** Reify ***
		Supports reification (a kind of instantiation or quasi-quotation). It allows any RuleML tag available within the
		current sublanguage as content, treating it as a term for performing reasoning on.
				
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Reify		
	-->
    <xs:attributeGroup name="Reify.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Reify.content">
        <xs:sequence>
            <!--
		  <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/> -->
            <!-- <Reify> only allows valid RuleML -->
            <!--<xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>-->
            <xs:any minOccurs="0" namespace="##targetNamespace" processContents="strict"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Reify.type">
        <xs:group ref="Reify.content"/>
        <xs:attributeGroup ref="Reify.attlist"/>
    </xs:complexType>
    <xs:element name="Reify" type="Reify.type"/>
    <!-- includes the hornlog layer with the 'expr' and 'rest' modules -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML expressions. File:
            expr_module.xsd Version: 1.02 Last Modification: 2015-10-05 [Tara Athan] This module
            declares       the following RuleML elements and attributes: * Expr * op * Fun * Plex *
            @per See       http://www.ruleml.org/modularization for details about this
            modularization approach. </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-10-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
        <!-- necessary for schematron -->
        <!-- 
		<xs:appinfo>

		<sch:ns prefix="r" iri="http://www.deliberation.ruleml.org/1.02/xsd"/>
		-->
    </xs:annotation>
    <!--
		*** Expr ***
		A logical function of the form "f(...)" where f is a function name.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Expr
	-->
    <xs:attributeGroup name="Expr.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Expr.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="op" type="op-Expr.type"/>
                <xs:group ref="op-Expr.content"/>
            </xs:choice>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:choice>
                        <xs:sequence>
                            <xs:choice maxOccurs="unbounded">
                                <xs:element ref="arg"/>
                                <xs:group ref="arg.content"/>
                            </xs:choice>
                            <xs:element minOccurs="0" ref="repo"/>
                        </xs:sequence>
                        <xs:element ref="repo"/>
                    </xs:choice>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                </xs:sequence>
            </xs:choice>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Expr.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Uninterpreted functions">
					<sch:rule context="r:Expr/r:Fun[@per='no']">
						<sch:assert test=
								"not(../r:Expr/r:Fun[@per='yes'] or
									 ../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
					<sch:rule context="r:Expr/r:op/r:Fun[@per='no']">
						<sch:assert test=
								"not(../../r:Expr/r:Fun[@per='yes'] or
									 ../../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <xs:group ref="Expr.content"/>
        <xs:attributeGroup ref="Expr.attlist"/>
    </xs:complexType>
    <xs:element name="Expr" type="Expr.type"/>
    <!--
		*** op ***
		An operator expression including the function name of an expression.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-op
				
	-->
    <!-- the (empty) attribute list is declared in the atom module -->
    <xs:group name="op-Expr.content">
        <xs:sequence>
            <xs:element ref="Fun"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="op-Expr.type">
        <xs:group ref="op-Expr.content"/>
        <xs:attributeGroup ref="op.attlist"/>
    </xs:complexType>
    <!--
		*** Fun ***
		A user-defined function name.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Fun
	-->
    <xs:attributeGroup name="Fun.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Fun.content">
        <xs:sequence> </xs:sequence>
    </xs:group>
    <xs:complexType mixed="true" name="Fun.type">
        <xs:group ref="Fun.content"/>
        <xs:attributeGroup ref="Fun.attlist"/>
    </xs:complexType>
    <xs:element name="Fun" type="Fun.type"/>
    <!--
		*** Plex ***
		An unordered collection of arguments without a constructor.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Plex
	-->
    <xs:attributeGroup name="Plex.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Plex.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:choice minOccurs="0">
                <xs:sequence minOccurs="0">
                    <xs:choice maxOccurs="unbounded">
                        <xs:element ref="arg"/>
                        <xs:group ref="arg.content"/>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="repo"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="repo"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="resl"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="Plex-repo.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="arg"/>
                <xs:group ref="arg.content"/>
            </xs:choice>
            <xs:element minOccurs="0" ref="repo"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Plex-resl.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Plex.type">
        <xs:group ref="Plex.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:complexType name="Plex-repo.type">
        <xs:group ref="Plex-repo.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:complexType name="Plex-resl.type">
        <xs:group ref="Plex-resl.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:element name="Plex" type="Plex.type"/>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML rest variables.
            File:       rest_module.xsd Version: 1.02 Last Modification: 2015-07-05 This module
            declares the following       RuleML elements: * repo * resl See
            http://www.ruleml.org/modularization for details about this       modularization
            approach. </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** repo ***
		A positional rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-repo
	-->
    <xs:attributeGroup name="repo.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="repo.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element form="qualified" name="Plex" type="Plex-repo.type"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="repo.type">
        <xs:group ref="repo.content"/>
        <xs:attributeGroup ref="repo.attlist"/>
    </xs:complexType>
    <xs:element name="repo" type="repo.type"/>
    <!--
		*** resl ***
		A slotted rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-resl		
	-->
    <xs:attributeGroup name="resl.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="resl.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element form="qualified" name="Plex" type="Plex-resl.type"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="resl.type">
        <xs:group ref="resl.content"/>
        <xs:attributeGroup ref="resl.attlist"/>
    </xs:complexType>
    <xs:element name="resl" type="resl.type"/>
    <!-- includes the equalog layer with the 'equality' module -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for equality in RuleML. File:
            equality_module.xsd Version: 1.02 Last Modification: 2015-02-21 [Tara Athan] This module
            declares the following RuleML elements and attributes: * Equal * left * right        See
            http://www.ruleml.org/modularization for details about this modularization approach. </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Equal ***
		An equational formula consisting of two expressions.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equal

	-->
    <xs:attributeGroup name="Equal.attlist">
        <xs:attributeGroup ref="oriented.attrib"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Equal.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element ref="left"/>
                    <xs:element ref="right"/>
                </xs:sequence>
                <!-- note that (right, left) is disallowed -->
                <xs:sequence>
                    <xs:group ref="left.content"/>
                    <xs:group ref="right.content"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Equal.type">
        <xs:group ref="Equal.content"/>
        <xs:attributeGroup ref="Equal.attlist"/>
    </xs:complexType>
    <xs:element name="Equal" type="Equal.type"/>
    <!--
		*** left ***
		The left-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-left
	
	-->
    <xs:attributeGroup name="left.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="left.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="left.type">
        <xs:group ref="left.content"/>
        <xs:attributeGroup ref="left.attlist"/>
    </xs:complexType>
    <xs:element name="left" type="left.type"/>
    <!--
		*** right***
		The right-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-right
	-->
    <xs:attributeGroup name="right.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="right.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="right.type">
        <xs:group ref="right.content"/>
        <xs:attributeGroup ref="right.attlist"/>
    </xs:complexType>
    <xs:element name="right" type="right.type"/>

    <xs:simpleType name="curieOrIRI.datatype">
        <xs:union memberTypes="curie.datatype xs:anyURI"/>
    </xs:simpleType>
    <xs:simpleType name="curieOrAbsIRI.datatype">
        <xs:union memberTypes="curie.datatype absIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrIRI.datatype">
        <xs:union memberTypes="term.datatype curie.datatype xs:anyURI"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrIRIs.datatype">
        <xs:list itemType="termOrCurieOrIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrAbsIRI.datatype">
        <xs:union memberTypes="term.datatype curie.datatype absIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrAbsIRIs.datatype">
        <xs:list itemType="termOrCurieOrAbsIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="absIRI.datatype">
        <xs:restriction base="xs:anyURI">
            <xs:pattern value="[\i-[:]][\c-[:]]+:.+"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="curie.datatype">
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="term.datatype">
        <xs:restriction base="xs:Name">
            <xs:pattern value="[\i-[:]][/\c-[:]]*"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
           *** @mode ***
           An attribute for optionally specifying the intended input-output constellations of formulas and terms with the
           following semantics:
        
           "+" The formula/term is intended to be input
           "-" The formula/term is intended to be output
           "?" The formula/term is undefined (input or output)
           "[iri]" the formula/term's mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)  
		   
			By default the mode of formulas when used as conditions, constraints, queries and event patterns is "+" (input)
			and the mode of conclusions, answers and active actions is "-" (output). Variables are "?" (open) by default.
			optional attribute
			
			See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40mode
-->
    <xs:attributeGroup name="mode.attrib">
        <xs:attribute default="?" name="mode" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-modes.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-modes.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="+"/>
            <xs:enumeration value="-"/>
            <xs:enumeration value="?"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
	  *** @safety ***

	     restriction: interrupting, non-interrupting or transactional or
	     "[iri]" the formula/term's safety mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)
	     
		 default: non-interrupting 
		 optional attribute
		 
		 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40safety
	-->
    <xs:attributeGroup name="safety.attrib">
        <xs:attribute default="non-interrupting" name="safety" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-safety.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-safety.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="non-interrupting"/>
            <xs:enumeration value="interrupting"/>
            <xs:enumeration value="transactional"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @per ***
		An optinal attribute indicating how a formulas, terms and operators are interpreted.
		
		Default for formulas is per "value" (truth valuation), for terms per "copy", for modal operators per "modal" and for actions/performatives by "effect".		
		In "reasoning" dialects the default for actions and events is per "value" and in active / messaging dialects it is per "effect".
		In "non-reified" representations as formulas default interpretation per "value" and in "reified" representations as term default interpretation is per copy. 
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40per
	-->
    <xs:attributeGroup name="per.attrib">
        <xs:attribute name="per" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-per.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-per.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="copy"/>
            <xs:enumeration value="value"/>
            <xs:enumeration value="effect"/>
            <xs:enumeration value="modal"/>
            <xs:enumeration value="open"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @size  ***
		An attribute indicating the size of a counter		
		-1 = unbound / all
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40size
	-->
    <!-- 
		
		replaced by card 
		
		<xs:attributeGroup name="size.attrib">
		<xs:attribute name="size" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="mapSize.attrib">
		<xs:attribute name="mapSize" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>-->
    <!--
    *** @style ***
    
    The style attribute defines the styles of the intended semantics. 
    Predefined semantics are "active", "reasoning", "messaging". 
    Further intented semantics can be defined by semantic profiles internally in the <evaluation> role
    or externally. They can be referenced by ther profile name (term) or resource locator (curie or absolute IRI).
    
   restriction: active | messaging | reasoning | "[IRIs]" (vocabulary terms or curies or absolute IRIs)

	 default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40style
	-->
    <xs:simpleType name="style.datatype">
        <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-style.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="vocab-style.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="active"/>
            <xs:enumeration value="messaging"/>
            <xs:enumeration value="reasoning"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
    *** @key ***
    
    optinal unique local key on all knowledge formulas
    
	 optinal attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40key
	-->
    <xs:attributeGroup name="key.attrib">
        <xs:attribute name="key" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @keyref ***
    
    corresponding reference to a unique local key
    
	 optinal attribute
	 
	 http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40keyref
	-->
    <xs:attributeGroup name="keyref.attrib">
        <xs:attribute name="keyref" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @node ***
    An optional identification label for a Node, creating accessibility within
    the knowledge representation.
    This can help for representing prioritization between rules, for example. 
    The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
    such a label.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40node
    
    content model: (curieOrAbsIRI.datatype)
  -->
    <xs:attributeGroup name="node.attrib">
        <xs:attribute name="node" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @type ***
		An attribute for optionally specifying a (user-defined) type.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40type
		
		Note: In Reaction RuleML the type is changed to Term or Curie or absolute IRI to allow references
		to internal vocabulary terms (e.g. local sort signature definitions) and external vocabulary types (sorts) 
	-->
    <xs:attributeGroup name="type.attrib">
        <xs:attribute name="type" type="termOrCurieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @meta ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines descriptive meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <meta> role)
     or external metadata vocabularies.
     
	 By default knowledge is contextually annotated by metadata about the source (@src([Locator])) and the name (@label([OID])),
	 with "Locator" being the source location (location of Reaction RuleML knowledge base in which the knowledge is defined) 
	 and OID being the implicitly or explicitly defined object identifer of the knowledge.
	 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40meta
	-->
    <xs:attributeGroup name="meta.attrib">
        <xs:attribute name="meta" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
    *** @qualify ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines qualifying meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <qualification> role)
     or external metadata vocabularies.
      
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40qualify
	-->
    <xs:attributeGroup name="qualify.attrib">
        <xs:attribute name="qualify" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
    *** @scope ***
    
     restriction: global | local | private | "[iris]" (terms or curies or absolute IRIs)
     
     Defines a scope. Predefined scopes are global, local, private. 
     Internal dynamic scopes defined by metadata views (defined in the <scope> role) can be references by the oid name term (<oid>)
     and externally defined scopes by their IRI.
     
	 default value: "global" for relations and functions and "local" for terms 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40scope
	-->
    <xs:attributeGroup name="scope-formula.attrib">
        <xs:attribute default="global" name="scope" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-scope.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="scope-term.attrib">
        <xs:attribute default="local" name="scope" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-scope.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-scope.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="local"/>
            <xs:enumeration value="global"/>
            <xs:enumeration value="private"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @arity ***
		An optional attribute for specifying the arity of a signature.
		The arity of constants / individual objects is zero.
		The arity of predicates and functions is the number of arguments they have.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40arity
	-->
    <xs:attributeGroup name="arity.attrib">
        <xs:attribute name="arity" type="xs:nonNegativeInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @prefix ***
		
		a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40prefix
		
	-->
    <xs:attributeGroup name="prefix.attrib">
        <xs:attribute name="prefix" type="prefix.datatype" use="optional"/>
    </xs:attributeGroup>
    <xs:simpleType name="prefix.datatype">
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="([\i-[:]][\c-[:]]*)?"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @vocab ***
		
		an IRI that defines the vocabulary mapping to use when a TERM is referenced in an attribute value.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40vocab
				
	-->
    <xs:attributeGroup name="vocab.attrib">
        <xs:attribute name="vocab" type="xs:anyURI" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @card @minCard @maxCard ***
		An attribute optionally specifying the cardinality.
		
		"-1" = unbound
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40card
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40maxCard
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40minCard
	-->
    <xs:attributeGroup name="card.attrib">
        <xs:attribute name="card" type="xs:int" use="optional"/>
        <xs:attribute name="maxCard" type="xs:int" use="optional"/>
        <xs:attribute name="minCard" type="xs:nonNegativeInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @weight ***
		An attribute optionally specifying a relative weight.
		The default is "1", i.e. all knowledge has the same weight of "1". 
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40weight		
	-->
    <xs:attributeGroup name="weight.attrib">
        <xs:attribute name="weight" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:decimal">
                    <xs:minInclusive value="0"/>
                    <xs:maxInclusive value="1"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
		*** @direction ***
		An attribute indicating the intended direction of an implication rule's inferencing.
		default is bidirectional.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40direction
	-->
    <xs:attributeGroup name="direction.attrib">
        <xs:attribute name="direction" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-direction.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-direction.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="forward"/>
            <xs:enumeration value="backward"/>
            <xs:enumeration value="bidirectional"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @closure ***
		An attribute indicating how the contained free variables are quantified.
		default is universal closure.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40closure		
	-->
    <xs:attributeGroup name="closure.attrib">
        <xs:attribute name="closure" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-closure.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-closure.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="universal"/>
            <xs:enumeration value="existential"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @material ***
		An attribute indicating the kind of an implication rule.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40material
	-->
    <xs:attributeGroup name="material.attrib">
        <xs:attribute name="material" type="material.datatype" use="optional"/>
    </xs:attributeGroup>
    <xs:simpleType name="material.datatype">
        <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-material.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="vocab-material.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="yes"/>
            <xs:enumeration value="no"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @iri ***
		An attribute for referring to a Curie or absolute IRI.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40iri
	-->
    <xs:attributeGroup name="iri.attrib">
        <xs:attribute name="iri" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @index ***
		An optional attribute for specifying an ordering on roles.
		
		Note: in Reaction RuleML @index is optional
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40index
	-->
    <xs:attributeGroup name="index.attrib">
        <xs:attribute name="index" type="xs:positiveInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @oriented ***
		An attribute indicating whether an equation is oriented (directed)
		or unoriented (symmetric).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-.40oriented
	-->
    <xs:attributeGroup name="oriented.attrib">
        <xs:attribute name="oriented" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:NMTOKEN">
                    <xs:enumeration value="yes"/>
                    <xs:enumeration value="no"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML elements in Reaction RuleML

	@prefix?, @key?, @keyref?, @xml:id?, @xml:base?
 
  	@key and @keyref attributes for local syntactic modularization of the knowledge base
  	   
  	-->
    <xs:attributeGroup name="xml.attlist">
        <xs:attributeGroup ref="prefix.attrib"/>
        <xs:attributeGroup ref="key.attrib"/>
        <xs:attributeGroup ref="keyref.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML node elements (type elements) in Reaction RuleML
  	
	@meta?, @qualify?, @node?, @iri?, @vocab?
   	   
  	-->
    <xs:attributeGroup name="node-element.attlist">
        <xs:attributeGroup ref="node.attrib"/>
        <xs:attributeGroup ref="iri.attrib"/>
        <xs:attributeGroup ref="vocab.attrib"/>
        <xs:attributeGroup ref="meta.attrib"/>
        <xs:attributeGroup ref="qualify.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML edge elements (role elements) in Reaction RuleML
  	
	@index?
   	   
  	-->
    <xs:attributeGroup name="edge-element.attlist">
        <xs:attributeGroup ref="index.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all grouping formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?  
	
	attributes of grouping formulas are automatically inherited as default attributes to all formulas in the group.
  	-->
    <xs:attributeGroup name="group-formula-interface.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all knowledge formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?

   	   
  	-->
    <xs:attributeGroup name="formula-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all terms in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?
   	   
  	-->
    <xs:attributeGroup name="term-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="scope-term.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all quantifiers in Reaction RuleML
  	
	@type?, @card?, @minCard?, @maxCard?, @style?, @scope?
  	-->
    <xs:attributeGroup name="quantifier-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all connectives/operators in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
  	-->
    <xs:attributeGroup name="operator-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all action / performatives in Reaction RuleML
  	
	@safety?
  	-->
    <xs:attributeGroup name="action-interface.attlist">
        <xs:attributeGroup ref="safety.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all events in Reaction RuleML
  	
	@safety?
  	-->
    <xs:attributeGroup name="event-interface.attlist">
        <xs:attributeGroup ref="safety.attrib"/>
    </xs:attributeGroup>
    <xs:annotation>
        <xs:documentation xml:lang="en">                      Rules module part of Reaction RuleML.
            It defines the core            Rule construct used as basis for all types of rules in
            Reaction RuleML                      This is the XML Schema rule module for Reaction
            RuleML.           File: rule_module.xsd           Version: 1.02           Last
            Modification: 2015-03-29                      This schema declares the following
            Reaction RuleML elements and attributes:                      * Rule           * on
            * if           * then           * do           * after                     * else
            * elseDo           * elseAfter                          </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** Rule ***
      The Rule element that provides the basic syntax for rules
      in Reaction RuleML.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Rule
-->
    <xs:attributeGroup name="Rule.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rule.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:group minOccurs="0" ref="rule-implementation.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Rule.type">
        <xs:group ref="Rule.content"/>
        <xs:attributeGroup ref="Rule.attlist"/>
    </xs:complexType>
    <xs:element name="Rule" type="Rule.type"/>
    <!--
     *** on ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-on
-->
    <xs:attributeGroup name="on.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
        <xs:attributeGroup ref="edge-element.attlist"/>
    </xs:attributeGroup>
    <xs:group name="on.content">
        <xs:choice>
            <xs:group ref="event_group.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="on.type">
        <xs:group ref="on.content"/>
        <xs:attributeGroup ref="on.attlist"/>
    </xs:complexType>
    <xs:element name="on" type="on.type"/>
    <!--
     *** if ***
     *** after ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-if
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-after
	-->
    <xs:element name="after" type="if.type"/>
    <!--
	 *** then ***	
     *** else ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-then
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-else
	-->
    <xs:element name="else" type="then.type"/>
    <!--
     *** do ***
     *** elseDo ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-do
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-elseDo
	-->
    <xs:attributeGroup name="do.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
        <xs:attributeGroup ref="edge-element.attlist"/>
    </xs:attributeGroup>
    <xs:group name="do.content">
        <xs:choice>
            <xs:group ref="action_group.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="do.type">
        <xs:group ref="do.content"/>
        <xs:attributeGroup ref="do.attlist"/>
    </xs:complexType>
    <xs:element name="do" type="do.type"/>
    <xs:element name="elseDo" type="do.type"/>
    <!--
  *** Derivation Rule content model ***  	
	-->
    <xs:group name="DerivationRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="else"/>
                <xs:element ref="then"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element ref="then"/>
                <xs:element minOccurs="0" ref="else"/>
            </xs:sequence>
            <xs:sequence>
                <xs:group ref="if.content"/>
                <xs:group ref="then.content"/>
                <xs:group minOccurs="0" ref="then.content"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** Production Rule content model ***
	-->
    <xs:group name="ProductionRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="elseDo"/>
                <xs:element ref="do"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element ref="do"/>
                <xs:element minOccurs="0" ref="elseDo"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** Combined DR Production Rule content model ***
    -->
    <xs:group name="DRProductionRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="elseDo"/>
                <xs:element minOccurs="0" ref="else"/>
                <xs:element ref="do"/>
                <xs:element minOccurs="0" ref="then"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element minOccurs="0" ref="then"/>
                <xs:element minOccurs="0" ref="do"/>
                <xs:element minOccurs="0" ref="else"/>
                <xs:element minOccurs="0" ref="elseDo"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** ECA Reaction Rule content model ***
    -->
    <xs:group name="ReactionRule.content">
        <xs:sequence>
            <xs:element ref="on"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element minOccurs="0" ref="if"/>
                    <xs:element minOccurs="0" ref="then"/>
                    <xs:element minOccurs="0" ref="do"/>
                    <xs:element minOccurs="0" ref="after"/>
                    <xs:element minOccurs="0" ref="else"/>
                    <xs:element minOccurs="0" ref="elseDo"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <!--
   *** CEP Messaging Rule content model ***
   
   CEP rules allow arbitrary combinations and repititions of the rule's content model
   -->
    <xs:group name="MessagingRule.content">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="on"/>
                <xs:element ref="if"/>
                <xs:element ref="then"/>
                <xs:element ref="do"/>
                <xs:element ref="after"/>
                <xs:element ref="else"/>
                <xs:element ref="elseDo"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:annotation>
        <xs:documentation xml:lang="en">         Negation module part of Reaction RuleML.   This
            defines the negation elements for Reaction RuleML.   File: negation_module.xsd
            Version: 1.02   Last Modification: 2015-03-22      * Negation  generic polymorphig
            negation   * Naf           negation as failure (inflationary negation in production
            rules), weak negation   * Neg           classical negation, strong negation   * weak
            * strong   * formula        </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Negation ***
		A generic polymorphic negation
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Negation
		
		It can be specialized by using
		the @type attribute to specify the type of negation and/or 
 		the @iri attribute to point to an external definition of the negation
 		@key, @keyref, @node
		-->
    <xs:attributeGroup name="Negation.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Negation.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-negation.type"/>
                <xs:group ref="formula-negation.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Negation.type">
        <xs:group ref="Negation.content"/>
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:complexType>
    <xs:element name="Negation" type="Negation.type"/>
    <xs:attributeGroup name="formula-negation.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula-negation.content">
        <xs:choice>
            <xs:element form="qualified" name="Operation" type="Operation-formula-and-or.type"/>
            <xs:element ref="Equal"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Neg"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-negation.type">
        <xs:group ref="formula-negation.content"/>
        <xs:attributeGroup ref="formula-negation.attlist"/>
    </xs:complexType>
    <xs:element name="formula" type="formula-negation.type"/>
    <!--
		*** Naf ***
		A "by default" negation of a logical atom (i.e. "weak" negation or
		negation-as-failure).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Naf 
	-->
    <xs:attributeGroup name="Naf.attlist">
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Naf.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:element ref="weak"/>
                <xs:group ref="weak.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Naf.type">
        <xs:group ref="Naf.content"/>
        <xs:attributeGroup ref="Naf.attlist"/>
    </xs:complexType>
    <xs:element name="Naf" type="Naf.type"/>
    <!--
		*** weak ***
		A role used for negation as failure.
	
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-weak
	-->
    <xs:attributeGroup name="weak.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="weak.content">
        <xs:choice>
            <xs:group ref="formula-negation.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="weak.type">
        <xs:group ref="weak.content"/>
        <xs:attributeGroup ref="weak.attlist"/>
    </xs:complexType>
    <xs:element name="weak" type="weak.type"/>
    <!--
		*** Neg ***
		A classical negation of a logical atom (i.e. classical or "strong" negation).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Neg 
	-->
    <xs:attributeGroup name="Neg.attlist">
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Neg.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:element ref="strong"/>
                <xs:group ref="strong.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Neg.type">
        <xs:group ref="Neg.content"/>
        <xs:attributeGroup ref="Neg.attlist"/>
    </xs:complexType>
    <xs:element name="Neg" type="Neg.type"/>
    <!--
		*** strong ***
		A role used for classical negation.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-strong
	-->
    <xs:attributeGroup name="strong.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="strong.content">
        <xs:choice>
            <xs:group ref="formula-negation.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="strong.type">
        <xs:group ref="strong.content"/>
        <xs:attributeGroup ref="strong.attlist"/>
    </xs:complexType>
    <xs:element name="strong" type="strong.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en">                                 Quantifier module part of
            Reaction RuleML redefining the Forall, Exists and introduce the Quantifier element.
            This is the XML Schema Quantifier element for Reaction RuleML.   File:
            quantifier_module.xsd   Version: 1.02   Last Modification: 2015-03-22       * Quantifier
            generic quantifier (used in quantification metatag)   * Forall  predefined body
            quantifier (used in quantification metatag)   * Exist   predefined body quantifier (used
            in qualification metatag)       </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Quantifier ***
	Explicit generic quantifier, where the quantifier name can be defined by the 
    @type attribute and the @iri attribute can point to an external definition
    of the quantifier.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Quantifier
    
    Format: "quantifier declare(Var)* such that guard formula(...)?" 
-->
    <xs:attributeGroup name="Quantifier.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="declare"/>
                <xs:element ref="Var"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-meta-quantifier.type"/>
                <xs:group ref="formula-meta-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Quantifier.type">
        <xs:group ref="Quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <xs:element name="Quantifier" type="Quantifier.type"/>
    <!-- Exists
	make the quantifier constraint restrictions ("such that") optional
	
	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Exists
    -->
    <xs:group name="Exists-quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-meta-quantifier.type"/>
                <xs:group ref="formula-meta-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists-quantifier.type">
        <xs:group ref="Exists-quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <!-- Forall
	make the quantifier constraint restrictions ("such that") optional
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Forall
	-->
    <xs:group name="Forall-quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-meta-quantifier.type"/>
                <xs:group ref="formula-meta-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Forall-quantifier.type">
        <xs:group ref="Forall-quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <!--
		*** formula ***
		The 'such that' guard formula role of a quantifier (<Forall> or <Exists>).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-formula
	-->
    <xs:group name="formula-meta-quantifier.content">
        <xs:choice>
            <xs:group ref="guard.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-meta-quantifier.type">
        <xs:group ref="formula-meta-quantifier.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">         Profile module part of Reaction RuleML.   This is
            the XML Schema Profile element for Reaction RuleML for describing semantic profiles.
            Semantic Profiles are used to define the interpretation evaluation semantics (under the
            evaluation metatag)    either by referecing external existing profiles or by defining
            them internally.   File: profile_module.xsd   Version: 1.02   Last Modification:
            2015-03-22      * Profile         generic semantic profile       </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-22T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Profile ***
	Explicit generic semantic profile defining the intended semantics for knowledge interpretation, inference and execution. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Profile 
	-->
    <xs:attributeGroup name="Profile.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="safety.attrib"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Profile.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
                <xs:element form="qualified" name="content" type="profile_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Profile.type">
        <xs:group ref="Profile.content"/>
        <xs:attributeGroup ref="Profile.attlist"/>
    </xs:complexType>
    <xs:element name="Profile" type="Profile.type"/>
    <!--
     *** content ***
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     the optional @prefix and @vocab are used to define a prefix and a term mapping vocabulary for the XML content (see CURIE to IRI and term to IRI translation)
-->
    <xs:attributeGroup name="profile_anycontent.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="profile_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="profile_anycontent.type">
        <xs:group ref="profile_anycontent.content"/>
        <xs:attributeGroup ref="profile_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               Time module part of Reaction RuleML. It
            defines the core     time constructs        This is the XML Schema time module for
            Reaction RuleML.    File: time_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Time    </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built time module for Reaction RuleML</dc:description>
            <dc:date>2015-07-19T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Time ***
	Explicit generic Time construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Situation
	
	The time can be represented internally 
      * with positional arguments <arg>, e.g., <arg><Data xsi:type="xs:dateTime>2015-10-02T10:45:34-00:00</Data></arg>
      * with unpositional slots <slot>, e.g., <slot><Ind>year</Ind><Ind>2015</Ind></slot><slot><Ind>month</Ind><Ind>10</Ind></slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
      or externally, where the optional @iri attribute points to an external data definition of the time
      The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
      or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
      Note: Time can be defined absolute or relative.
	-->
    <xs:attributeGroup name="Time-formula.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Time-formula.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg" type="arg_time.type"/>
                                        <xs:group ref="arg_time.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="time_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Time-formula.type">
        <xs:group ref="Time-formula.content"/>
        <xs:attributeGroup ref="Time-formula.attlist"/>
    </xs:complexType>
    <!-- Time term -->
    <xs:attributeGroup name="Time-term.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Time-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg" type="arg_time.type"/>
                                        <xs:group ref="arg_time.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="time_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Time-term.type">
        <xs:group ref="Time-term.content"/>
        <xs:attributeGroup ref="Time-term.attlist"/>
    </xs:complexType>
    <!--
     *** arg ***
     
     Definition of the the arg role for Time
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
	-->
    <xs:attributeGroup name="arg_time.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_time.content">
        <xs:choice>
            <xs:group ref="time_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_time.type">
        <xs:group ref="arg_time.content"/>
        <xs:attributeGroup ref="arg_time.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
	-->
    <xs:attributeGroup name="time_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="time_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="time_anycontent.type">
        <xs:group ref="time_anycontent.content"/>
        <xs:attributeGroup ref="time_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">        Spatial module part of Reaction RuleML. It defines
            the core     spatial constructs        This is the XML Schema spatial module for
            Reaction RuleML.    File: spatial_module.xsd    Version: 1.02    Last Modification:
            2015-07-19        This schema declares the following Reaction RuleML elements and
            attributes:        * Spatial       </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Spatial ***
	Explicit generic Spatial construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Spatial
	
	The spatial can be represented internally 
      * with positional arguments <arg>
      * with unpositional slots <slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
      or externally, where the optional @iri attribute points to an external data definition of the spatial
      The optional @type attribute defines the type of the spatial
	-->
    <xs:attributeGroup name="Spatial-formula.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Spatial-formula.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_spatial.type"/>
                                        <xs:group ref="arg_spatial.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="spatial_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Spatial-formula.type">
        <xs:group ref="Spatial-formula.content"/>
        <xs:attributeGroup ref="Spatial-formula.attlist"/>
    </xs:complexType>
    <!-- Spatial term -->
    <xs:attributeGroup name="Spatial-term.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Spatial-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_spatial.type"/>
                                        <xs:group ref="arg_spatial.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="spatial_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Spatial-term.type">
        <xs:group ref="Spatial-term.content"/>
        <xs:attributeGroup ref="Spatial-term.attlist"/>
    </xs:complexType>
    <!--
     *** arg ***
     
     Definition of the the arg role for Spatial
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg  
	-->
    <xs:attributeGroup name="arg_spatial.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_spatial.content">
        <xs:choice>
            <xs:group ref="spatial_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_spatial.type">
        <xs:group ref="arg_spatial.content"/>
        <xs:attributeGroup ref="arg_spatial.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
	-->
    <xs:attributeGroup name="spatial_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="spatial_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="spatial_anycontent.type">
        <xs:group ref="spatial_anycontent.content"/>
        <xs:attributeGroup ref="spatial_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               Interval module part of Reaction RuleML. It
            defines the core     Interval construct        This is the XML Schema interval module
            for Reaction RuleML.    File: interval_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Interval    </xs:documentation>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Interval ***
	Explicit generic Interval. 
	
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Interval
	
	The interval can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the interval,
      the optional @iri attribute points to an external definition of the interval, and
       An interval can be defined by Events, Actions,  Times, Spatials, and other Intervals can be typed by the 
       interval ontology of Reaction RuleML (defining different types of intervals).
	-->
    <xs:attributeGroup name="Interval-formula.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Interval-formula.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:element form="qualified" name="content" type="interval_anycontent.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
                <xs:choice minOccurs="0">
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:element form="qualified" name="content" type="interval_anycontent.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Interval-formula.type">
        <xs:group ref="Interval-formula.content"/>
        <xs:attributeGroup ref="Interval-formula.attlist"/>
    </xs:complexType>
    <!-- Interval term -->
    <xs:attributeGroup name="Interval-term.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Interval-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
                <xs:choice minOccurs="0">
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Interval-term.type">
        <xs:group ref="Interval-term.content"/>
        <xs:attributeGroup ref="Interval-term.attlist"/>
    </xs:complexType>
    <!--
     *** arg ***
     
     Definition of the the arg role for Intervals
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
-->
    <xs:attributeGroup name="arg_interval.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_interval.content">
        <xs:choice>
            <xs:group ref="interval_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_interval.type">
        <xs:group ref="arg_interval.content"/>
        <xs:attributeGroup ref="arg_interval.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation

-->
    <xs:attributeGroup name="interval_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="interval_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="interval_anycontent.type">
        <xs:group ref="interval_anycontent.content"/>
        <xs:attributeGroup ref="interval_anycontent.attlist"/>
    </xs:complexType>
    <!-- include spatial-temporal and interval operators from the algebra modules of reaction ruleml   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">                        spatial-temporal-interval algebra
            module part of Reaction RuleML    This is the XML Schema of the algebra module for
            Reaction RuleML    File: spatial_temporal_interval_algebra_module.xsd    Version: 1.02
            Last Modification: 2015-07-19        This schema declares the following Reaction RuleML
            elements and attributes:                                      Operation (generic
            operator)                   at (general role "at Time | Spatial | Interval)
            Spatial, Temporal, Interval Function Constructs                                       *
            After                   * Before       * Every                   * Any
            * Timer                                                         (Allen's) Interval
            Relations                                      * During                   * Overlaps
            * Starts                   * Precedes                   * Succeeds                   *
            Meets                   * Equal                   * Finishes
            The approach is modelled after that used in "Modularization of XHTML in XML Schema"
            WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-14T17:04:00+0200</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <xs:group name="spatial_temporal_algebra_group.content">
        <xs:choice>
            <xs:element ref="After"/>
            <xs:element ref="Before"/>
            <xs:element ref="Every"/>
            <xs:element ref="Any"/>
            <xs:element ref="Timer"/>
        </xs:choice>
    </xs:group>
    <xs:group name="interval_algebra_group.content">
        <xs:choice>
            <xs:element ref="During"/>
            <xs:element ref="Overlaps"/>
            <xs:element ref="Starts"/>
            <xs:element ref="Precedes"/>
            <xs:element ref="Succeeds"/>
            <xs:element ref="Meets"/>
            <xs:element ref="Finishes"/>
        </xs:choice>
    </xs:group>
    <!--
      *** at ***
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-at
      
	  Note: In Situation Calculus the time is a situation (the history of occured situations as a finite sequence of the events/actions) 	
	-->
    <xs:attributeGroup name="at.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="at.content">
        <xs:choice>
            <xs:group ref="time_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="at.type">
        <xs:group ref="at.content"/>
        <xs:attributeGroup ref="at.attlist"/>
    </xs:complexType>
    <xs:element name="at" type="at.type"/>
    <!--
      *** After / Before***

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-After
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Before

      X after Y  / X before Y
      
      Note: Y might be absolute or relative, e.g. "after 2 days", "2 days after X"  
	-->
    <xs:attributeGroup name="After.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="After.content">
        <xs:sequence>
            <xs:group ref="Interval-term.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="After.type">
        <xs:group ref="After.content"/>
        <xs:attributeGroup ref="After.attlist"/>
    </xs:complexType>
    <xs:element name="After" type="After.type"/>
    <xs:element name="Before" type="After.type"/>
    <!--
      *** Every ***
      
      Every X 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Every
      
      Note:  X is often a relative, e.g. "every Monday", "every 2 meters" 
	-->
    <xs:attributeGroup name="Every.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Every.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                <xs:group ref="interval_primitives.content"/>
                <xs:element form="qualified" name="content" type="interval_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Every.type">
        <xs:group ref="Every.content"/>
        <xs:attributeGroup ref="Every.attlist"/>
    </xs:complexType>
    <xs:element name="Every" type="Every.type"/>
    <!--
      *** Any ***
      
      Any X1,..Xn
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Any
            
      e.g. "at any Saturday and Sunday"     
	-->
    <xs:attributeGroup name="Any.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Any.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="arg"
                    type="arg_interval.type"/>
                <xs:group maxOccurs="unbounded" minOccurs="1" ref="interval_primitives.content"/>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="content"
                    type="interval_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Any.type">
        <xs:group ref="Any.content"/>
        <xs:attributeGroup ref="Any.attlist"/>
    </xs:complexType>
    <xs:element name="Any" type="Any.type"/>
    <!--
      *** (Recurring) Timer ***
      
      After X Every Y
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Recurring
      
      Note: X and Y might be relative, e.g. after 1 hour every hour (recurring timer)
	-->
    <xs:attributeGroup name="Timer.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Timer.content">
        <xs:sequence>
            <xs:group ref="Interval-term.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Timer.type">
        <xs:group ref="Timer.content"/>
        <xs:attributeGroup ref="Timer.attlist"/>
    </xs:complexType>
    <xs:element name="Timer" type="Timer.type"/>
    <!--
      *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes) ***
      
      operator(Interval, Interval)
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-During
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Overlaps
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Starts
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Precedes
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Succeeds
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Meets
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Equal
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Finishes
	-->
    <xs:attributeGroup name="IntervalAlgebraOperator.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="IntervalAlgebraOperator.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:group ref="arg_interval.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="IntervalAlgebraOperator.type">
        <xs:group ref="IntervalAlgebraOperator.content"/>
        <xs:attributeGroup ref="IntervalAlgebraOperator.attlist"/>
    </xs:complexType>
    <xs:element name="During" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Overlaps" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Starts" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Precedes" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Succeeds" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Meets" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Finishes" type="IntervalAlgebraOperator.type"/>
    <!-- include actions from the PR rule layer of reaction ruleml   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">        Action module part of Reaction RuleML. It defines
            the core     action constructs        This is the XML Schema event module for Reaction
            RuleML.    File: action_module.xsd    Version: 1.02    Last Modification: 2015-07-19
            This schema declares the following Reaction RuleML elements and attributes:        *
            Action       </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
     *** arg ***
     
     Definition of the the arg role for Action


     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
     
-->
    <xs:attributeGroup name="arg_action.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_action.content">
        <xs:choice>
            <xs:group ref="action_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_action.type">
        <xs:group ref="arg_action.content"/>
        <xs:attributeGroup ref="arg_action.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     content model:  xs:any*
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
          
    -->
    <xs:attributeGroup name="action_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="action_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="action_anycontent.type">
        <xs:group ref="action_anycontent.content"/>
        <xs:attributeGroup ref="action_anycontent.attlist"/>
    </xs:complexType>
    <!--
	*** Action ***
	
	  Explicit generic Action. The action can be defined internally 
     	* with positional arguments <arg>, e.g., <arg><Ind>a1</Ind></arg> (atomic actions | complex actions)
      	* with unpositional slots <slot>, e.g., <slot><Ind>name</Ind><Ind>a1</Ind></slot><slot><Ind>processingDate</Ind><Time>....</Time></slot>
      	* as interpretation as event with <do>, e.g., <do><Atom>...</Atom></do>
      	* by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for actions
      or externally, where the optional @iri attribute points to an external definition of the action.
      The optional @type attribute defines the type of the action,
      the optional @safety attribute indicates if this is an interrupting, non-interrupting, transactional action
      the optional @size attribute acts as a generic size counter for the number of actions to be done 
      optional @closure defines the default quantification
             

	  See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Action	                
	-->
    <xs:attributeGroup name="Action-formula.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Action-formula.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="slot"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_action.type"/>
                                        <xs:group ref="arg_action.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element maxOccurs="unbounded" minOccurs="0" ref="slot"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" name="content" type="action_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Action-formula.type">
        <xs:group ref="Action-formula.content"/>
        <xs:attributeGroup ref="Action-formula.attlist"/>
    </xs:complexType>
    <!-- action term -->
    <xs:attributeGroup name="Action-term.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Action-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="slot"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_action.type"/>
                                        <xs:group ref="arg_action.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element maxOccurs="unbounded" minOccurs="0" ref="slot"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" name="content" type="action_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Action-term.type">
        <xs:group ref="Action-term.content"/>
        <xs:attributeGroup ref="Action-term.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">                        action algebra module part of
            Reaction RuleML    This is the XML Schema of the algebra module for Reaction RuleML
            File: action_algebra_module.xsd    Version: 1.02    Last Modification: 2015-03-22
            This schema declares the following Reaction RuleML elements and attributes:
            Action Algebra Operators                                      * Operation (generic
            action operator)                   * Succession                    * Choice
            * Flow                    * Loop                           The approach is modelled
            after that used in "Modularization of XHTML in XML Schema"    WD
            [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-22T29:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <xs:group name="action_algebra_group.content">
        <xs:choice>
            <xs:element ref="Succession"/>
            <xs:element ref="Choice"/>
            <xs:element ref="Flow"/>
            <xs:element ref="Loop"/>
            <xs:element form="qualified" name="Operation" type="ActionAlgebraOperator.type"/>
        </xs:choice>
    </xs:group>
    <!--
      *** (Succession) (Choice) (Flow) (Loop) (Operation) ***
      
      Definition of action algebra operators


     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Sucession
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Choice
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Flow
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Loop
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Operation
	-->
    <xs:attributeGroup name="ActionAlgebraOperator.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="ActionAlgebraOperator.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="do"/>
                <xs:group ref="do.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="ActionAlgebraOperator.type">
        <xs:group ref="ActionAlgebraOperator.content"/>
        <xs:attributeGroup ref="ActionAlgebraOperator.attlist"/>
    </xs:complexType>
    <xs:element name="Succession" type="ActionAlgebraOperator.type"/>
    <xs:element name="Choice" type="ActionAlgebraOperator.type"/>
    <xs:element name="Flow" type="ActionAlgebraOperator.type"/>
    <xs:element name="Loop" type="ActionAlgebraOperator.type"/>
    <!-- include events from the ECA rule layer of reaction ruleml   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">               Event module part of Reaction RuleML. It
            defines the core     event constructs        This is the XML Schema event module for
            Reaction RuleML.    File: event_module.xsd    Version: 1.02    Last Modification:
            2015-07-19     This schema declares the following Reaction RuleML elements and
            attributes:       * Event    </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-07-19T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Event ***
	  Explicit generic Event. 
	  
	  See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Event
	  
	  The event can be defined internally 
     	* with positional arguments <arg>, e.g., <arg><Ind>e1</Ind></arg>
      	* with unpositional slots <slot>, e.g., <slot><Ind>name</Ind><Ind>e1</Ind></slot><slot><Ind>processingDate</Ind><Time>....</Time></slot>
      	* as interpretation as event with <on>, e.g., <on><Atom>...</Atom></on>
      	* by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for events
      or externally, where the optional @iri attribute points to an external definition of the event.
      The optional @type attribute defines the type of the event,
      the optional @safety attribute indicates if this is an interrupting, non-interrupting, transactional event
      the optional @size attribute acts as a generic size counter for the number of events to be received 
      Definitions of time and spatial events are simplified by makeing the assumption that a time/spatial object can be interpreted as event, 
      e.g. <Event><arg><Time>...</Time></arg></Event>.
      
      The event instance is defined by its <arg>uments, <slot>s, as an event interpretation <on>, or arbitrary <content>.
      An event pattern (as used, e.g., in the <on> part of a reaction rule) is defined in the <signature> 
      of the event as event template, e.g. <Event><signature>...</signature></Event>.

	-->
    <xs:attributeGroup name="Event-formula.attlist">
        <xs:attributeGroup ref="event-interface.attlist"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Event-formula.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_event.type"/>
                                        <xs:group ref="arg_event.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" name="content" type="event_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Event-formula.type">
        <xs:group ref="Event-formula.content"/>
        <xs:attributeGroup ref="Event-formula.attlist"/>
    </xs:complexType>
    <!-- event term -->
    <xs:attributeGroup name="Event-term.attlist">
        <xs:attributeGroup ref="event-interface.attlist"/>
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Event-term.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_event.type"/>
                                        <xs:group ref="arg_event.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                        </xs:sequence>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:element form="qualified" name="content" type="event_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Event-term.type">
        <xs:group ref="Event-term.content"/>
        <xs:attributeGroup ref="Event-term.attlist"/>
    </xs:complexType>
    <!--
     *** arg ***
     
     Definition of the the arg role for Event
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-arg
     
-->
    <xs:attributeGroup name="arg_event.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_event.content">
        <xs:choice>
            <xs:group ref="event_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_event.type">
        <xs:group ref="arg_event.content"/>
        <xs:attributeGroup ref="arg_event.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
         
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation

    -->
    <xs:attributeGroup name="event_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="event_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="event_anycontent.type">
        <xs:group ref="event_anycontent.content"/>
        <xs:attributeGroup ref="event_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">                        event algebra module part of
            Reaction RuleML    This is the XML Schema of the event algebra module for Reaction
            RuleML    File: event_algebra_module.xsd    Version: 1.02    Last Modification:
            2015-03-22        This schema declares the following Reaction RuleML elements and
            attributes:                                                                        Event
            Algebra Operators                                      * Operation (generic event
            operator)                   * Sequence                    * Disjunction
            * Xor                    * Conjunction                    * Concurrent
            * Not                    * Any                    * Aperiodic                    *
            Periodic                    * AtLeast                    * ATMost                    *
            Operation                       The approach is modelled after that used in
            "Modularization of XHTML in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/],
            which will soon be integrated with    "Modularization of XHTML"
            (REC-xhtml-modularization-20010410)    [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-22T29:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <xs:group name="event_algebra_group.content">
        <xs:choice>
            <xs:element ref="Sequence"/>
            <xs:element ref="Disjunction"/>
            <xs:element ref="Xor"/>
            <xs:element ref="Conjunction"/>
            <xs:element ref="Concurrent"/>
            <xs:element ref="Not"/>
            <xs:element form="qualified" name="Any" type="EventAlgebraOperator.type"/>
            <xs:element ref="Aperiodic"/>
            <xs:element ref="Periodic"/>
            <xs:element ref="AtLeast"/>
            <xs:element ref="AtMost"/>
            <xs:element form="qualified" name="Operation" type="EventAlgebraOperator.type"/>
        </xs:choice>
    </xs:group>
    <!--
      *** (Operation) Sequence Disjunction XOR Conjunction Concurrent Not Any Aperiodic Periodic AtLeast AtMost ***
      
      See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Operation
	-->
    <xs:attributeGroup name="EventAlgebraOperator.attlist">
        <xs:attributeGroup ref="event-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
	<xs:group name="EventAlgebraOperator.content">
		<xs:sequence>
			<xs:group ref="meta-roles.content"/>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="on"/>
				<xs:group ref="on.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="EventAlgebraOperator.type">
        <xs:group ref="EventAlgebraOperator.content"/>
        <xs:attributeGroup ref="EventAlgebraOperator.attlist"/>
    </xs:complexType>
    <xs:element name="Sequence" type="EventAlgebraOperator.type"/>
    <xs:element name="Disjunction" type="EventAlgebraOperator.type"/>
    <xs:element name="Xor" type="EventAlgebraOperator.type"/>
    <xs:element name="Conjunction" type="EventAlgebraOperator.type"/>
    <xs:element name="Concurrent" type="EventAlgebraOperator.type"/>
    <!--
      *** Not ***
      
      "Not on Even2 at [Event1, Event3]" ("Event 2 does not occur between/at [Event 1 and Event 3]")
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Not 
	-->
    <xs:attributeGroup name="Not.attlist">
        <xs:attributeGroup ref="EventAlgebraOperator.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Not.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element ref="on"/>
                </xs:choice>
                <xs:choice>
                    <xs:element ref="at"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Not.type">
        <xs:group ref="Not.content"/>
        <xs:attributeGroup ref="Not.attlist"/>
    </xs:complexType>
    <xs:element name="Not" type="Not.type"/>
    <!--
      *** Aperiodic ***
      
      "Aperiodic on Event2 at [Event1, Event3]" ("Event2 does occur aperiodically at [Event 1 and Event3]")
      possibly with multiple accumlated occurences of Event 2 (@size attribute) 
      
            see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Aperiodic
            
             *** Periodic ***
      
      "Periodic on Event2 at [Event1, Event3]" ("Event2 does occur periodically at time interval [Event 1 and Event3]")
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Periodic     
	-->
    <xs:element name="Aperiodic" type="Not.type"/>
    <xs:element name="Periodic" type="Not.type"/>
    <!--
      *** AtLeast / AtMost ***
      
      "AtLeast @size occurrences on Event"
      "AtMost @size occurrences on Event"
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-AtLeast
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-AtMost
 
	-->
    <xs:element name="AtLeast" type="EventAlgebraOperator.type"/>
    <xs:element name="AtMost" type="EventAlgebraOperator.type"/>
    <!-- include events from the CEP rule layer of reaction ruleml   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">        Message module part of Reaction RuleML.        This
            is the XML Schema Message module for Reaction RuleML.    File: message_module.xsd
            Version: 1.02    Last Modification: 2015-07-20        This schema declares the following
            Reaction RuleML elements and attributes:            * Message    * Agent    * Protocol
            * protocol    * sender    * receiver        * content | payload    * @mode    *
            directive    * Send    * Receive    * enclosed        The approach is modelled after
            that used in "Modularization of XHTML in XML Schema"    WD
            [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].       </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** Message ***
      A Message element that provides the syntax for inbound and outbound messages / notifications 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Message      
-->
    <xs:attributeGroup name="Message.attlist">
        <xs:attributeGroup ref="message-mode.attrib"/>
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Message.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="cid" type="oid.type"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element ref="protocol"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element ref="directive"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element ref="sender"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element ref="receiver"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="content" type="message_anycontent.type"/>
                <xs:element ref="payload"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Message.type">
        <xs:group ref="Message.content"/>
        <xs:attributeGroup ref="Message.attlist"/>
    </xs:complexType>
    <xs:element name="Message" type="Message.type"/>
    <!--
      *** Agent ***
      Generic Agent element for defining Agents locally or for referencing existing external Agents
      
            see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Agent      
	-->
    <xs:attributeGroup name="Agent.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Agent.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="meta"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="qualification"/>
            <xs:element maxOccurs="1" minOccurs="0" ref="oid"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="content" type="message_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Agent.type">
        <xs:group ref="Agent.content"/>
        <xs:attributeGroup ref="Agent.attlist"/>
    </xs:complexType>
    <xs:element name="Agent" type="Agent.type"/>
    <!--
      *** Protocol ***
      Generic Protocol element for defining protocols locally or for referencing existing external protocols
 
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Protocol
                  
-->
    <xs:attributeGroup name="Protocol.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Protocol.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="meta"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="qualification"/>
            <xs:element maxOccurs="1" minOccurs="0" ref="oid"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="content" type="message_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Protocol.type">
        <xs:group ref="Protocol.content"/>
        <xs:attributeGroup ref="Protocol.attlist"/>
    </xs:complexType>
    <xs:element name="Protocol" type="Protocol.type"/>
    <!--
     *** protocol ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-protocol
-->
    <xs:attributeGroup name="protocol.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="protocol.content">
        <xs:sequence>
            <xs:choice>
                <xs:element ref="Protocol"/>
                <xs:element ref="Ind"/>
                <xs:element ref="Data"/>
                <xs:element ref="Var"/>
                <xs:element ref="Expr"/>
                <xs:element ref="Plex"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="protocol.type">
        <xs:group ref="protocol.content"/>
        <xs:attributeGroup ref="protocol.attlist"/>
    </xs:complexType>
    <xs:element name="protocol" type="protocol.type"/>
    <!--
     *** directive ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-directive

-->
    <xs:attributeGroup name="directive.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="directive.content">
        <xs:sequence>
            <xs:choice>
                <xs:element ref="Ind"/>
                <xs:element ref="Data"/>
                <xs:element ref="Var"/>
                <xs:element ref="Expr"/>
                <xs:element ref="Plex"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="directive.type">
        <xs:group ref="directive.content"/>
        <xs:attributeGroup ref="directive.attlist"/>
    </xs:complexType>
    <xs:element name="directive" type="directive.type"/>
    <!--
     *** sender ***
     *** receiver ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-sender
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-receiver
-->
    <xs:attributeGroup name="sender.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="sender.content">
        <xs:sequence>
            <xs:choice>
                <xs:element ref="Agent"/>
                <xs:element ref="Ind"/>
                <xs:element ref="Data"/>
                <xs:element ref="Var"/>
                <xs:element ref="Expr"/>
                <xs:element ref="Plex"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="sender.type">
        <xs:group ref="sender.content"/>
        <xs:attributeGroup ref="sender.attlist"/>
    </xs:complexType>
    <xs:element name="sender" type="sender.type"/>
    <xs:element name="receiver" type="sender.type"/>
    <!--
     *** content ***
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
     	
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-content
    -->
    <xs:attributeGroup name="message_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="message_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="message_anycontent.type">
        <xs:group ref="message_anycontent.content"/>
        <xs:attributeGroup ref="message_anycontent.attlist"/>
    </xs:complexType>
    <!--
    *** @mode ***

     restriction: inbound | outbound  ; 
	 optional attribute
-->
    <xs:attributeGroup name="message-mode.attrib">
        <xs:attribute name="mode" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="inbound"/>
                    <xs:enumeration value="outbound"/>
                    <xs:enumeration value="bidirectional"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
      *** Send and Receive ***
      Send  and Receive performative / action
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Send
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Receive

    -->
    <xs:attributeGroup name="Send.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Send.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="enclosed"/>
                <xs:element ref="Message"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Send.type">
        <xs:group ref="Send.content"/>
        <xs:attributeGroup ref="Send.attlist"/>
    </xs:complexType>
    <xs:element name="Send" type="Send.type"/>
    <xs:attributeGroup name="Receive.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Receive.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="enclosed"/>
                <xs:element ref="Message"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Receive.type">
        <xs:group ref="Receive.content"/>
        <xs:attributeGroup ref="Receive.attlist"/>
    </xs:complexType>
    <xs:element name="Receive" type="Receive.type"/>
    <!--
     *** enclosed ***
     
     Definition of the the enclosed role for Send and Receive actions
      
	-->
    <xs:attributeGroup name="enclosed.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="enclosed.content">
        <xs:choice>
            <xs:element ref="Message"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="enclosed.type">
        <xs:group ref="enclosed.content"/>
        <xs:attributeGroup ref="enclosed.attlist"/>
    </xs:complexType>
    <xs:element name="enclosed" type="enclosed.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en">        Test and Proof module part of Reaction RuleML.
            This is the XML Schema Test module for Reaction RuleML.    File: test_module.xsd
            Version: 1.02    Last Modification: 2015-07-20        Further information - see RBSLA
            project (http://rbsla.ruleml.org)    ContractLog framework VVI Testing:
            http://rbsla.ruleml.org/docs/ContractLog_VVI.pdf        This schema declares the
            following Reaction RuleML elements and attributes:            * Test    * vvi    *
            TestSuite    * testbase    * TestItem    * Answer     * formula (Answer)    *
            expectedResult        The approach is modelled after that used in "Modularization of
            XHTML in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].       </xs:documentation>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.02</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.02</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2015-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dc:rights>'Copyright 2015 RuleML Inc. -- Licensed under the RuleML Specification
                License, Version 1.0 (the "License"); you may not use this file except in compliance
                with the License. You may obtain a copy of the License at
                http://ruleml.org/licensing/RSL1.0-RuleML. Disclaimer: THIS SPECIFICATION IS
                PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, ..., EVEN IF ADVISED OF
                THE POSSIBILITY OF SUCH DAMAGE. See the License for the specifics governing
                permissions and limitations under the License.</dc:rights>
            <dcterms:rights>http://ruleml.org/licensing/RSL1.0-RuleML</dcterms:rights>
            <dc:relation>http://reaction.ruleml.org</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** Test ***
      A Test action/primitive that provides the syntax for Verification, Validation and Integrity (VVI) Testing.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-Test
      
      An optional scope (<scope>) can be defined so that the test applies only to the scope (constructed view) on the knowledge base.   
	-->
    <xs:attributeGroup name="Test.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Test.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="vvi"/>
                <xs:group ref="vvi.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Test.type">
        <xs:group ref="Test.content"/>
        <xs:attributeGroup ref="Test.attlist"/>
    </xs:complexType>
    <xs:element name="Test" type="Test.type"/>
    <!--
     *** vvi ***
     
     vvi role - "verification, validation, integrity" tests
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-vvi 
	-->
    <xs:attributeGroup name="vvi.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="vvi.content">
        <xs:choice>
            <xs:element ref="Entails"/>
            <xs:element ref="TestSuite"/>
            <xs:element ref="TestItem"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="vvi.type">
        <xs:group ref="vvi.content"/>
        <xs:attributeGroup ref="vvi.attlist"/>
    </xs:complexType>
    <xs:element name="vvi" type="vvi.type"/>
    <!--
     *** testsbase ***
     
     base role for the test assertion | consultation base
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-testbase
	-->
    <xs:attributeGroup name="testbase.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="testbase.content">
        <xs:choice>
            <xs:element ref="Consult"/>
            <xs:element ref="Assert"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="testbase.type">
        <xs:group ref="testbase.content"/>
        <xs:attributeGroup ref="testbase.attlist"/>
    </xs:complexType>
    <xs:element name="testbase" type="testbase.type"/>
    <!--
      *** TestSuite ***
      A TestSuite consisting of the assertion | consultation base (test assertions) and the VVI tests (integrity entailments, test items or nested test suites 

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-TestSuite
	-->
    <xs:attributeGroup name="TestSuite.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="TestSuite.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="testbase"/>
                <xs:element ref="Assert"/>
                <xs:element ref="Consult"/>
            </xs:choice>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="vvi"/>
                <xs:group ref="vvi.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="TestSuite.type">
        <xs:group ref="TestSuite.content"/>
        <xs:attributeGroup ref="TestSuite.attlist"/>
    </xs:complexType>
    <xs:element name="TestSuite" type="TestSuite.type"/>
    <!--
      *** TestItem ***
      TestItem describing one particular test consisting of the test act (typically a Query) and the expected result (the expected Answer with the predefined expected truth valuation (<degree>) and results/variable bindings)
      
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.022#gloss-TestItem
    -->
    <xs:attributeGroup name="TestItem.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="TestItem.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence minOccurs="0">
                <xs:choice>
                    <xs:element form="qualified" name="do" type="act.type"/>
                    <xs:group ref="act.content"/>
                </xs:choice>
                <xs:choice>
                    <xs:element ref="expectedResult"/>
                    <xs:group ref="expectedResult.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="TestItem.type">
        <xs:group ref="TestItem.content"/>
        <xs:attributeGroup ref="TestItem.attlist"/>
    </xs:complexType>
    <xs:element name="TestItem" type="TestItem.type"/>
    <!--
     *** expectedResult***
     
     Definition of the the enclosed role for Send and Receive actions
     
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.02#gloss-expectedResult

-->
    <xs:attributeGroup name="expectedResult.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="expectedResult.content">
        <xs:choice>
            <xs:element ref="Answer"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="expectedResult.type">
        <xs:group ref="expectedResult.content"/>
        <xs:attributeGroup ref="expectedResult.attlist"/>
    </xs:complexType>
    <xs:element name="expectedResult" type="expectedResult.type"/>
    <!--
     metadata group
     
	This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
	
     content model: (meta*, scope*, guard )
          
	-->
    <xs:group name="metadata.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="meta"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="scope"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="guard"/>
        </xs:sequence>
    </xs:group>
    <!--
     interface group
     
     This internal group defines the interface signature and the evaluation semantics
     
     content model: (evaluation*, signature* )
          
	-->
    <xs:group name="interface.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="evaluation"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="signature"/>
        </xs:sequence>
    </xs:group>
    <!--
     instance group
     
     This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
     
     content model: (qualification*, quantification*, oid? )
          
	-->
    <xs:group name="instance.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="qualification"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="quantification"/>
            <xs:element maxOccurs="1" minOccurs="0" ref="oid"/>
        </xs:sequence>
    </xs:group>
    <!--
         
     An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
    
    
     content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
          
	-->
    <xs:group name="meta-roles.content">
        <xs:sequence>
            <xs:group ref="metadata.content"/>
            <xs:group ref="interface.content"/>
            <xs:group ref="instance.content"/>
        </xs:sequence>
    </xs:group>
    <!--
         
     An internal group for the implementation of a rule in the Reaction RuleML language
    
    
     content model:
     
     in CEP Reaction RuleML:      
     (on | if | then | do | after | else | elseDo)*
          
	-->
    <xs:group name="rule-implementation.content">
        <xs:choice>
            <xs:group ref="MessagingRule.content"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the query connectives in the Reaction RuleML language
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <xs:group name="query-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="Operation-formula-query.type"/>
            <xs:element name="And" type="And-query.type"/>
            <xs:element name="Or" type="Or-query.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Naf"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the rulebase connectives in the Reaction RuleML language
    
    
     content model: (Operation | Negation | Neg | Equal )
          
	-->
    <xs:group name="rulebase-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="Operation-formula-rulebase.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the body connectives in the Reaction RuleML language
    
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <xs:group name="body-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="Operation-formula-and-or.type"/>
            <xs:element name="And" type="And-body.type"/>
            <xs:element name="Or" type="Or-body.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Naf"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the head connectives in the Reaction RuleML language
    
     content model: (Operation | Negation | Neg | Equal)
          
	-->
    <xs:group name="head-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="Operation-formula-and-or.type"/>
            <xs:element name="And" type="And-body.type"/>
            <xs:element name="Or" type="Or-body.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the query quantifiers in the Reaction RuleML language
    
     content model: ( Exists )
          
	-->
    <xs:group name="query-quantifier.content">
        <xs:choice>
            <xs:element ref="Exists"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the body quantifiers in the Reaction RuleML language
    
    
     content model: (Forall | Exists | Quantifier)
          
	-->
    <xs:group name="meta-quantifier.content">
        <xs:choice>
            <xs:element name="Forall" type="Forall-quantifier.type"/>
            <xs:element name="Exists" type="Exists-quantifier.type"/>
            <xs:element ref="Quantifier"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the rulebase quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall  )
          
	-->
    <xs:group name="rulebase-quantifier.content">
        <xs:choice>
            <xs:element ref="Forall"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the head quantifiers in the Reaction RuleML language
	 
	  Quantifiers can be defined internally in the <quantification> too 
    
     content model: ( Forall )
          
	-->
    <xs:group name="head-quantifier.content">
        <xs:choice>
            <xs:element ref="Forall"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the body quantifier in the Reaction RuleML language
    
    
     content model: ( Exist )
          
	-->
    <xs:group name="body-quantifier.content">
        <xs:choice>
            <xs:element ref="Exists"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
    
    content model: (Atom | Time | Spatial | Interval | Event | Action | (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes | Operation))
          
	-->
    <xs:group name="extended-signature-predicate-sorts.content">
        <xs:choice>
            <xs:element name="Atom" type="Atom.type"/>
            <xs:element name="Time" type="Time-formula.type"/>
            <xs:element name="Spatial" type="Spatial-formula.type"/>
            <xs:element name="Interval" type="Interval-formula.type"/>
            <xs:group ref="interval_algebra_group.content"/>
            <xs:element name="Event" type="Event-formula.type"/>
            <xs:element name="Action" type="Action-formula.type"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
    
		content model: (Ind | Data | Expr | Plex | Time | Spatial | Interval | Event | Action | (After | Before | Any | Every | Timer | Operation))
          
	-->
    <xs:group name="extended-signature-function-sorts.content">
        <xs:choice>
            <xs:element ref="Ind"/>
            <xs:element ref="Data"/>
            <xs:element ref="Expr"/>
            <xs:element ref="Plex"/>
            <xs:element name="Time" type="Time-term.type"/>
            <xs:element name="Spatial" type="Spatial-term.type"/>
            <xs:element name="Interval" type="Interval-term.type"/>
            <xs:element name="Event" type="Event-term.type"/>
            <xs:element name="Action" type="Action-term.type"/>
            <xs:group ref="spatial_temporal_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the time primitives for interpretation as time
		content model: 

		in CEP Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) 

	-->
    <xs:group name="time_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the spatial primitives for interpretation as spatial
		content model: 

		in CEP Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)

	-->
    <xs:group name="spatial_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <!-- Interval primitives
		content model: 
		
		in CEP Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)   
	-->
    <xs:group name="interval_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the situation primitives for interpretation as situation
		content model: 
		

	-->
    <xs:group name="situation_primitives.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for the event primitives for interpretation as event
		content model: 
		(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action )		
	-->
    <xs:group name="event_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for events
		content model:
		in CEP Reaction RuleML:  ( Receive | Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operation )
	-->
    <xs:group name="event_group.content">
        <xs:choice>
            <xs:element name="Event" type="Event-formula.type"/>
            <xs:element name="Action" type="Action-formula.type"/>
            <xs:element ref="Receive"/>
            <xs:element ref="Answer"/>
            <xs:group ref="event_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the action primitives for interpretation as action
		content model: 
		
		in CEP Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action )
	-->
    <xs:group name="action_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for actions
		content model:
		CEP Reaction RuleML (Send | Consult | Assert | Retract | Update | Query | Test | Action | Succession | Choice | Flow | Loop | Operation )-->
    <xs:group name="action_group.content">
        <xs:choice>
            <xs:element ref="Assert"/>
            <xs:element ref="Retract"/>
            <xs:element ref="Update"/>
            <xs:element name="Action" type="Action-formula.type"/>
            <xs:element ref="Query"/>
            <xs:element ref="Send"/>
            <xs:element ref="Consult"/>
            <xs:element ref="Test"/>
            <xs:group ref="action_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the imports of the consult primitive
		content model: 
		in DR Reaction RuleML: ((payload | RuleML | Reify | Var) | (enclosed | Message))
	-->
    <xs:group name="consult_imports.content">
        <xs:choice>
            <xs:element ref="payload"/>
            <xs:group ref="payload.content"/>
            <xs:element ref="enclosed"/>
            <xs:element ref="Message"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the performative primitives
		content model: 
		in CEP Reaction RuleML: (Assert|Retract|Update|Query|Answer|Send|Receive|Consult|Test|Action)
	-->
    <xs:group name="performative_primitives.content">
        <xs:choice>
            <xs:element ref="Assert"/>
            <xs:element ref="Retract"/>
            <xs:element ref="Update"/>
            <xs:element ref="Query"/>
            <xs:element ref="Answer"/>
            <xs:element ref="Test"/>
            <!-- for test-driven verification, validation and integrity testing -->
            <xs:element ref="Send"/>
            <xs:element ref="Receive"/>
            <xs:element name="Action" type="Action-formula.type"/>
            <xs:element ref="Consult"/>
        </xs:choice>
    </xs:group>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: active (in CEP Reaction RuleML)
	 optional attribute
-->
    <xs:attributeGroup name="style.attrib">
        <xs:attribute name="style" type="style.datatype" use="optional"/>
    </xs:attributeGroup>
</xs:schema>
