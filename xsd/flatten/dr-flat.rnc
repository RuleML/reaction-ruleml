default namespace = "http://ruleml.org/spec"


# Modifications, after creation using rngconv
# 1. changed name of any(...) to anyLax
# 2. change type of xml:id to NCName
start =
  elseDo
  | Implies
  | Assert
  | Naf
  | after
  | Data
  | arg
  | qualification
  | repo
  | Neg
  | on
  | Expr
  | right
  | signature
  | else
  | resl
  | op
  | Spatial
  | quantification
  | Profile
  | declare
  | Plex
  | Fun
  | Forall
  | strong
  | Exists
  | then
  | Or
  | Negation
  | Entails
  | And
  | torso
  | Interval
  | scope
  | Query
  | meta
  | evaluation
  | Retract
  | Time
  | Atom
  | guard
  | oid
  | if
  | Rulebase
  | Equal
  | do
  | left
  | slot
  | Quantifier
  | Reify
  | Equivalent
  | Rule
  | Ind
  | Rel
  | degree
  | Skolem
  | weak
  | RuleML
  | Var
  | act
  | formula
RuleML.attlist = node-element.attlist, xml.attlist
RuleML.content = meta-roles.content, (act | act.content)*
RuleML.type = RuleML.content, RuleML.attlist
start |= RuleML
RuleML = element RuleML { RuleML.type }
act.content = performative_primitives.content
act.attlist = edge-element.attlist, xml.attlist
act.type = act.content, act.attlist
start |= act
act = element act { act.type }
Consult.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Consult.content = meta-roles.content, (consult_imports.content)*
Consult.type = Consult.content, Consult.attlist
start |= Consult
Consult = element Consult { Consult.type }
payload.attlist = xml.attlist
payload.content = RuleML | Reify | Var
payload.type = payload.content, payload.attlist
start |= payload
payload = element payload { payload.type }
Assert.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Assert.content =
  meta-roles.content,
  (element formula { formula-assert.type }
   | formula-assert.content)*
Assert.type = Assert.content, Assert.attlist
start |= Assert
Assert = element Assert { Assert.type }
Retract.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Retract.content =
  meta-roles.content,
  (element formula { formula-assert.type }
   | formula-assert.content)*
Retract.type = Retract.content, Retract.attlist
start |= Retract
Retract = element Retract { Retract.type }
Update.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Update.content =
  meta-roles.content,
  (element formula { formula-assert.type }
   | formula-assert.content)
Update.type = Update.content, Update.attlist
start |= Update
Update = element Update { Update.type }
#	    *** Query ***
#	    A KQML-like performative acting as a wrapper specifying that its content is
#	    queried, making an 'implicit <Rulebase>' assumption.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Query
# 
#	    content model:
#	    DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval )* )
#	    KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
#	    PR Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )* )
#	    ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )* )		
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Query.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Query.content =
  meta-roles.content,
  (element formula { formula-query.type }
   | formula-query.content)*
Query.type = Query.content, Query.attlist
start |= Query
Query = element Query { Query.type }
#       *** Answer ***
#       Answer performative / action 
# 
#       see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Answer
# 
#       It delivers the answer to a Query . The answer is given in terms of solved formulas, e.g.
# 
#       as a <Rulebase> that contains just 'solved' equations with the variable bindings
# 
#	  <Rulebase>
#		<Equal>
# <Var>x</Var>
# <Ind>a</Ind>
# </Equal>
#		<Equal>
# <Var>y</Var>
# <Ind>b</Ind>
# </Equal>
#		<Equal>
# <Var>z</Var>
# <Ind>c</Ind>
# </Equal>
#	  </Rulebase>
# 
#	  as ground fact <Atom> matching the query / goal 
# 
#	  <Atom>
#		<Rel>p</Rel>
#		<Ind>a</Ind>
#		<Ind>b</Ind>
#		<Ind>c</Ind>
#	  </Atom>
# 
#	  as solved ground entailments <Entails> of the answer from the queried (ground or instantiated / forward chained) rule base  
# 
#	  With the optional <degree> role a truth/uncertainty value (between 0.0 and 1.0; 
#	  with the truth values "1" for true and "0" for false in two-valued logics and "0.5" for unknown in three-valued logics) can be assigned to the answer. 
# 
#	  An answer maybe be also just referenced by the local @key-@keyref mechanism  
#	  or by the optional @iri attribute, in case of externally published answers. 
# 
#	  With the optional @type attribute an answer type can be specified. 
#	  The @safety optionally defines if the answer (event) is interrupting or non-interrupting 
#	  and the @size attribute optionally defines the number of results contained in an Answer.
# 
# 
#       content model:
# 
#	  in CEP Reaction RuleML
#	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree? (formula | Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)* )
# 
#       Answer has the following attributes:
#     attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Answer.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Answer.content =
  meta-roles.content,
  degree?,
  (element formula { formula-answer.type }
   | formula-answer.content)*
Answer.type = Answer.content, Answer.attlist
start |= Answer
Answer = element Answer { Answer.type }
#	  *** formula ***
#	  The formula role of a performative (<Answer>).
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
# 
#	  content model (below Answer formula): 
#	  (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)
# 
#	  Other (context-sensitive) versions of <formula> are in the
#	  connective and quantifier modules.
# 
#	  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
formula-answer.content =
  Rulebase
  | Entails
  | query-connective.content
  | query-quantifier.content
  | extended-signature-predicate-sorts.content
formula-answer.type = formula-answer.content, formula.attlist
#	    *** formula ***
#	    The formula role of a performative (<Assert>, <Retract> or <Query>).
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
# 
#	    content model (below Assert formula): 
#	    DR Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval )
#	    KR Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval  | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
#	    PR Reaction RuleML (Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
#	    ECA Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg |  Time | Spatial | Interval | Event | Action )
# 
#	    content model (below Query): 
#	    DR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval )
#	    KR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
# PR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )
#	    ECA Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action )    
# 
#	    Other (context-sensitive) versions of <formula> are in the
#	    connective and quantifier modules.
# 
#	    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

# the (empty) attribute list is declared in the connective module
formula-assert.content =
  Rulebase
  | Implies
  | Rule
  | Equivalent
  | Entails
  | outer-quantifier.content
  | outer-connective.content
  | extended-signature-predicate-sorts.content
formula-query.content =
  Rulebase
  | Entails
  | query-connective.content
  | query-quantifier.content
  | extended-signature-predicate-sorts.content
formula-assert.type = formula-assert.content, formula.attlist
formula-query.type = formula-query.content, formula.attlist
# *** oid ***
# An optional object identifier for an atomic formula, expression or the unifed terms
# of the SWSL branch, as needed for PSOA semantics.
# Note that oids are not required to be unique within a rulebase.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-oid
# 
# content model: 
# in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
# in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
# in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex)
# in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
oid.attlist = xml.attlist
oid.content =
  Var | Skolem | Reify | extended-signature-function-sorts.content
oid.type = oid.content, oid.attlist
start |= oid
oid = element oid { oid.type }
#  *** meta ***     
# 
# An optional container for meta-knowledge about a Node.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-meta
# 
#     Used for descriptive Metadata annotations in Reaction RuleML
# 
#  content model: 
#  in DR Reaction RuleML: ( Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
#  in KR Reaction RuleML: ( Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
#  in PR Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
#  in ECA Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )
# 
#  Multiple Metadata annotations are possible by repreating <meta>
# 
#  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
meta.attlist = edge-element.attlist, xml.attlist
meta.content = formula-assert.content
meta.type = meta.content, meta.attlist
start |= meta
meta = element meta { meta.type }
#    *** scope ***
# 
#    metadata-based scope definition defined over the metadata annotations and the qualifications annotations.
# 
#    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-scope
# 
#    Note: scope reasoning in rules can use the metadata scopes to define a constructive view on the rules and facts in the KB.    
#    The scoped rule/literal goal only applies in this scope (scoped reasoning/processing)
# 
#    For an implementation of scoped reasoning as a mechanism to dynamicaly create a scope (a constructive view)
#    on the knowledge base and to do scoped reasoning on this scope see the Prova rule engine (http://prova.ws).
# 
#    Example:
#    @src(kb1) @author("Adrian Paschke") @validity([2011-03-20, 2011-04-20]) @label(fact1) fact1(constant1).
#    @src(kb2) @author("Alex Kozlenkov") @validity([2011-01-20, 2011-03-20]) @label(fact2) fact2(constant2).
# 
#    @src(rb1) @label(rule1) rule1(Y) :- @validity(VTime) @authors("Adrian Paschke") fact1(Y) [between(SysTime,VTime)] 
# 
#    In this example all knowledge is annotated with predefined (@src, ...) and user-defined metadata annotations (@author, @validity, ...). 
#    User-defined metadata annotations can be arbitrary name/value pairs described as predicates. The literal "fact1" in the body
#    of "rule1" is a scoped literal defining a scope over knowledge in the knowledge base with the scope constraints
#    @validity and @author. If such knowledge is found in the KB the meta data value (an Interval) for @validity
#    is bound to the variable "VTime" and used in the guard constraint [...] on the literal. The guard is stating that 
#    the actual system time should be  within the validity interval. The second scope constraint is directly compared 
#    to the constant value "Adrian Paschke".
#    The sub-goal literal "fact1" in the rule condition is then applied only on the selected scope 
#    (a constructive view on the overall knowledge base which is selected by the metadata scope of the literal) and not on the 
#    overal knowledge. It is possible to define scopes for modules (e.g. sets of knowledge such as a rule-base/rule-set or 
#    an knowledge updates (assert, retracts) by using the meta data identifier such as @src or @label. Such identifiers can
#    be also used for transactional logics.
# 
#    In Reaction RuleML general metadata annotations (descriptive metadata) are defined under the <meta> tag role and
#    qualifying metadata which qualify the rule (such as validity in the above example) are defined under the <qualification> tag.
#    The @key attribute which defines a unique identifier for knowledge in the knowledge base is used for a 
#    modular nested structuring of the knowledge base. The @key of e.g. <Assert key=""> or <Rulebase key=""> acts as module identifier 
#    (which in Prova is denoted by the predefined @src metadata).
# 
#        Scopes in Reaction RuleML can be defined within the <scope> role tag on descriptive metadata <meta> and qualifying metadata <qualification> as well as
#        on the unique identifier @key of the knowledge in the knowledge base (<Assert key="">, <Rulebase key="">, <Rule key="">, <Atom key="">)
#        by referencing it with the @keyref attribute.
# 
#        There is a nesting of scopes. Scopes defined on the more general level automatically apply to the inner knowledge. For instance, a scope
#        defined on the level of a <Rulebase> automatically applies to all goal literals of the <Rule>s in the rulebase. Inner scopes
#        overwrite the outer scope. For instance a scope defined on <Assert> becomes overwritten by an inner scope defined on a <Rule> which is within the
#        this asserted knowledge module. That is the goal literals within this rules are automatically applying the innter scope and not the outer scope.
# 
#        Note: the old approach which used <oid> to define a scope has been replaces by the key-keyref approach in Reaction RuleML 1.0
# 
#    Note: multiple scopes can be defined by repeating the <scope> role element
#    Note: an empty scope either assumes the outer scope or an existing scope needs to be explicity referenced by keyref
# 
#    content model: 
#    DR Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
#    KR Reaction RuleML  ( Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
#    PR Reaction RuleML  ( Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)?     
#    ECA Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )
# 
# attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
scope.attlist = edge-element.attlist, xml.attlist
scope.content = formula-query.content?
scope.type = scope.content, scope.attlist
start |= scope
scope = element scope { scope.type }
#  *** guard ***     
# 
#     guard constraints 
# 
#     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-guard
# 
#  content model: 
#  in DR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
#  in KR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
#  in PR Reaction RuleML: ( Operator | Atom | And | Or | Equal | Negation | Naf )
#  in ECA Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)    
# 
# attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
guard.attlist = edge-element.attlist, xml.attlist
guard.content = if.content
guard.type = guard.content, guard.attlist
start |= guard
guard = element guard { guard.type }
#  *** evaluation ***
# 
#  The intended evaluation semantics, e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
# 
#     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-evaluation
# 
#  Note: multiple Profiles can be defined by repreating the <evaluation> role element
#  The Profiles can be defined externally by using the Profile attributes to point to it or internally by defining it in XML (xs:any)
# 
#  content model: (Profile )     
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
evaluation.attlist = edge-element.attlist, xml.attlist
evaluation.content = Profile
evaluation.type = evaluation.content, evaluation.attlist
start |= evaluation
evaluation = element evaluation { evaluation.type }
#    *** signature ***
# 
#    The signature defines the signature of knowledge (formula and terms) with optional input / output mode declarations. The signature declaration can act as public interface and
#       can be published together with the intended evaluation semantics. 
# 
#       see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-signature
# 
#       Note: In PR, RR and CEP reaction rules the signature is extended with events and actions
#       for defining the event templates (i.e. the event form / event descriptor which corresponds to the event type/class. The event template is used for
#       pattern machting, i.e. in the on part of a reaction rule it triggers the reaction rule if the template matches with required event instances, which are
#       instantiations of the event type / class to which make up the required properties of the event template.
# 
#       Multiple signatures are possible by repreating the <signature> element
# 
#    content model: 
#    DR Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
#    KR Reaction RuleML  ( Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
#    PR Reaction RuleML  ( Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)? 
#    ECA Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )         
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
signature.attlist = edge-element.attlist, xml.attlist
signature.content = formula-query.content
signature.type = signature.content, signature.attlist
start |= signature
signature = element signature { signature.type }
#    *** qualification ***
# 
#   Definition of the qualification (qualifying metadata), e.g. validity time, priorities, etc.
# 
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-qualification
# 
#   Note: the qualification can be also defined as a situation  <Situation> in KR Reaction RuleML 
#       A situation could be also modelled as a changeable situation called fluent (in the KR dialect of Reaction RuleML),
#       which changes its truth value depending on the context (context can be time, events/actions which 
#       initiate/terminate the changeable situation, or a history of occured events/actions which leads to an occured situation
#       as context for the truth changes of the fluent.
# 
#       That would mean the qualification of the rule changes depending on the situation (the truth value of the fluent in KR RuleML)
# 
#    content model: 
#    in DR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
#    in KR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
#    in PR Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
#    in ECA Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
qualification.attlist = edge-element.attlist, xml.attlist
qualification.content = formula-assert.content
qualification.type = qualification.content, qualification.attlist
start |= qualification
qualification = element qualification { qualification.type }
# *** quantification ***
# 
# Definition of the quantifier. 
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-quantification
# 
# content model: (Forall | Exists | Quantifier)
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
quantification.attlist = edge-element.attlist, xml.attlist
quantification.content = inner-quantifier.content
quantification.type = quantification.content, quantification.attlist
start |= quantification
quantification = element quantification { quantification.type }
# extended descriptors in Reaction RuleML

# note that elementFormDefault is qualified because of local declarations

#	    *** Forall ***
#	    Explicit universal quantifier.
# 
#	    See http://www.ruleml.org/1.0/glossary/#gloss-Forall
# 
#	    content model: 
#	    DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval ) )
#	    KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens ) )
#	    PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
#	    ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action ) )		
# 
# attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
Forall.attlist =
  quantifier-interface.attlist, node-element.attlist, xml.attlist
Forall.content =
  meta-roles.content,
  (declare | declare.content)+,
  (element formula { formula-forall.type }
   | formula-forall.content)
Forall.type = Forall.content, Forall.attlist
start |= Forall
Forall = element Forall { Forall.type }
#	    *** Exists ***
#	    Explicit existential quantifier.
# 
#	    See http://www.ruleml.org/1.0/glossary/#gloss-Exists
# 
#	    content model: 
#	    DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval) )
#	    KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens) )		
# PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
#	    ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) )    
# 
# attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Exists.attlist =
  quantifier-interface.attlist, node-element.attlist, xml.attlist
Exists.content =
  meta-roles.content,
  (declare | declare.content)+,
  (element formula { formula-exists.type }
   | formula-exists.content)
Exists.type = Exists.content, Exists.attlist
start |= Exists
Exists = element Exists { Exists.type }
# *** declare ***
# A role used for variables declared within a quantifier.
# 
# See http://www.ruleml.org/1.0/glossary/#gloss-declare
# 
# content model: ( Var )
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
declare.attlist = xml.attlist
declare.content = Var
declare.type = declare.content, declare.attlist
start |= declare
declare = element declare { declare.type }
# *** formula ***
# The formula role of a quantifier (<Forall> or <Exists>).
# 
# See http://www.ruleml.org/1.0/glossary/#gloss-formula
# 
# content model (below Forall): 
# DR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval )
# KR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
# ECA Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action)
# 
# content model (below Exists): 
# DR Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval )
# KR Reaction RuleML ( Atom | Exists  | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )
# PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
# ECA Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)		
# 
# Other (context-sensitive) versions of <formula> are in the
# connective and performative modules.
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
formula-forall.content =
  Implies
  | Rule
  | Equivalent
  | outer-quantifier.content
  | outer-connective.content
  | extended-signature-predicate-sorts.content
formula-forall.type = formula-forall.content, formula.attlist
formula-exists.content =
  query-quantifier.content
  | query-connective.content
  | extended-signature-predicate-sorts.content
formula-exists.type = formula-exists.content, formula.attlist
#	    *** Implies ***
#	    An implication rule.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Implies
# 
#	    content model:
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (then, if) | (if, then) | ( (Atom | And | Or | Equal), (Atom | Equal) ) )
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
Implies.attlist =
  formula-interface.attlist, material.attrib, xml.attlist
Implies.content =
  meta-roles.content,
  (then | if | if | then | if.content | then.content)
Implies.type = Implies.content, Implies.attlist
start |= Implies
Implies = element Implies { Implies.type }
# *** if ***
# The if of an implication rule containing the premise(s),
# also known as the "antecedent" or "if" part of the rule.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if
# 
# content model: 
# DR Reaction RuleML (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
# KR Reaction RuleML (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf ) 
# ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
if.attlist = xml.attlist
if.content =
  inner-connective.content | extended-signature-predicate-sorts.content
if-entails.content = Rulebase
if.type = if.content, if.attlist
if-entails.type = if-entails.content, if.attlist
start |= if
if = element if { if.type }
# *** then ***
# The then of an implication rule containing the conclusion,
# also known as the "consequent" or "then" part of the rule.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then
# 
# content model: 
# DR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
# KR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML does not support "then"  (except in combination with DR/KR Reaction RuleML)
# ECA Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
then.attlist = xml.attlist
then.content =
  outer-connective.content | extended-signature-predicate-sorts.content
then-entails.content = Rulebase
then.type = then.content, then.attlist
then-entails.type = then-entails.content, then.attlist
start |= then
then = element then { then.type }
# *** Entails ***
# Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
# Kowalski/Bowen's object/meta-level-amalgamated logic).
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Entails
# 
# content model:
# ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (if | Rulebase), (then | Rulebase) )
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Entails.attlist =
  group-formula-interface.attlist, node-element.attlist, xml.attlist
Entails.content =
  meta-roles.content,
  (element if { if-entails.type }
   | if-entails.content),
  (element then { then-entails.type }
   | then-entails.content)
Entails.type = Entails.content, Entails.attlist
start |= Entails
Entails = element Entails { Entails.type }
# *** Equivalent ***
# An equivalence expression, which is "syntactic sugar" for a pair
# of conjoined converse implication rules.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equivalent
# 
# content model: 		
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval) ) ) )
# KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens), 
#		      (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens) ) ) )
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Negation | Naf | Atom | Equal), (Operator | And | Or | Negation | Naf | Atom | Equal ) ) ) )                     
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
# CEP Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Equivalent.attlist =
  formula-interface.attlist, material.attrib, xml.attlist
Equivalent.content =
  meta-roles.content, (torso | torso | torso.content | torso.content)
Equivalent.type = Equivalent.content, Equivalent.attlist
start |= Equivalent
Equivalent = element Equivalent { Equivalent.type }
# *** torso ***
# A symmetric role used in an equivalence expression combining
# the asymmetric <then> and <if>.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-torso
# 
# content model: 
# DR Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval)
# KR Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML (Operator | And | Or | Negation | Naf | Atom | Equal )
# ECA Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
torso.attlist = xml.attlist
torso.content =
  inner-connective.content | extended-signature-predicate-sorts.content
torso.type = torso.content, torso.attlist
start |= torso
torso = element torso { torso.type }
#	    *** Rulebase ***
#	    A collection of rules that can be ordered or unordered, without or with duplicates.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rulebase
# 
#	    @prefix for default prefix definitions 
#	    @vocab for default vocab definitions
# 
#	    content model:
#	    DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval )* )
#	    KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
#	    PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal )* )
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )* )
# 
# attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Rulebase.attlist =
  group-formula-interface.attlist, node-element.attlist, xml.attlist
Rulebase.content =
  meta-roles.content,
  (element formula { formula-rulebase.type }
   | formula-rulebase.content)*
Rulebase.type = Rulebase.content, Rulebase.attlist
start |= Rulebase
Rulebase = element Rulebase { Rulebase.type }
# *** And ***
# A conjunctive expression, where <And>Atom</And> is equivalent to Atom.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-And
# 
# content model: 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
# KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* ) 
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Equal | Negation | Naf )* )
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )
# 
# Under Query, And may have attribute closure="existential"; 
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
And-inner.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
And-query.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
And.content =
  meta-roles.content,
  (element formula { formula-and-or.type }
   | formula-and-or.content)*
And-query.type = And.content, And-query.attlist
And-inner.type = And.content, And-inner.attlist
start |= And
And = element And { And-inner.type }
#       *** Or ***
#       A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
# 
#       See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Or
# 
#       content model: 
#       DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
#       KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* )
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Equal | Negation | Naf )* )
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )
# 
#       Under Query, Or may have attribute closure="existential"; 
# 
#       attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Or-query.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
Or-inner.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
Or.content =
  meta-roles.content,
  (element formula { formula-and-or.type }
   | formula-and-or.content)*
Or-query.type = Or.content, Or-query.attlist
Or-inner.type = Or.content, Or-inner.attlist
start |= Or
Or = element Or { Or-inner.type }
# *** formula ***
# The formula role of a conjunctive/disjunctive expression or a rulebase.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
# 
# content model (below And/Or): 
# DR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)
# KR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Equal )
# ECA Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
# 
# content model (below Rulebase): 
# DR Reaction RuleML (Operator | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval)
# KR Reaction RuleML (Operator | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
# PR Reaction RuleML (Operator | Atom | Rule | Equivalent | Equal )
# ECA Reaction RuleML (Operator | Atom | Rule | Equivalent |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)
# 
# Other (context-sensitive) versions of <formula> are in the
# performative and quantifier modules.
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
formula.attlist = edge-element.attlist, xml.attlist
formula-and-or.content =
  inner-connective.content | extended-signature-predicate-sorts.content
# In 1.0, Naf is not allowed in the consequent (second child) of Entails
# because Integrity uses of Entails call for classical Neg
# and Rulebase should not contain Naf in any other context (except Query).
# Alternatives would have been to use And in the consequent of Entails
# or to only allow Naf children within Rulebases that are used for Integrity
# and querying, but this would require making the role tags explicit (i.e.
# not skippable). Schematron could be used here to disallow Naf from other
# Rulebases.
formula-rulebase.content =
  element Implies { Implies.type }
  | Rule
  | element Equivalent { Equivalent.type }
  | outer-quantifier.content
  | outer-connective.content
  | extended-signature-predicate-sorts.content
formula-and-or.type = formula-and-or.content, formula.attlist
formula-rulebase.type = formula-rulebase.content, formula.attlist
# *** generic connective Operator ***
# 
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Operator
# 
#   content model: 
#	  DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval)* )
#	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)* ) 
#   PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal)* ) 
#   ECA Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)* )
# 
#   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
ConnectiveOperator.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
ConnectiveOperator.content =
  meta-roles.content,
  (element formula { formula-rulebase.type }
   | formula-rulebase.content)*
ConnectiveOperator.type =
  ConnectiveOperator.content, ConnectiveOperator.attlist
# *** Atom ***
#	A logical atom , i.e. an expression formed from a predicate
#	applied to a collection of its (logical) arguments.
#	Or a frame object with slots
# 
#	See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Atom
# 
#	content model:
#	in DR Reaction RuleML:
#	(
#		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
#		((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval)*, repo?) | repo), slot*, resl?
#	)
# 
#	in KR Reaction RuleML:
#	(
#		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
#		((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo?) | repo), slot*, resl?
#	)
# 
#	in PR Reaction RuleML:
#	(
#		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
#		((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex)*, repo?) | repo), slot*, resl?
#	)
# 
#	in ECA Reaction RuleML
#	(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
#		((arg | Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)*, repo?) | repo), slot*, resl?)
# 
#	however, the above content model is non-deterministic,
#	so it is (equivalently) restructured as follows:
# 
#	in DR Reaction RuleML:
#	(
#			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
#			( 
#				( 
#					((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?)
#					|
#					repo
#				),
#				slot*)?, 
#			resl?
#		)	
# 
#	in KR Reaction RuleML
#	(
#			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
#			( 
#				( 
#					((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?)
#					|
#					repo
#				),
#				slot*)?, 
#			resl?
#		)
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
#
Atom.attlist =
  formula-interface.attlist, node-element.attlist, xml.attlist
# These .extend groups, pointed to by Atom.content, are necessary
# for redefinition to be binary in bindatalog and to add rest
# variables in hornlog.
Atom-repo.extend = Atom-arg.extend | repo
Atom-arg.extend = (arg | arg.content)+, repo?
Atom-slots.extend1 = element slot { slot.type }*
Atom-slots.extend2 = resl?
Atom.content =
  meta-roles.content,
  degree?,
  (# operator optional for frame representation
   element op { op-atom.type }
   | op-atom.content)?,
  Atom-slots.extend1,
  Atom-repo.extend,
  Atom-slots.extend1,
  Atom-slots.extend2
Atom.type = Atom.content, Atom.attlist
start |= Atom
Atom = element Atom { Atom.type }
# *** op ***
# An operator expression including the relation of an atom.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op
# 
# content model (within Atom): (Rel)
# 
# Other (context-sensitive) versions of <op> are in the expr and holog modules.
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
op.attlist = xml.attlist
op-atom.content = Rel
op-atom.type = op-atom.content, op.attlist
start |= op
op = element op { op-atom.type }
# *** Rel ***
# A relation, i.e. a logical predicate, of an atom.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rel
# 
# content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
# 
# attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Rel.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
start |= Rel
Rel =
  element Rel {
    mixed { Rel.attlist }
  }
# *** degree ***
# 
# An optional uncertainty value (between 0.0 and 1.0)
# that may be assigned to facts and rules.
# 
# See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-degree
# 
# content model: (Data)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
degree.attlist = xml.attlist
degree.content = Data
degree.type = degree.content, degree.attlist
start |= degree
degree = element degree { degree.type }
# *** slot ***
# A user-defined slot consisting of a name (first position) and a filler (second position).
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-slot
# 
# content model:
# DR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval) )
# KR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation) )
# PR Reaction RuleML: ( (Ind|Data|Expr|Plex), (Ind|Data|Skolem|Var|Reify|Expr|Plex) )
# ECA Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action) )
# 
# attributes: @card?, @minCard?, @maxCard?, @weight?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
#
slot.attlist = card.attrib, weight.attrib, xml.attlist
slot-name.extend = extended-signature-function-sorts.content
slot.content = slot-name.extend, arg.content
slot.type = slot.content, slot.attlist
start |= slot
slot = element slot { slot.type }
#	    *** arg ***
#	    A role used for the positional arguments of a logical atom.
# 
#	    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
# 
#	    content model: 
#	    in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
#	    in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
#	    in PR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
#	    in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
arg.attlist = edge-element.attlist, xml.attlist
arg.content =
  Var | Skolem | Reify | extended-signature-function-sorts.content
arg.type = arg.content, arg.attlist
start |= arg
arg = element arg { arg.type }
#	    *** Ind ***
#	    An individual constant, as in predicate logic, which can also be considered to
#	    be a fixed argument like RDF resources.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Ind
# 
#	    content model: text
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Ind.attlist = term-interface.attlist, node-element.attlist, xml.attlist
start |= Ind
Ind =
  element Ind {
    mixed { Ind.attlist }
  }
# *** Data ***
# A fixed argument like RDF literals, allowing XML data.  It may be
# optionally associated with an XML Schema built-in datatype
# (see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
# using the built-in xsi:type attribute.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Data
# 
# content model: xs:anytype [optionally datatyped]
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
start |= Data
Data = element Data { xsd:string }
#	    *** Var ***
#	    A logical variable, as in logic programming.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Var
# 
#	    content model: text
# 
#	    @mode = + | - | ?; default is ?
# 
#       + input variable which must be bound
#     - output variable which must be free (unbound)
#     ? can be both input / bound or output / free
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Var.attlist = term-interface.attlist, node-element.attlist, xml.attlist
start |= Var
Var =
  element Var {
    mixed { Var.attlist }
  }
# *** Skolem ***
# A Skolem individual constant, like RDF's blank nodes.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Skolem
# 
# content model: text
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Skolem.attlist =
  term-interface.attlist, node-element.attlist, xml.attlist
start |= Skolem
Skolem =
  element Skolem {
    mixed { Skolem.attlist }
  }
# *** Reify ***
# Supports reification (a kind of instantiation or quasi-quotation)
# as needed by SWSL. It allows any RuleML tag available within the
# current sublanguage as content, treating it as a term for performing
# reasoning on.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Reify		
# 
# content model: (any valid RuleML formula)
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Reify.attlist =
  term-interface.attlist, node-element.attlist, xml.attlist
Reify.content =
  # <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/>
  
  # <Reify> only allows valid RuleML
  
  # <xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>
  element * { text }?
Reify.type = Reify.content, Reify.attlist
start |= Reify
Reify = element Reify { Reify.type }
#	    *** Expr ***
#	    A logical function of the form "f(...)" where f is a function name.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Expr
# 
#	    content model:
#	    DR Reaction RuleML:
#	    ( 		   
#	       meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
#	      (op|Fun), slot*, 
#   (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*,
#	      repo?, slot*, resl?
#	    )
# 
# KR Reaction RuleML:
#	    ( 		   
#	       meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
#	      (op|Fun), slot*, 
#   (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*,
#	      repo?, slot*, resl?
#	    )
# 
#	    PR Reaction RuleML:
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
#	      (op|Fun), slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl?		)
# 
#	    ECA Reaction RuleML:
#	    ( 		   
#	       meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op|Fun), slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)*, repo?, slot*, resl?
#	    )  
# 
#	    however, this is non-deterministic, so it is (equivalently) restructured as follows:
#	    DR Reaction RuleML:
#	    (
#	    meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun), slot*,
#		    ( 
#			    ( 
#				    ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo? )
#				    |
#				    repo
#			    ),
#			    slot*)? , 
#		    resl?
#	    )
#	    KR Reaction RuleML:
#			    (
#	    meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun), slot*,
#		    ( 
#			    ( 
#				    ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo? )
#				    |
#				    repo
#			    ),
#			    slot*)? , 
#		    resl?
#	    )
#	    Note the 'positionalized' normal form where the op role is only
#	    at the beginning of the Expr.
# 
#	    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Expr.attlist = term-interface.attlist, node-element.attlist, xml.attlist
Expr.content =
  meta-roles.content,
  (element op { op-Expr.type }
   | op-Expr.content),
  element slot { slot.type }*,
  ((arg | arg.content)+ | repo? | repo),
  element slot { slot.type }*,
  resl?
Expr.type = Expr.content, Expr.attlist
start |= Expr
Expr = element Expr { Expr.type }
# *** op ***
# An operator expression including the function name of an expression.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op
# 
# content model (within Expr): (Fun)
# 
# Other (context-sensitive) versions of <op> are in the atom and holog modules.
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

# the (empty) attribute list is declared in the atom module
op-Expr.content = Fun
op-Expr.type = op-Expr.content, op.attlist
#	    *** Fun ***
#	    A user-defined function name.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Fun
# 
# content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
# attributes: attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Fun.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
start |= Fun
Fun =
  element Fun {
    mixed { Fun.attlist }
  }
#	    *** Plex ***
#	    An unordered collection of arguments without a constructor.
# 
#	    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Plex
# 
#	    content model (within Atom, Plex, slot):
#	    DR Reaction RuleML:
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	      slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*, repo?, slot*, resl? )
# 
# KR Reaction RuleML
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	      slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Interval)*, repo?, slot*, resl? )
# 
#	    PR Reaction RuleML:
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	      slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl? )
# 
#	    ECA Reaction RuleML:
#	    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	      slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Atom|Event)*, repo?, slot*, resl? )
# 
#	    however, this is non-deterministic, so it is (equivalently) restructured as follows:
# 
#	    DR Reaction RuleML:
#	    (		
#	       meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	       slot*,
#		 (
#		    ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?, slot*, resl? )?
#		    |
#		 ( repo, slot*, resl? )
#		 |
#		 resl
#		 )
#	    )
# 
#	    KR Reaction RuleML:
#	    (		
#	       meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
#	       slot*,
#		 (
#		    ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?, slot*, resl? )?
#		    |
#		 ( repo, slot*, resl? )
#		 |
#		 resl
#		 )
#	    )
# 
#	    content model (within repo): 
#	    DR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval )*, repo? )
#	    KR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo? )
#	    PR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex )*, repo? )
#	    ECA Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action )*, repo? )
# 
#	    content model (within resl):
#	    DR/KR/PR/ECA/CEP Reaction RuleML: (slot*, resl? )
# 
#	    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Plex.attlist = term-interface.attlist, node-element.attlist, xml.attlist
Plex.content =
  meta-roles.content,
  element slot { slot.type }*,
  ((arg | arg.content)+
   | repo?
   | element slot { slot.type }*
   | resl?
   | repo
   | element slot { slot.type }*
   | resl?
   | resl)
Plex-repo.content = meta-roles.content, (arg | arg.content)*, repo?
Plex-resl.content =
  meta-roles.content,
  element slot { slot.type }*,
  resl?
Plex.type = Plex.content, Plex.attlist
Plex-repo.type = Plex-repo.content, Plex.attlist
Plex-resl.type = Plex-resl.content, Plex.attlist
start |= Plex
Plex = element Plex { Plex.type }
# *** repo ***
# A positional rest variable.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-repo
# 
# content model: (Var | Plex)
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
repo.attlist = xml.attlist
repo.content =
  Var
  | element Plex { Plex-repo.type }
repo.type = repo.content, repo.attlist
start |= repo
repo = element repo { repo.type }
# *** resl ***
# A slotted rest variable.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-resl		
# 
# content model: (Var | Plex)
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
resl.attlist = xml.attlist
resl.content =
  Var
  | element Plex { Plex-resl.type }
resl.type = resl.content, resl.attlist
start |= resl
resl = element resl { resl.type }
# *** Equal ***
# An equational formula consisting of two expressions.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal
# 
# content model:
# in DR Reaction RuleML:
# (
#   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?
#	(left, right) |
#	(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)  )
# )
# in KR Reaction RuleML:
# (
#   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,
#	(left, right) |
#	(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)  )
# )
# in PR Reaction RuleML:  (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	( (Ind | Data | Var | Skolem | Reify  | Expr | Plex ), (Ind | Data | Var | Skolem | Reify  | Expr | Plex ) ))
# in ECA Reaction RuleML:	(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)  )
# )		
# 
# attributes: @oriented?, @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Equal.attlist =
  oriented.attrib,
  formula-interface.attlist,
  node-element.attlist,
  xml.attlist
Equal.content =
  meta-roles.content,
  degree?,
  (left
   | right
   | # note that (right, left) is disallowed
     left.content
   | right.content)
Equal.type = Equal.content, Equal.attlist
start |= Equal
Equal = element Equal { Equal.type }
# *** left ***
# The left-hand side of an equational formula.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-left
# 
# content model: 
# in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
# in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
# in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
# in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
left.attlist = xml.attlist
left.content = arg.content
left.type = left.content, left.attlist
start |= left
left = element left { left.type }
# *** right***
# The right-hand side of an equational formula.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-right
# 
# content model: 
# in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
# in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
# in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
# in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)		
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
right.attlist = xml.attlist
right.content = arg.content
right.type = right.content, right.attlist
start |= right
right = element right { right.type }
curieOrIRI.datatype = curie.datatype | xsd:anyURI
curieOrAbsIRI.datatype = curie.datatype | absIRI.datatype
termOrCurieOrIRI.datatype = term.datatype | curie.datatype | xsd:anyURI
termOrCurieOrIRIs.datatype = list { termOrCurieOrIRI.datatype }
termOrCurieOrAbsIRI.datatype =
  term.datatype | curie.datatype | absIRI.datatype
termOrCurieOrAbsIRIs.datatype = list { termOrCurieOrAbsIRI.datatype }
absIRI.datatype = xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
curie.datatype =
  xsd:string {
    minLength = "1"
    pattern =
      "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
  }
term.datatype = xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
# *** @mode ***
# An attribute for optionally specifying the intended input-output constellations of formulas and terms with the
# following semantics:
# 
# "+" The formula/term is intended to be input
# "-" The formula/term is intended to be output
# "?" The formula/term is undefined (input or output)
# "[iri]" the formula/term's mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)  
# 
#	     By default the mode of formulas when used as conditions, constraints, queries and event patterns is "+" (input)
#	     and the mode of conclusions, answers and active actions is "-" (output). Variables are "?" (open) by default.
#	     optional attribute
# 
#	     See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40mode
mode.attrib =

  attribute mode {
    termOrCurieOrAbsIRI.datatype | vocab-modes.datatype
  }?
vocab-modes.datatype = "+" | "-" | "?"
# *** @safety ***
# 
#    restriction: interrupting, non-interrupting or transactional or
#    "[iri]" the formula/term's safety mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)
# 
#        default: non-interrupting 
#        optional attribute
# 
#        See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40safety
safety.attrib =
  attribute safety {
    termOrCurieOrAbsIRI.datatype | vocab-safety.datatype
  }?
vocab-safety.datatype =
  "non-interrupting" | "interrupting" | "transactional"
# *** @per ***
# An optinal attribute indicating how a formulas, terms and operators are interpreted.
# 
# Default for formulas is per "value" (truth valuation), for terms per "copy", for modal operators per "modal" and for actions/performatives by "effect".		
# In "reasoning" dialects the default for actions and events is per "value" and in active / messaging dialects it is per "effect".
# In "non-reified" representations as formulas default interpretation per "value" and in "reified" representations as term default interpretation is per copy. 
# 
# See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40per
per.attrib =
  attribute per { termOrCurieOrAbsIRI.datatype | vocab-per.datatype }?
vocab-per.datatype = "copy" | "value" | "effect" | "modal" | "open"
# *** @size  ***
# An attribute indicating the size of a counter		
# -1 = unbound / all
# 
# See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40size

#  
# 
#	replaced by card ?
# 
#	<xs:attributeGroup name="size.attrib">
#	<xs:attribute name="size" type="xs:int" use="optional" default="-1"/>
# </xs:attributeGroup>
# <xs:attributeGroup name="mapSize.attrib">
#	<xs:attribute name="mapSize" type="xs:int" use="optional" default="-1"/>
# </xs:attributeGroup>

#  *** @style ***
# 
#  The style attribute defines the styles of the intended semantics. 
#  Predefined semantics are "active", "reasoning", "messaging". 
#  Further intented semantics can be defined by semantic profiles internally in the <evaluation> role
#  or externally. They can be referenced by ther profile name (term) or resource locator (curie or absolute IRI).
# 
# restriction: active | messaging | reasoning | "[IRIs]" (vocabulary terms or curies or absolute IRIs)
# 
#       default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
#       optional attribute
# 
#       See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40style
style.datatype = termOrCurieOrAbsIRIs.datatype | vocab-style.datatype
vocab-style.datatype = "active" | "messaging" | "reasoning"
# *** @key ***
# 
# optinal unique local key on all knowledge formulas
# 
#      optinal attribute
# 
#      See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40key
key.attrib = attribute key { curieOrAbsIRI.datatype }?
# *** @keyref ***
# 
# corresponding reference to a unique local key
# 
#      optinal attribute
# 
#      http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40keyref
keyref.attrib = attribute keyref { curieOrAbsIRI.datatype }?
# *** @node ***
# An optional identification label for a Node, creating accessibility within
# the knowledge representation.
# This can help for representing prioritization between rules, for example. 
# The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
# such a label.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40node
# 
# content model: (curieOrAbsIRI.datatype)
node.attrib = attribute node { curieOrAbsIRI.datatype }?
# *** @type ***
# An attribute for optionally specifying a (user-defined) type.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40type
# 
# Note: In Reaction RuleML the type is changed to Term or Curie or absolute IRI to allow references
# to internal vocabulary terms (e.g. local sort signature definitions) and external vocabulary types (sorts) 
type.attrib = attribute type { termOrCurieOrAbsIRI.datatype }?
# *** @meta ***
# 
#  "[iri]" (term or curie or absolute IRI)
# 
#  Defines descriptive meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <meta> role)
#  or external metadata vocabularies.
# 
#      By default knowledge is contextually annotated by metadata about the source (@src([Locator])) and the name (@label([OID])),
#      with "Locator" being the source location (location of Reaction RuleML knowledge base in which the knowledge is defined) 
#      and OID being the implicitly or explicitly defined object identifer of the knowledge.
# 
#      optional attribute
# 
#      See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40meta
meta.attrib = attribute meta { termOrCurieOrAbsIRIs.datatype }?
# *** @scope ***
# 
#  restriction: global | local | private | "[iri]" (term or curie or absolute IRI)
# 
#  Defines a scope. Predefined scopes are global, local, private. 
#  Internal dynamic scopes defined by metadata views (defined in the <scope> role) can be references by the oid name term (<oid>)
#  and externally defined scopes by their IRI.
# 
#      default value: "global" for relations and functions and "local" for terms 
#      optional attribute
# 
#      See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40scope
scope-formula.attrib =
  attribute scope {
    termOrCurieOrAbsIRI.datatype | vocab-scope.datatype
  }?
scope-term.attrib =
  attribute scope {
    termOrCurieOrAbsIRI.datatype | vocab-scope.datatype
  }?
vocab-scope.datatype = "local" | "global" | "private"
# *** @arity ***
# An optional attribute for specifying the arity of a signature.
# The arity of constants / individual objects is zero.
# The arity of predicates and functions is the number of arguments they have.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40arity
arity.attrib = attribute arity { xsd:nonNegativeInteger }?
# *** @prefix ***
# 
# a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
# 
# See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40prefix
#
prefix.attrib = attribute prefix { prefix.datatype }?
prefix.datatype =
  xsd:string { minLength = "1" pattern = "([\i-[:]][\c-[:]]*)?" }
# *** @vocab ***
# 
# an IRI that defines the vocabulary mapping to use when a TERM is referenced in an attribute value.
# 
# See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40vocab
#
vocab.attrib = attribute vocab { xsd:anyURI }?
# *** @card @minCard @maxCard ***
# An attribute optionally specifying the cardinality.
# 
# "-1" = unbound
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40card
#	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40maxCard
#	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40minCard
card.attrib =
  attribute card { xsd:int }?,
  attribute maxCard { xsd:int }?,
  attribute minCard { xsd:nonNegativeInteger }?
# *** @weight ***
# An attribute optionally specifying a relative weight.
# The default is "1", i.e. all knowledge has the same weight of "1". 
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40weight		
weight.attrib =
  attribute weight {
    xsd:decimal { minInclusive = "0" maxInclusive = "1" }
  }?
# *** @direction ***
# An attribute indicating the intended direction of an implication rule's inferencing.
# default is bidirectional.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40direction
direction.attrib =
  attribute direction {
    termOrCurieOrAbsIRI.datatype | vocab-direction.datatype
  }?
vocab-direction.datatype = "forward" | "backward" | "bidirectional"
# *** @closure ***
# An attribute indicating how the contained free variables are quantified.
# default is universal closure.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40closure		
closure.attrib =
  attribute closure {
    termOrCurieOrAbsIRI.datatype | vocab-closure.datatype
  }?
vocab-closure.datatype = "universal" | "existential"
# *** @material ***
# An attribute indicating the kind of an implication rule.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40material
material.attrib =
 attribute material { "no" | "yes" }?
# *** @iri ***
# An attribute for referring to a Curie or absolute IRI.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40iri
iri.attrib = attribute iri { curieOrAbsIRI.datatype }?
# *** @index ***
# An optional attribute for specifying an ordering on roles.
# 
# Note: in Reaction RuleML @index is optional
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40index
index.attrib = attribute index { xsd:positiveInteger }?
# *** @oriented ***
# An attribute indicating whether an equation is oriented (directed)
# or unoriented (symmetric).
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40oriented
oriented.attrib =
  attribute oriented { "yes" | "no" }?
# 
# a group of attributes for all XML elements in Reaction RuleML
# 
# @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
# 
# @key and @keyref attributes for local syntactic modularization of the knowledge base
#
xml.attlist =
  prefix.attrib,
  key.attrib,
  keyref.attrib,
  attribute xml:base { text },
  attribute xml:id { text }
# 
# a group of attributes for all XML node elements (type elements) in Reaction RuleML
# 
# @meta?, @node?, @iri?, @vocab?
#
node-element.attlist =
  node.attrib, iri.attrib, vocab.attrib, meta.attrib
# 
# a group of attributes for all XML edge elements (role elements) in Reaction RuleML
# 
# @index?
#
edge-element.attlist = index.attrib
# 
# a group of attributes for the meta knowledge interface of all grouping formulas in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?  
# 
# attributes of grouping formulas are automatically inherited as default attributes to all formulas in the group.
group-formula-interface.attlist =
  formula-interface.attlist, material.attrib
# 
# a group of attributes for the meta knowledge interface of all knowledge formulas in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
# 
#
formula-interface.attlist =
  type.attrib,
  arity.attrib,
  card.attrib,
  weight.attrib,
  style.attrib,
  direction.attrib,
  scope-formula.attrib,
  closure.attrib,
  mode.attrib,
  per.attrib
# 
# a group of attributes for the meta knowledge interface of all terms in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?
#
term-interface.attlist =
  type.attrib,
  arity.attrib,
  card.attrib,
  weight.attrib,
  scope-term.attrib,
  mode.attrib,
  per.attrib
# 
# a group of attributes for the meta knowledge interface of all quantifiers in Reaction RuleML
# 
# @type?, @card?, @minCard?, @maxCard?, @style?, @scope?
quantifier-interface.attlist =
  type.attrib, card.attrib, style.attrib, scope-formula.attrib
# 
# a group of attributes for the meta knowledge interface of all connectives/operators in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
operator-interface.attlist =
  type.attrib,
  arity.attrib,
  card.attrib,
  weight.attrib,
  style.attrib,
  direction.attrib,
  scope-formula.attrib,
  mode.attrib,
  closure.attrib,
  per.attrib
# 
# a group of attributes for the meta knowledge interface of all action / performatives in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
action-interface.attlist =
  type.attrib,
  arity.attrib,
  card.attrib,
  weight.attrib,
  style.attrib,
  direction.attrib,
  safety.attrib,
  scope-formula.attrib,
  mode.attrib,
  closure.attrib,
  per.attrib
# 
# a group of attributes for the meta knowledge interface of all events in Reaction RuleML
# 
# @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
event-interface.attlist =
  type.attrib,
  arity.attrib,
  card.attrib,
  weight.attrib,
  style.attrib,
  direction.attrib,
  safety.attrib,
  scope-formula.attrib,
  mode.attrib,
  closure.attrib,
  per.attrib
# *** Rule ***
# The Rule element that provides the basic syntax for rules
# in Reaction RuleML.
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rule
# 
# content model: 
# 
#    In (temporal) DR Reaction RuleML:
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )
# 
#    In KR Reaction RuleML:
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)))
# 
#    In PR Reaction RuleML:
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (elseDo?, do, if) | (if, do, elseDo?)))
# 
#    in ECA Reaction RuleML:
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)? ) )
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )
# 
# 
#    in CEP Reaction RuleML:
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)* ) )
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( do )
#    ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )
# 
# 
# Rule has the following attributes:
#	  attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
Rule.attlist = formula-interface.attlist, material.attrib, xml.attlist
Rule.content = meta-roles.content, rule-implementation.content?
Rule.type = Rule.content, Rule.attlist
start |= Rule
Rule = element Rule { Rule.type }
# *** on ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-on
# 
# content model: 
# DR Reaction RuleMl: (  )
# KR Reaction RuleMl: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
# PR Reaction RuleML: ( )
# ECA Reaction RuleML: (Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operator)  
# CEP Reaction RuleML: (Receive | Answer | Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operator) 
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
on.attlist = xml.attlist, edge-element.attlist
on.content = event_group.content
on.type = on.content, on.attlist
start |= on
on = element on { on.type }
# *** if ***
# *** after ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-after
# 
# content model:   
# DR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
# KR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
# PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf  )    
# ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
# 
#    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
start |= after
after = element after { if.type }
#     *** then ***	
# *** else ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-else
# 
# content model: 
# DR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
# KR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation )
# PR Reaction RuleML: not used in PR Reaction RuleML (only in combination with DR)
# ECA Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
# 
#    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
start |= else
else = element else { then.type }
# *** do ***
# *** elseDo ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-do
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-elseDo
# 
# content model:  
# DR Reaction RuleML: (  )
# KR Reaction RuleML: ( Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation )
# PR Reaction RuleML: (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)
# ECA Reaction RuleML:  (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)
# CEP Reaction RuleML:  (Send | Consult | Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)
# 
#    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
do.attlist = xml.attlist, edge-element.attlist
do.content = action_group.content
do.type = do.content, do.attlist
start |= do
do = element do { do.type }
start |= elseDo
elseDo = element elseDo { do.type }
# *** Derivation Rule content model ***
#       ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
DerivationRule.content =
  else?
  | then
  | if
  | if
  | then
  | else?
  | if.content
  | then.content
  | then.content?
# *** Production Rule content model ***
# ((if, do, elseDo?) | (elseDo?, do, if))
ProductionRule.content = elseDo? | do | if | if | do | elseDo?
# *** Combined DR Production Rule content model ***
# Production Rule       Derivation Rule    Production Rule with conclusion   inverse Production Rule with conclusion 
# ((if, do, elseDo?) | (if, then, else) | (if, do, then?, elseDo?, else?) | (else?, elseDo?, then?, do, if))
DRProductionRule.content =
  else? | elseDo? | then? | do | if | if | do? | then? | elseDo? | else?
# *** Reaction Rule content model ***
# (on, (if?, then?, do?, after?,else?, elseDo?)? )
ReactionRule.content = on, if?, then?, do?, after?, else?, elseDo?
# *** Messaging Rule content model ***
# (do)
MessagingRule.content = do
#	*** Negation ***
#	A generic polymorphic negation
# 
#	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Negation
# 
#	It can be specialized by using
#	the @type attribute to specify the type of negation and/or 
#	the @iri attribute to point to an external definition of the negation
#	@key, @keyref, @node
# 
#	content model: 
#	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
#	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
#	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action) )
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
Negation.attlist =
  formula-interface.attlist, node-element.attlist, xml.attlist
Negation.content =
  meta-roles.content,
  (element formula { formula-negation.type }
   | formula-negation.content)
Negation.type = Negation.content, Negation.attlist
start |= Negation
Negation = element Negation { Negation.type }
formula-negation.attlist = xml.attlist
formula-negation.content =
  element Operator { ConnectiveOperator.type }
  | Equal
  | Negation
  | Neg
  | extended-signature-predicate-sorts.content
formula-negation.type =
  formula-negation.content, formula-negation.attlist
start |= formula
formula = element formula { formula-negation.type }
# *** Naf ***
# A "by default" negation of a logical atom (i.e. "weak" negation or
# negation-as-failure).
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Naf
# 
# content model: 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
# KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )  		
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
Naf.attlist = Negation.attlist
Naf.content = meta-roles.content, (weak | weak.content)
Naf.type = Naf.content, Naf.attlist
start |= Naf
Naf = element Naf { Naf.type }
# *** weak ***
# A role used for negation as failure.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-weak
# 
# content model:
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
# KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
# PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action ) )
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
weak.attlist = xml.attlist
weak.content = formula-negation.content
weak.type = weak.content, weak.attlist
start |= weak
weak = element weak { weak.type }
#	*** Neg ***
#	A classical negation of a logical atom (i.e. classical or "strong" negation).
# 
#	See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Neg
# 
#	content model:
#	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
#	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
#	PR Reaction RuleML: strong negation not supported by PR Reaction RuleML
#	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
Neg.attlist = Negation.attlist
Neg.content = meta-roles.content, (strong | strong.content)
Neg.type = Neg.content, Neg.attlist
start |= Neg
Neg = element Neg { Neg.type }
# *** strong ***
# A role used for classical negation.
# 
# See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-strong
# 
# content model: 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
# KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )	
# PR Reaction RuleML: strong negation not supported by PR Reaction RuleML 
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )	
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
strong.attlist = xml.attlist
strong.content = formula-negation.content
strong.type = strong.content, strong.attlist
start |= strong
strong = element strong { strong.type }
#     *** Quantifier ***
#     Explicit generic quantifier, where the quantifier name can be defined by the 
# @type attribute and the @iri attribute can point to an external definition
# of the quantifier.
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Quantifier
# 
# Format: "quantifier declare(Var)+ such that guard formula(...)?" 
# 
#     content model: 
#     DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
#     KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
# PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
# ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )?
# 
#     attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Quantifier.attlist =
  quantifier-interface.attlist, node-element.attlist, xml.attlist
Quantifier.content =
  meta-roles.content,
  (declare | Var)+,
  (element formula { formula-inner-quantifier.type }
   | formula-inner-quantifier.content)?
Quantifier.type = Quantifier.content, Quantifier.attlist
start |= Quantifier
Quantifier = element Quantifier { Quantifier.type }
# Exists
#     make the quantifier constraint restrictions ("such that") optional
# 
#     http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Exists
# 
#     DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
#     KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
# PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
# ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?
# 
#     attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Exists-quantifier.content =
  meta-roles.content,
  (declare | declare.content)+,
  (element formula { formula-inner-quantifier.type }
   | formula-inner-quantifier.content)?
Exists-quantifier.type = Exists-quantifier.content, Quantifier.attlist
# Forall
#     make the quantifier constraint restrictions ("such that") optional
# 
#     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Forall
# 
#     DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
#     KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
# PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
# ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?
# 
#     attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Forall-quantifier.content =
  meta-roles.content,
  (declare | declare.content)+,
  (element formula { formula-inner-quantifier.type }
   | formula-inner-quantifier.content)?
Forall-quantifier.type = Forall-quantifier.content, Quantifier.attlist
#        *** formula ***
#        The 'such that' guard formula role of a quantifier (<Forall> or <Exists>).
# 
#        See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
# 
#     DR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
# KR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
# PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf  ) 
# ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
# 
#        Other (context-sensitive) versions of <formula> are in the
#        connective and performative modules.
# 
#        attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
formula-inner-quantifier.content = guard.content
formula-inner-quantifier.type =
  formula-inner-quantifier.content, formula.attlist
#     *** Profile ***
#     Explicit generic semantic profile defining the intended semantics for knowledge interpretation, inference and execution. 
# 
#     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Profile
# 
#     The semantic profile can be
#   defined internally by the any content model (xs:any Element) or externally, where 
#   the optional @type attribute defines the name/type of the used sematics profile,
#   the optional @iri attribute points to an external definition of the semantics profile, and
#   the optional @mapDirection attribute indicates the default direction of the inference / execution.
#   the optional @mapClosure attribute indicates the default quantification.  Allowed values are "universal" and "existential".
#   the optional @mapMaterial attribute indicates the default quantification.  Allowed values are "universal" and "existential".
#   the optional @mapSafety attribute indicates if the execution / inference is transactional, interrupting, non-interrupting
#   the optional @mapSize attribute acts as a generic size boundary / counter in the operational semantic profiles    
# 
#     DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | content(xs:any*)  )*)
# KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens | content(xs:any*) )*)	
# PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal | content(xs:any*)  )*)
#     ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | content(xs:any*)  )*)   
# 
#     attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @safety?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
Profile.attlist =
  group-formula-interface.attlist, safety.attrib, node-element.attlist, xml.attlist
Profile.content =
  meta-roles.content,
  (element formula { formula-assert.type }
   | formula-assert.content
   | element content { profile_anycontent.type })*
Profile.type = Profile.content, Profile.attlist
start |= Profile
Profile = element Profile { Profile.type }
# *** content ***
# 
#    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
# 
# the optional @prefix and @vocab are used to define a prefix and a term mapping vocabulary for the XML content (see CURIE to IRI and term to IRI translation)
# content model:  (xs:any*)
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
profile_anycontent.attlist = xml.attlist
profile_anycontent.content = element * { text }*
profile_anycontent.type =
  profile_anycontent.content, profile_anycontent.attlist
#	*** Time ***
#	Explicit generic Time construct. 
# 
#	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Situation
# 
#	The time can be represented internally 
#       * with positional arguments <arg>, e.g., <arg>
# <Data xsi:type="xs:dateTime>2011-10-02T10:45:34-00:00</Data>
# </arg>
#       * with unpositional slots <slot>, e.g., <slot>
# <Ind>year</Ind>
# <Ind>2011</Ind>
# </slot>
# <slot>
# <Ind>month</Ind>
# <Ind>10</Ind>
# </slot>
#       * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
#       or externally, where the optional @iri attribute points to an external data definition of the time
#       The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
#       or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
#       Note: Time can be defined absolute or relative.
# 
#	content model: 
#	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#			((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
#				content(xs:any*)* ) ) 
#	KR Reaction RuleML:  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#				((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
#				content(xs:any*)* ) ) 
#	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#			((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
#				content(xs:any*)* ) ) 	
# 
#	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Time.attlist =
  formula-interface.attlist, node-element.attlist, xml.attlist
Time.content =
  meta-roles.content,
  (element slot { slot.type }*
   | resl?
   | ((element arg { arg_time.type }
       | time_primitives.content)+
      | repo?
      | repo)
   | element slot { slot.type }*
   | resl?
   | element content { time_anycontent.type }*)
Time.type = Time.content, Time.attlist
start |= Time
Time = element Time { Time.type }
# *** arg ***
# 
# Definition of the the arg role for Time
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
# 
# content model:  
# in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval | (After | Before | Any | Every | Timer | Operator))
# in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operator))
# in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator))  
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
arg_time.attlist = edge-element.attlist, xml.attlist
arg_time.content = time_primitives.content
arg_time.type = arg_time.content, arg_time.attlist
# *** content ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
# 
# @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
#    See CURIE to IRI and term to IRI translation
# 
# content model:  xs:any*
# 
# attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
time_anycontent.attlist = edge-element.attlist, xml.attlist
time_anycontent.content = element * { text }*
time_anycontent.type = time_anycontent.content, time_anycontent.attlist
#   *** Spatial ***
#   Explicit generic Spatial construct. 
# 
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Spatial
# 
#   The spatial can be represented internally 
# * with positional arguments <arg>
# * with unpositional slots <slot>
# * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
# or externally, where the optional @iri attribute points to an external data definition of the spatial
# The optional @type attribute defines the type of the spatial
# 
#   content model: 
#   DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#		  ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
#			  content(xs:any*)* ) ) 
#   KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#		  ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
#			  content(xs:any*)* ) ) 
#   PR Reaction RuleML: not used in PR Reaction RuleML
#   DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
#		  ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
#			  content(xs:any*)* ) ) 
# 
#   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Spatial.attlist =
  formula-interface.attlist, node-element.attlist, xml.attlist
Spatial.content =
  meta-roles.content,
  (element slot { slot.type }*
   | resl?
   | ((element arg { arg_spatial.type }
       | spatial_primitives.content)+
      | repo?
      | repo)
   | element slot { slot.type }*
   | resl?
   | element content { spatial_anycontent.type }*)
Spatial.type = Spatial.content, Spatial.attlist
start |= Spatial
Spatial = element Spatial { Spatial.type }
# *** arg ***
# 
# Definition of the the arg role for Spatial
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
# 
# content model:  
# in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))
# in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operator))
# in PR Reaction RuleML: not used in PR Reaction RuleML
# in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator)) 
# 
#  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
arg_spatial.attlist = edge-element.attlist, xml.attlist
arg_spatial.content = spatial_primitives.content
arg_spatial.type = arg_spatial.content, arg_spatial.attlist
# *** content ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
# 
# @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
#    See CURIE to IRI and term to IRI translation
# 
# content model:  xs:any*
# attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
spatial_anycontent.attlist = edge-element.attlist, xml.attlist
spatial_anycontent.content = element * { text }*
spatial_anycontent.type =
  spatial_anycontent.content, spatial_anycontent.attlist
#     *** Interval ***
#     Explicit generic Interval. 
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Interval
# 
#     The interval can be
#   defined internally by the any content model (xs:any Element) or externally, where 
#   the optional @type attribute defines the name/type of the interval,
#   the optional @iri attribute points to an external definition of the interval, and
#    An interval can be defined by Events, Actions,  Times, Spatials, and other Intervals can be typed by the 
#    interval ontology of Reaction RuleML (defining different types of intervals).
# 
#     content model: 
#     DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?])) 
#     KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?] )) 
# PR Reaction RuleML: not used in PR Reaction RuleML 
#     ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?])) 
# 
#     attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Interval.attlist =
  formula-interface.attlist, node-element.attlist, xml.attlist
Interval.content =
  meta-roles.content,
  (element arg { arg_interval.type }
   | interval_primitives.content
   | element content { interval_anycontent.type })?
Interval.type = Interval.content, Interval.attlist
start |= Interval
Interval = element Interval { Interval.type }
# *** arg ***
# 
# Definition of the the arg role for Intervals
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
# 
# content model:  
# in DR Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)
# in KR Reaction RuleML: (Time | Spatial | Interval |  Event | Action | Situation | Ind | Data | Skolem | Var | Reify | Expr | Plex | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator) )
# not used in PR Reaction RuleML     
# ECA Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)
# 
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
arg_interval.attlist = edge-element.attlist, xml.attlist
arg_interval.content = interval_primitives.content
arg_interval.type = arg_interval.content, arg_interval.attlist
# *** content ***
# 
#      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
# 
# content model:  xs:any*
# 
# @prefix is used to define a prefix and a term mapping vocabulary for the XML content
# See CURIE to IRI and term to IRI translation
# 
# attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
interval_anycontent.attlist = edge-element.attlist, xml.attlist
interval_anycontent.content = element * { text }*
interval_anycontent.type =
  interval_anycontent.content, interval_anycontent.attlist
# (After | Before | Any | Every | Timer | Operator)
spatial_temporal_algebra_group.content =
  After
  | Before
  | Every
  | Any
  | Timer
  | element Operator { Any.type }
# (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes | Operator)
interval_algebra_group.content =
  During
  | Overlaps
  | Starts
  | Precedes
  | Succeeds
  | Meets
  | element Equal { IntervalAlgebraOperator.type }
  | Finishes
  | element Operator { IntervalAlgebraOperator.type }
# *** at ***
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-at
# 
#     Note: In Situation Calculus the time is a situation (the history of occured situations as a finite sequence of the events/actions) 	
# 
# content model: 
# in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
# in ECA Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operator))
# in CEP Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operator))
# 
# attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
at.attlist = xml.attlist
at.content = time_primitives.content
at.type = at.content, at.attlist
start |= at
at = element at { at.type }
# *** After / Before***
# 
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-After
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Before
# 
# X after Y  / X before Y
# 
# Note: Y might be absolute or relative, e.g. "after 2 days", "2 days after X"  
# 
# content model: 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
#     KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] ))
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)?])) 	  
# 
#   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
After.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
After.content = Interval.content
After.type = After.content, After.attlist
start |= After
After = element After { After.type }
start |= Before
Before = element Before { After.type }
# *** Every ***
# 
# Every X 
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Every
# 
# Note:  X is often a relative, e.g. "every Monday", "every 2 meters" 
# 
# content model:
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 
#     KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation) ))
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 
# 
#   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Every.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
Every.content =
  meta-roles.content,
  (element arg { arg_interval.type }
   | interval_primitives.content
   | element content { interval_anycontent.type })?
Every.type = Every.content, Every.attlist
start |= Every
Every = element Every { Every.type }
# *** Any ***
# 
# Any X1,..Xn
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Any
# 
# e.g. "at any Saturday and Sunday"     
# 
# content model: 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 
#     KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg*] | content(xs:any)* | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)* ))
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 
# 
#   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Any.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
Any.content =
  meta-roles.content,
  (element arg { arg_interval.type }+
   | interval_primitives.content+
   | element content { interval_anycontent.type }+)?
Any.type = Any.content, Any.attlist
start |= Any
Any = element Any { Any.type }
# *** (Recurring) Timer ***
# 
# After X Every Y
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Recurring
# 
# Note: X and Y might be relative, e.g. after 1 hour every hour (recurring timer)
# 
# content model: 
# 
# DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
#     KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] )) 
# ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
Timer.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
Timer.content = Interval.content
Timer.type = Timer.content, Timer.attlist
start |= Timer
Timer = element Timer { Timer.type }
# *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes) ***
# 
# operator(Interval, Interval)
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-During
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Overlaps
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Starts
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Precedes
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Succeeds
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Meets
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Finishes
# 
# content model: 
# ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg] | [Interval, Interval])
# 
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
IntervalAlgebraOperator.attlist =
  operator-interface.attlist, node-element.attlist, xml.attlist
IntervalAlgebraOperator.content =
  meta-roles.content,
  (element arg { arg_interval.type }
   | element arg { arg_interval.type }
   | Interval
   | Interval)
IntervalAlgebraOperator.type =
  IntervalAlgebraOperator.content, IntervalAlgebraOperator.attlist
start |= During
During = element During { IntervalAlgebraOperator.type }
start |= Overlaps
Overlaps = element Overlaps { IntervalAlgebraOperator.type }
start |= Starts
Starts = element Starts { IntervalAlgebraOperator.type }
start |= Precedes
Precedes = element Precedes { IntervalAlgebraOperator.type }
start |= Succeeds
Succeeds = element Succeeds { IntervalAlgebraOperator.type }
start |= Meets
Meets = element Meets { IntervalAlgebraOperator.type }
start |= Finishes
Finishes = element Finishes { IntervalAlgebraOperator.type }
# *** Test ***
# A Test action/primitive that provides the syntax for Verification, Validation and Integrity (VVI) Testing.
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Test
# 
# An optional scope (<scope>) can be defined so that the test applies only to the scope (constructed view) on the knowledge base.
# 
# content model: 
#  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (vvi | Entails | TestItem | TestSuite)*)
# 
# Test has the following attributes:
# attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?   
Test.attlist =
  action-interface.attlist, node-element.attlist, xml.attlist
Test.content = meta-roles.content, (vvi | vvi.content)*
Test.type = Test.content, Test.attlist
start |= Test
Test = element Test { Test.type }
#  *** vvi ***
# 
#  vvi role - "verification, validation, integrity" tests
# 
#  see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-vvi
# 
#  content model: ( Entails | TestItem | TestSuite )
# 
#   vvi has the following attributes:
# attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
vvi.attlist = edge-element.attlist, xml.attlist
vvi.content = Entails | TestSuite | TestItem
vvi.type = vvi.content, vvi.attlist
start |= vvi
vvi = element vvi { vvi.type }
# *** testsbase ***
# 
# base role for the test assertion | consultation base
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-testbase
# 
# content model: ( Consult | Assert )
# 
#  base has the following attributes:
#     attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
testbase.attlist = xml.attlist
testbase.content = Consult | Assert
testbase.type = testbase.content, testbase.attlist
start |= testbase
testbase = element testbase { testbase.type }
# *** TestSuite ***
# A TestSuite consisting of the assertion | consultation base (test assertions) and the VVI tests (integrity entailments, test items or nested test suites 
# 
#   see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestSuite
# 
# content model: 
#  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (testbase | Consult | Assert), (vvi | Entails | TestItem | TestSuite)*)
# 
# TestSuite has the following attributes:
# attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
TestSuite.attlist =
  group-formula-interface.attlist, node-element.attlist, xml.attlist
TestSuite.content =
  meta-roles.content,
  (testbase | Assert | Consult)*,
  (vvi | vvi.content)*
TestSuite.type = TestSuite.content, TestSuite.attlist
start |= TestSuite
TestSuite = element TestSuite { TestSuite.type }
#  *** TestItem ***
#  TestItem describing one particular test consisting of the test act (typically a Query) and the expected result (the expected Answer with the predefined expected truth valuation (<degree>) and results/variable bindings)
# 
# see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestItem
# 
#  content model:
# 
#      ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act|Query|Assert|Retract|Update|Send|Receive|Consult|Test|Action), (expectedResult|Answer) )
# 
# attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
TestItem.attlist =
  group-formula-interface.attlist, node-element.attlist, xml.attlist
TestItem.content =
  meta-roles.content,
  (act | act.content),
  (expectedResult | expectedResult.content)
TestItem.type = TestItem.content, TestItem.attlist
start |= TestItem
TestItem = element TestItem { TestItem.type }
# *** expectedResult***
# 
# Definition of the the enclosed role for Send and Receive actions
# 
#  see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-expectedResult
# 
# content model:  
#  in CEP Reaction RuleML: (Answer)
# 
#  attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
#
expectedResult.attlist = xml.attlist
expectedResult.content = Answer
expectedResult.type = expectedResult.content, expectedResult.attlist
start |= expectedResult
expectedResult = element expectedResult { expectedResult.type }
# metadata group
# 
#    This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
# 
# content model: (meta*, scope*, guard )
#
metadata.content = meta*, scope*, guard*
# interface group
# 
# This internal group defines the interface signature and the evaluation semantics
# 
# content model: (evaluation*, signature* )
#
interface.content = evaluation*, signature*
# instance group
# 
# This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
# 
# content model: (qualification*, quantification*, oid? )
#
instance.content = qualification*, quantification*, oid?
# 
# An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
# 
# 
# content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
#
meta-roles.content =
  metadata.content, interface.content, instance.content
# 
# An internal group for the implementation of a rule in the Reaction RuleML language
# 
# 
# content model:
# 
# in DR Reaction RuleML: 
# 
# ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
#
rule-implementation.content = DerivationRule.content
# 
# An internal group for the query connectives in the Reaction RuleML language
# 
# content model: (Operator | And | Or | Negation | Naf | Neg | Equal)
#
query-connective.content =
  element Operator { ConnectiveOperator.type }
  | element And { And-query.type }
  | element Or { Or-query.type }
  | Negation
  | Naf
  | Neg
  | Equal
# 
# An internal group for the inner connectives in the Reaction RuleML language
# 
# 
# content model: (Operator | And | Or | Negation | Naf | Neg | Equal)
#
inner-connective.content =
  element Operator { ConnectiveOperator.type }
  | element And { And-inner.type }
  | element Or { Or-inner.type }
  | Negation
  | Naf
  | Neg
  | Equal
# 
# An internal group for the outer connectives in the Reaction RuleML language
# 
# 
# content model: (Operator | Negation | Neg | Equal )
#
outer-connective.content =
  element Operator { ConnectiveOperator.type }
  | Negation
  | Neg
  | Equal
# 
# An internal group for the query quantifiers in the Reaction RuleML language
# 
# content model: (Exists )
#
query-quantifier.content = Exists
# 
# An internal group for the inner quantifiers in the Reaction RuleML language
# 
# 
# content model: (Forall | Exists | Quantifier)
#
inner-quantifier.content =
  element Forall { Forall-quantifier.type }
  | element Exists { Exists-quantifier.type }
  | Quantifier
# 
# An internal group for the outer quantifiers in the Reaction RuleML language
# 
# 
# content model: ( Forall  )
#
outer-quantifier.content = Forall
# 
# An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
# 
# In the DR dialect of Reaction RuleML the signature contains the predicate sorts Time, Spatial and Interval
# 
# content model: (Atom | Time | Spatial | Interval)
#
extended-signature-predicate-sorts.content =
  element Atom { Atom.type }
  | Time
  | Spatial
  | Interval
# 
# An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
# 
# In the DR dialect of Reaction RuleML the signature contains the function sorts Time, Spatial and Interval
# 
# content model: (Ind | Data | Expr | Plex | Time | Spatial | Interval)
#
extended-signature-function-sorts.content =
  Ind | Data | Expr | Plex | Time | Spatial | Interval
# An internal group for the time primitives for interpretation as time
# content model: 
# in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operator))
time_primitives.content =
  arg.content | spatial_temporal_algebra_group.content
# An internal group for the spatial primitives for interpretation as spatial
# content model: 
# in DR Reaction RuleML ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operator))
spatial_primitives.content =
  arg.content | spatial_temporal_algebra_group.content
# Interval primitives
# content model: 
# in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))
interval_primitives.content =
  arg.content | interval_algebra_group.content
#  An internal group for events
# content model:
# 
# DR Reaction RuleML ( )
event_group.content = notAllowed
#  An internal group for actions
# content model:
# 
# DR Reaction RuleML ( )
action_group.content = notAllowed
# An internal group for the imports of the consult primitive
# content model: 
# in DR Reaction RuleML: (payload | RuleML | Reify | Var)
consult_imports.content = payload | payload.content
# An internal group for the performative primitives
# content model: 
# in DR Reaction RuleML: (Consult|Assert|Retract|Query|Answer|Test)
performative_primitives.content =
  Consult | Assert | Retract | Query | Answer | Test
# *** @style ***
# 
#  restriction: active | messaging | reasoning
#      default value: reasoning (in DR Reaction RuleML)
#      optional attribute
style.attrib = attribute style { style.datatype }?
