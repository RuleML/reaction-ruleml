<?xml version="1.0"?>
<grammar ns="http://ruleml.org/spec"
    xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Modifications, after creation using rngconv
    1. changed name of any(...) to anyLax
    2. change type of xml:id to NCName
  -->
    <start>
        <choice>
            <ref name="elseDo"/>
            <ref name="Implies"/>
            <ref name="Assert"/>
            <ref name="Naf"/>
            <ref name="after"/>
            <ref name="Data"/>
            <ref name="arg"/>
            <ref name="qualification"/>
            <ref name="repo"/>
            <ref name="Neg"/>
            <ref name="on"/>
            <ref name="Expr"/>
            <ref name="right"/>
            <ref name="signature"/>
            <ref name="else"/>
            <ref name="resl"/>
            <ref name="op"/>
            <ref name="Spatial"/>
            <ref name="quantification"/>
            <ref name="Profile"/>
            <ref name="declare"/>
            <ref name="Plex"/>
            <ref name="Fun"/>
            <ref name="Forall"/>
            <ref name="strong"/>
            <ref name="Exists"/>
            <ref name="then"/>
            <ref name="Or"/>
            <ref name="Negation"/>
            <ref name="Entails"/>
            <ref name="And"/>
            <ref name="torso"/>
            <ref name="Interval"/>
            <ref name="scope"/>
            <ref name="Query"/>
            <ref name="meta"/>
            <ref name="evaluation"/>
            <ref name="Retract"/>
            <ref name="Time"/>
            <ref name="Atom"/>
            <ref name="guard"/>
            <ref name="oid"/>
            <ref name="if"/>
            <ref name="Rulebase"/>
            <ref name="Equal"/>
            <ref name="do"/>
            <ref name="left"/>
            <ref name="slot"/>
            <ref name="Quantifier"/>
            <ref name="Reify"/>
            <ref name="Equivalent"/>
            <ref name="Rule"/>
            <ref name="Ind"/>
            <ref name="Rel"/>
            <ref name="degree"/>
            <ref name="Skolem"/>
            <ref name="weak"/>
            <ref name="RuleML"/>
            <ref name="Var"/>
            <ref name="act"/>
            <ref name="formula"/>
        </choice>
    </start>
    
    <!--
		*** RuleML ***
		The n-ary top-level of a RuleML document.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-RuleML
			 
	DR/KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Consult|Assert|Retract|Query|Answer|Test)* )
	PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Assert|Retract|Update|Consult|Query|Answer|Test|Action)* )
	ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Assert|Retract|Update|Query|Consult|Answer|Test|Action)* )
	CEP Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act|Assert|Retract|Update|Query|Answer|Send|Receive|Consult|Test|Action)* )
			
 	 Note: key and keyref object identifier are defined to be unique under the RuleML document root
 	 
 	 @vocab: an IRI that defines the mapping to use when a type term (e.g. a frame signature type) is referenced in an attribute value
 	 @prefix: a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
				
	attributes: @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="RuleML.attlist">
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="RuleML.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <ref name="act"/>
                <ref name="act.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="RuleML.type">
        <ref name="RuleML.content"/>
        <ref name="RuleML.attlist"/>
    </define>
    <start combine="choice">
<ref name="RuleML"/>
</start>
<define name="RuleML">
<element name="RuleML">
<ref name="RuleML.type"/>
        <!-- key object identifiers and key object references defined on the top level -->
        
            
            
        
        
            
            
        
    </element>
</define>
    <!--
    *** act ***
    The act role of the root element (<RuleML>).
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-act
    
    content model  
    DR/KR Reaction RuleML (Consult|Assert|Retract|Query|Answer|Test)
    PR Reaction RuleML (Assert|Retract|Update|Consult|Query|Answer|Test|Action)
    ECA Reaction RuleML (Assert|Retract|Update|Query|Consult|Answer|Test|Action)
    CEP Reaction RuleML (Assert|Retract|Update|Query|Answer|Send|Receive|Consult|Test|Action)
    
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="act.content">
        <choice>
            <ref name="performative_primitives.content"/>
        </choice>
    </define>
    <define name="act.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="act.type">
        <ref name="act.content"/>
        <ref name="act.attlist"/>
    </define>
    <start combine="choice">
<ref name="act"/>
</start>
<define name="act">
<element name="act">
<ref name="act.type"/>
</element>
</define>
    <!--
      *** Consult ***
      Consult (import) performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Consult
      
      dynamically "consults" (imports) knowledge resource, e.g. a message, documents or external resource (with the @iri attribute).
      
      content model:
 		 
 		 in DR Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in KR Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in PR Reaction RuleML  (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in ECA Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
	   in CEP Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ((payload | RuleML | Reify | Var) | (enclosed | Message))* )
	  
      Consult has the following attributes:
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 

    -->
    <define name="Consult.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Consult.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <ref name="consult_imports.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Consult.type">
        <ref name="Consult.content"/>
        <ref name="Consult.attlist"/>
    </define>
    <start combine="choice">
<ref name="Consult"/>
</start>
<define name="Consult">
<element name="Consult">
<ref name="Consult.type"/>
</element>
</define>
    <!--
     *** payload ***
     
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-payload
     
     content model: (RuleML | Reify | Var)
     
     attributes:  @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="payload.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="payload.content">
        <choice>
            <ref name="RuleML"/>
            <!-- a RuleML knowledge base -->
            <ref name="Reify"/>
            <!-- reified knowledge as payload -->
            <ref name="Var"/>
            <!-- for  binding knowledge to variables in meta programming -->
        </choice>
    </define>
    <define name="payload.type">
        <ref name="payload.content"/>
        <ref name="payload.attlist"/>
    </define>
    <start combine="choice">
<ref name="payload"/>
</start>
<define name="payload">
<element name="payload">
<ref name="payload.type"/>
</element>
</define>
    <!--
		*** Assert ***
		A KQML-like performative acting as a wrapper specifying that its content is
		asserted, making an 'implicit <Rulebase>' assumption.

		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Assert 

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )*)
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )*) 
    ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action  )*)

   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
  -->
    <define name="Assert.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Assert.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-assert.type"/>
</element>
                <ref name="formula-assert.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Assert.type">
        <ref name="Assert.content"/>
        <ref name="Assert.attlist"/>
    </define>
    <start combine="choice">
<ref name="Assert"/>
</start>
<define name="Assert">
<element name="Assert">
<ref name="Assert.type"/>
</element>
</define>
    <!--
		*** Retract ***
		A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
		content is to be deleted, making an 'implicit <Rulebase>' assumption.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Retract

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )*)
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )*) 
 		ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action  )*)   

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?   
  -->
    <define name="Retract.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Retract.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-assert.type"/>
</element>
                <ref name="formula-assert.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Retract.type">
        <ref name="Retract.content"/>
        <ref name="Retract.attlist"/>
    </define>
    <start combine="choice">
<ref name="Retract"/>
</start>
<define name="Retract">
<element name="Retract">
<ref name="Retract.type"/>
</element>
</define>
    <!--
      *** Update ***
      Update action
      
      See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Update
      
      content model:
      
      in PR Reaction RuleML
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal),
		 (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal)? )
		 
	  in ECA Reaction RuleML
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal |  Negation | Neg | Time | Spatial | Interval | Event | Action),
		 (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal |  Negation | Neg | Time | Spatial | Interval | Event | Action)? )
	  
      Update has the following attributes:
      @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
      
-->
    <define name="Update.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Update.content">
        
            <ref name="meta-roles.content"/>
            
                <choice>
                    <element name="formula">
<ref name="formula-assert.type"/>
</element>
                    <ref name="formula-assert.content"/>
                </choice>
                <optional>
<choice>
                    <element name="formula">
<ref name="formula-assert.type"/>
</element>
                    <ref name="formula-assert.content"/>
                </choice>
</optional>
            
        
    </define>
    <define name="Update.type">
        <ref name="Update.content"/>
        <ref name="Update.attlist"/>
    </define>
    <start combine="choice">
<ref name="Update"/>
</start>
<define name="Update">
<element name="Update">
<ref name="Update.type"/>
</element>
</define>
    <!--
		*** Query ***
		A KQML-like performative acting as a wrapper specifying that its content is
		queried, making an 'implicit <Rulebase>' assumption.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Query

		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
		PR Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )* )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Atom | Rulebase | And | Or | Entails |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )* )		

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="Query.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Query.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-query.type"/>
</element>
                <ref name="formula-query.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Query.type">
        <ref name="Query.content"/>
        <ref name="Query.attlist"/>
    </define>
    <start combine="choice">
<ref name="Query"/>
</start>
<define name="Query">
<element name="Query">
<ref name="Query.type"/>
</element>
</define>
    <!--
      *** Answer ***
      Answer performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Answer
      
      It delivers the answer to a Query . The answer is given in terms of solved formulas, e.g.
      
      as a <Rulebase> that contains just 'solved' equations with the variable bindings
      
	  <Rulebase>
  		<Equal>
<Var>x</Var>
<Ind>a</Ind>
</Equal>
  		<Equal>
<Var>y</Var>
<Ind>b</Ind>
</Equal>
  		<Equal>
<Var>z</Var>
<Ind>c</Ind>
</Equal>
	  </Rulebase>
	  
	  as ground fact <Atom> matching the query / goal 
	  
	  <Atom>
	  	<Rel>p</Rel>
	  	<Ind>a</Ind>
	  	<Ind>b</Ind>
	  	<Ind>c</Ind>
	  </Atom>
	  
	  as solved ground entailments <Entails> of the answer from the queried (ground or instantiated / forward chained) rule base  
	  
	  With the optional <degree> role a truth/uncertainty value (between 0.0 and 1.0; 
	  with the truth values "1" for true and "0" for false in two-valued logics and "0.5" for unknown in three-valued logics) can be assigned to the answer. 
	  
	  An answer maybe be also just referenced by the local @key-@keyref mechanism  
	  or by the optional @iri attribute, in case of externally published answers. 
	  
	  With the optional @type attribute an answer type can be specified. 
	  The @safety optionally defines if the answer (event) is interrupting or non-interrupting 
	  and the @card attribute optionally defines the number of results contained in an Answer.
	   
	  
      content model:
 		 
	  in CEP Reaction RuleML
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree? (formula | Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)* )
	  
      Answer has the following attributes:
    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
    -->
    <define name="Answer.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Answer.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<ref name="degree"/>
</optional>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-answer.type"/>
</element>
                <ref name="formula-answer.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Answer.type">
        <ref name="Answer.content"/>
        <ref name="Answer.attlist"/>
    </define>
    <start combine="choice">
<ref name="Answer"/>
</start>
<define name="Answer">
<element name="Answer">
<ref name="Answer.type"/>
</element>
</define>
    <!--
		*** formula ***
		The formula role of a performative (<Answer>).
		
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
		
		content model (below Answer formula): 
		(Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)
  		
		Other (context-sensitive) versions of <formula> are in the
		connective and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="formula-answer.content">
        <choice>
            <ref name="Rulebase"/>
            <ref name="Entails"/>
            <ref name="query-connective.content"/>
            <ref name="query-quantifier.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-answer.type">
        <ref name="formula-answer.content"/>
        <ref name="formula.attlist"/>
    </define>
    <!--
		*** formula ***
		The formula role of a performative (<Assert>, <Retract> or <Query>).

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula

		content model (below Assert formula): 
		DR Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval )
		KR Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval  | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
		PR Reaction RuleML (Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
		ECA Reaction RuleML (Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg |  Time | Spatial | Interval | Event | Action )
		
		content model (below Query): 
		DR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval )
		KR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
    PR Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )
		ECA Reaction RuleML (Operator | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action )    

		Other (context-sensitive) versions of <formula> are in the
		connective and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <define name="formula-assert.content">
        <choice>
            <ref name="Rulebase"/>
            <ref name="Implies"/>
            <ref name="Rule"/>
            <ref name="Equivalent"/>
            <ref name="Entails"/>
            <ref name="outer-quantifier.content"/>
            <ref name="outer-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-query.content">
        <choice>
            <ref name="Rulebase"/>
            <ref name="Entails"/>
            <ref name="query-connective.content"/>
            <ref name="query-quantifier.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-assert.type">
        <ref name="formula-assert.content"/>
        <ref name="formula.attlist"/>
    </define>
    <define name="formula-query.type">
        <ref name="formula-query.content"/>
        <ref name="formula.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for description-related
            RuleML       elements. File: desc_module.xsd Version: 1.0 Last Modification: 2012-05-17
            [Adrian Paschke]       This module declares the following RuleML elements:
            * meta            descriptive metadata        * scope           scope  (e.g. for scoped
            reasoning)        * guard         guard (e.g. for guard constraints in scoped reasoning)
            * evaluation      semantic profile        * signature       interface signature, pattern
            definition,       * qualification   qualification, e.g. priorities, validity, strategy
            * quantification  quantification       * oid              See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-05-17T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
  *** oid ***
  An optional object identifier for an atomic formula, expression or the unifed terms
  of the SWSL branch, as needed for PSOA semantics.
  Note that oids are not required to be unique within a rulebase.
  
  See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-oid
  
  content model: 
  in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
  in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
  in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex)
  in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
  
  attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="oid.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="oid.content">
        <choice>
            <ref name="Var"/>
            <ref name="Skolem"/>
            <ref name="Reify"/>
            <ref name="extended-signature-function-sorts.content"/>
        </choice>
    </define>
    <define name="oid.type">
        <ref name="oid.content"/>
        <ref name="oid.attlist"/>
    </define>
    <start combine="choice">
<ref name="oid"/>
</start>
<define name="oid">
<element name="oid">
<ref name="oid.type"/>
</element>
</define>
    <!-- 
     *** meta ***     
     
    An optional container for meta-knowledge about a Node.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-meta
    
	Used for descriptive Metadata annotations in Reaction RuleML
	
     content model: 
     in DR Reaction RuleML: ( Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
     in KR Reaction RuleML: ( Operator | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
     in PR Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
     in ECA Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )

     Multiple Metadata annotations are possible by repreating <meta>
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="meta.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="meta.content">
        <choice>
            <ref name="formula-assert.content"/>
        </choice>
    </define>
    <define name="meta.type">
        <ref name="meta.content"/>
        <ref name="meta.attlist"/>
    </define>
    <start combine="choice">
<ref name="meta"/>
</start>
<define name="meta">
<element name="meta">
<ref name="meta.type"/>
</element>
</define>
    <!--
     *** scope ***
     
     metadata-based scope definition defined over the metadata annotations and the qualifications annotations.
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-scope
     
     Note: scope reasoning in rules can use the metadata scopes to define a constructive view on the rules and facts in the KB.    
     The scoped rule/literal goal only applies in this scope (scoped reasoning/processing)
     
     For an implementation of scoped reasoning as a mechanism to dynamicaly create a scope (a constructive view)
     on the knowledge base and to do scoped reasoning on this scope see the Prova rule engine (http://prova.ws).
     
     Example:
     @src(kb1) @author("Adrian Paschke") @validity([2011-03-20, 2011-04-20]) @label(fact1) fact1(constant1).
     @src(kb2) @author("Alex Kozlenkov") @validity([2011-01-20, 2011-03-20]) @label(fact2) fact2(constant2).
     
     @src(rb1) @label(rule1) rule1(Y) :- @validity(VTime) @authors("Adrian Paschke") fact1(Y) [between(SysTime,VTime)] 
     
     In this example all knowledge is annotated with predefined (@src, ...) and user-defined metadata annotations (@author, @validity, ...). 
     User-defined metadata annotations can be arbitrary name/value pairs described as predicates. The literal "fact1" in the body
     of "rule1" is a scoped literal defining a scope over knowledge in the knowledge base with the scope constraints
     @validity and @author. If such knowledge is found in the KB the meta data value (an Interval) for @validity
     is bound to the variable "VTime" and used in the guard constraint [...] on the literal. The guard is stating that 
     the actual system time should be  within the validity interval. The second scope constraint is directly compared 
     to the constant value "Adrian Paschke".
     The sub-goal literal "fact1" in the rule condition is then applied only on the selected scope 
     (a constructive view on the overall knowledge base which is selected by the metadata scope of the literal) and not on the 
     overal knowledge. It is possible to define scopes for modules (e.g. sets of knowledge such as a rule-base/rule-set or 
     an knowledge updates (assert, retracts) by using the meta data identifier such as @src or @label. Such identifiers can
     be also used for transactional logics.
     
     In Reaction RuleML general metadata annotations (descriptive metadata) are defined under the <meta> tag role and
     qualifying metadata which qualify the rule (such as validity in the above example) are defined under the <qualification> tag.
     The @key attribute which defines a unique identifier for knowledge in the knowledge base is used for a 
     modular nested structuring of the knowledge base. The @key of e.g. <Assert key=""> or <Rulebase key=""> acts as module identifier 
     (which in Prova is denoted by the predefined @src metadata).
     
	 Scopes in Reaction RuleML can be defined within the <scope> role tag on descriptive metadata <meta> and qualifying metadata <qualification> as well as
	 on the unique identifier @key of the knowledge in the knowledge base (<Assert key="">, <Rulebase key="">, <Rule key="">, <Atom key="">)
	 by referencing it with the @keyref attribute.
	 
	 There is a nesting of scopes. Scopes defined on the more general level automatically apply to the inner knowledge. For instance, a scope
	 defined on the level of a <Rulebase> automatically applies to all goal literals of the <Rule>s in the rulebase. Inner scopes
	 overwrite the outer scope. For instance a scope defined on <Assert> becomes overwritten by an inner scope defined on a <Rule> which is within the
	 this asserted knowledge module. That is the goal literals within this rules are automatically applying the innter scope and not the outer scope.
	 
	 Note: the old approach which used <oid> to define a scope has been replaces by the key-keyref approach in Reaction RuleML 1.0
     
     Note: multiple scopes can be defined by repeating the <scope> role element
     Note: an empty scope either assumes the outer scope or an existing scope needs to be explicity referenced by keyref
     
     content model: 
     DR Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
     KR Reaction RuleML  ( Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
     PR Reaction RuleML  ( Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)?     
     ECA Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )

  attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="scope.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="scope.content">
        <choice>
            <optional>
<ref name="formula-query.content"/>
</optional>
        </choice>
    </define>
    <define name="scope.type">
        <ref name="scope.content"/>
        <ref name="scope.attlist"/>
    </define>
    <start combine="choice">
<ref name="scope"/>
</start>
<define name="scope">
<element name="scope">
<ref name="scope.type"/>
</element>
</define>
    <!--
     *** guard ***     
     
	guard constraints 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-guard
	
     content model: 
     in DR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
     in KR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     in PR Reaction RuleML: ( Operator | Atom | And | Or | Equal | Negation | Naf )
     in ECA Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)    
    
    attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="guard.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="guard.content">
        <choice>
            <ref name="if.content"/>
        </choice>
    </define>
    <define name="guard.type">
        <ref name="guard.content"/>
        <ref name="guard.attlist"/>
    </define>
    <start combine="choice">
<ref name="guard"/>
</start>
<define name="guard">
<element name="guard">
<ref name="guard.type"/>
</element>
</define>
    <!--
     *** evaluation ***
     
     The intended evaluation semantics, e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-evaluation
     
     Note: multiple Profiles can be defined by repreating the <evaluation> role element
     The Profiles can be defined externally by using the Profile attributes to point to it or internally by defining it in XML (xs:any)
     
     content model: (Profile )     
  
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="evaluation.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="evaluation.content">
        
            <ref name="Profile"/>
        
    </define>
    <define name="evaluation.type">
        <ref name="evaluation.content"/>
        <ref name="evaluation.attlist"/>
    </define>
    <start combine="choice">
<ref name="evaluation"/>
</start>
<define name="evaluation">
<element name="evaluation">
<ref name="evaluation.type"/>
</element>
</define>
    <!--
     *** signature ***
     
     The signature defines the signature of knowledge (formula and terms) with optional input / output mode declarations. The signature declaration can act as public interface and
	can be published together with the intended evaluation semantics. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-signature
	
	Note: In PR, RR and CEP reaction rules the signature is extended with events and actions
	for defining the event templates (i.e. the event form / event descriptor which corresponds to the event type/class. The event template is used for
	pattern machting, i.e. in the on part of a reaction rule it triggers the reaction rule if the template matches with required event instances, which are
	instantiations of the event type / class to which make up the required properties of the event template.
		
	Multiple signatures are possible by repreating the <signature> element
	
     content model: 
     DR Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
     KR Reaction RuleML  ( Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
     PR Reaction RuleML  ( Operator | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)? 
     ECA Reaction RuleML  ( (Operator | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )         

  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="signature.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="signature.content">
        <choice>
            <ref name="formula-query.content"/>
        </choice>
    </define>
    <define name="signature.type">
        <ref name="signature.content"/>
        <ref name="signature.attlist"/>
    </define>
    <start combine="choice">
<ref name="signature"/>
</start>
<define name="signature">
<element name="signature">
<ref name="signature.type"/>
</element>
</define>
    <!--
     *** qualification ***
     
    Definition of the qualification (qualifying metadata), e.g. validity time, priorities, etc.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-qualification
     
    Note: the qualification can be also defined as a situation  <Situation> in KR Reaction RuleML 
	A situation could be also modelled as a changeable situation called fluent (in the KR dialect of Reaction RuleML),
	which changes its truth value depending on the context (context can be time, events/actions which 
	initiate/terminate the changeable situation, or a history of occured events/actions which leads to an occured situation
	as context for the truth changes of the fluent.
	
	That would mean the qualification of the rule changes depending on the situation (the truth value of the fluent in KR RuleML)
	
     content model: 
     in DR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
     in KR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
     in PR Reaction RuleML: ( Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
     in ECA Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )
  
  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="qualification.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="qualification.content">
        <choice>
            <ref name="formula-assert.content"/>
        </choice>
    </define>
    <define name="qualification.type">
        <ref name="qualification.content"/>
        <ref name="qualification.attlist"/>
    </define>
    <start combine="choice">
<ref name="qualification"/>
</start>
<define name="qualification">
<element name="qualification">
<ref name="qualification.type"/>
</element>
</define>
    <!--
     *** quantification ***
     
     Definition of the quantifier. 
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-quantification
     
     content model: (Forall | Exists | Quantifier)
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
          
-->
    <define name="quantification.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="quantification.content">
        <choice>
            <ref name="inner-quantifier.content"/>
        </choice>
    </define>
    <define name="quantification.type">
        <ref name="quantification.content"/>
        <ref name="quantification.attlist"/>
    </define>
    <start combine="choice">
<ref name="quantification"/>
</start>
<define name="quantification">
<element name="quantification">
<ref name="quantification.type"/>
</element>
</define>
    <!-- extended descriptors in Reaction RuleML -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML quantifiers. File:
            quantifier_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares
            the       following RuleML elements: * Forall * Exists * declare * formula See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Forall ***
		Explicit universal quantifier.
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-Forall

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens ) )
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action ) )		

    attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
  -->
    <define name="Forall.attlist">
        <ref name="quantifier-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Forall.content">
        
            <ref name="meta-roles.content"/>
            <oneOrMore>
<choice>
                <ref name="declare"/>
                <ref name="declare.content"/>
            </choice>
</oneOrMore>
            <choice>
                <element name="formula">
<ref name="formula-forall.type"/>
</element>
                <ref name="formula-forall.content"/>
            </choice>
        
    </define>
    <define name="Forall.type">
        <ref name="Forall.content"/>
        <ref name="Forall.attlist"/>
    </define>
    <start combine="choice">
<ref name="Forall"/>
</start>
<define name="Forall">
<element name="Forall">
<ref name="Forall.type"/>
</element>
</define>
    <!--
		*** Exists ***
		Explicit existential quantifier.

		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-Exists

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens) )		
    PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operator | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) )    
 
    attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="Exists.attlist">
        <ref name="quantifier-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Exists.content">
        
            <ref name="meta-roles.content"/>
            <oneOrMore>
<choice>
                <ref name="declare"/>
                <ref name="declare.content"/>
            </choice>
</oneOrMore>
            <choice>
                <element name="formula">
<ref name="formula-exists.type"/>
</element>
                <ref name="formula-exists.content"/>
            </choice>
        
    </define>
    <define name="Exists.type">
        <ref name="Exists.content"/>
        <ref name="Exists.attlist"/>
    </define>
    <start combine="choice">
<ref name="Exists"/>
</start>
<define name="Exists">
<element name="Exists">
<ref name="Exists.type"/>
</element>
</define>
    <!--
		*** declare ***
		A role used for variables declared within a quantifier.
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-declare

		content model: ( Var )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="declare.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="declare.content">
        
            <ref name="Var"/>
        
    </define>
    <define name="declare.type">
        <ref name="declare.content"/>
        <ref name="declare.attlist"/>
    </define>
    <start combine="choice">
<ref name="declare"/>
</start>
<define name="declare">
<element name="declare">
<ref name="declare.type"/>
</element>
</define>
    <!--
		*** formula ***
		The formula role of a quantifier (<Forall> or <Exists>).
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-formula
		
		content model (below Forall): 
		DR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action)

		content model (below Exists): 
		DR Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Exists  | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)		
		
		Other (context-sensitive) versions of <formula> are in the
		connective and performative modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="formula-forall.content">
        <choice>
            <ref name="Implies"/>
            <ref name="Rule"/>
            <ref name="Equivalent"/>
            <ref name="outer-quantifier.content"/>
            <ref name="outer-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-forall.type">
        <ref name="formula-forall.content"/>
        <ref name="formula.attlist"/>
    </define>
    <define name="formula-exists.content">
        <choice>
            <ref name="query-quantifier.content"/>
            <ref name="query-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-exists.type">
        <ref name="formula-exists.content"/>
        <ref name="formula.attlist"/>
    </define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML connectives. File:
            connective_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This
            module       declares the following RuleML elements and attributes: * Implies * if *
            then * Entails *       Equivalent * torso * Rulebase * And * Or * formula        See
            http://www.ruleml.org/modularization for details       about this modularization
            approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!-- necessary for schematron -->
    <!-- 
	<xs:appinfo>
		
		<ns prefix="r" uri="http://ruleml.org/spec"/>
	</xs:appinfo> 
	-->
    <!--
		*** Implies ***
		An implication rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Implies

		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (then, if) | (if, then) | ( (Atom | And | Or | Equal), (Atom | Equal) ) )

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

  -->
    <define name="Implies.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="material.attrib"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Implies.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                
                    <ref name="then"/>
                    <ref name="if"/>
                
                
                    <ref name="if"/>
                    <ref name="then"/>
                
                
                    <ref name="if.content"/>
                    <ref name="then.content"/>
                
            </choice>
        
    </define>
    <define name="Implies.type">
        <ref name="Implies.content"/>
        <ref name="Implies.attlist"/>
    </define>
    <start combine="choice">
<ref name="Implies"/>
</start>
<define name="Implies">
<element name="Implies">
<ref name="Implies.type"/>
</element>
</define>
    <!-- 
		*** if ***
		The if of an implication rule containing the premise(s),
		also known as the "antecedent" or "if" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if

		content model: 
		DR Reaction RuleML (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
		KR Reaction RuleML (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf ) 
		ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="if.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="if.content">
        <choice>
            <ref name="inner-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="if-entails.content">
        <choice>
            <ref name="Rulebase"/>
        </choice>
    </define>
    <define name="if.type">
        <ref name="if.content"/>
        <ref name="if.attlist"/>
    </define>
    <define name="if-entails.type">
        <ref name="if-entails.content"/>
        <ref name="if.attlist"/>
    </define>
    <start combine="choice">
<ref name="if"/>
</start>
<define name="if">
<element name="if">
<ref name="if.type"/>
</element>
</define>
    <!--
		*** then ***
		The then of an implication rule containing the conclusion,
		also known as the "consequent" or "then" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then

		content model: 
		DR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML does not support "then"  (except in combination with DR/KR Reaction RuleML)
		ECA Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="then.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="then.content">
        <choice>
            <ref name="outer-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="then-entails.content">
        <choice>
            <ref name="Rulebase"/>
        </choice>
    </define>
    <define name="then.type">
        <ref name="then.content"/>
        <ref name="then.attlist"/>
    </define>
    <define name="then-entails.type">
        <ref name="then-entails.content"/>
        <ref name="then.attlist"/>
    </define>
    <start combine="choice">
<ref name="then"/>
</start>
<define name="then">
<element name="then">
<ref name="then.type"/>
</element>
</define>
    <!--
		*** Entails ***
		Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
		Kowalski/Bowen's object/meta-level-amalgamated logic).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Entails
		
		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (if | Rulebase), (then | Rulebase) )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Entails.attlist">
        <ref name="group-formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Entails.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                <element name="if">
<ref name="if-entails.type"/>
</element>
                <ref name="if-entails.content"/>
            </choice>
            <choice>
                <element name="then">
<ref name="then-entails.type"/>
</element>
                <ref name="then-entails.content"/>
            </choice>
        
    </define>
    <define name="Entails.type">
        <ref name="Entails.content"/>
        <ref name="Entails.attlist"/>
    </define>
    <start combine="choice">
<ref name="Entails"/>
</start>
<define name="Entails">
<element name="Entails">
<ref name="Entails.type"/>
</element>
</define>
    <!--
		*** Equivalent ***
		An equivalence expression, which is "syntactic sugar" for a pair
		of conjoined converse implication rules.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equivalent

		content model: 		
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval) ) ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens), 
		                      (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens) ) ) )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Negation | Naf | Atom | Equal), (Operator | And | Or | Negation | Naf | Atom | Equal ) ) ) )                     
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
		CEP Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="Equivalent.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="material.attrib"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Equivalent.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                
                    <choice>
                        <ref name="torso"/>
                        <ref name="torso.content"/>
                    </choice>
                    <choice>
                        <ref name="torso"/>
                        <ref name="torso.content"/>
                    </choice>
                
                 
            </choice>
        
    </define>
    <define name="Equivalent.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<pattern name="Equivalent">
					<rule context="r:Equivalent[count( descendant::r:Equal/r:Expr | descendant::r:Equal/r:left/r:Expr )=2]">
						<assert test=
							"( descendant::r:Equal[1]/descendant::r:Fun[@per = 'copy']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'copy'] )
							 or
							 ( descendant::r:Equal[1]/descendant::r:Fun[@per = 'open']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'open'] )">
						  Equalities within an equivalence expression must either both be interpreted or both uninterpreted.
						</assert>
					</rule>
				</pattern>
			</xs:appinfo>
		</xs:annotation>
                -->
        <ref name="Equivalent.content"/>
        <ref name="Equivalent.attlist"/>
    </define>
    <start combine="choice">
<ref name="Equivalent"/>
</start>
<define name="Equivalent">
<element name="Equivalent">
<ref name="Equivalent.type"/>
</element>
</define>
    <!--
		*** torso ***
		A symmetric role used in an equivalence expression combining
		the asymmetric <then> and <if>.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-torso

		content model: 
		DR Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operator | And | Or | Negation | Naf | Atom | Equal )
		ECA Reaction RuleML (Operator | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="torso.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="torso.content">
        <choice>
            <ref name="inner-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="torso.type">
        <ref name="torso.content"/>
        <ref name="torso.attlist"/>
    </define>
    <start combine="choice">
<ref name="torso"/>
</start>
<define name="torso">
<element name="torso">
<ref name="torso.type"/>
</element>
</define>
    <!--
		*** Rulebase ***
		A collection of rules that can be ordered or unordered, without or with duplicates.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rulebase
		
		@prefix for default prefix definitions 
		@vocab for default vocab definitions
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal )* )
    ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )* )
    
    attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <define name="Rulebase.attlist">
        <ref name="group-formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Rulebase.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-rulebase.type"/>
</element>
                <ref name="formula-rulebase.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Rulebase.type">
        <ref name="Rulebase.content"/>
        <ref name="Rulebase.attlist"/>
    </define>
    <start combine="choice">
<ref name="Rulebase"/>
</start>
<define name="Rulebase">
<element name="Rulebase">
<ref name="Rulebase.type"/>
</element>
</define>
    <!--
		*** And ***
		A conjunctive expression, where <And>Atom</And> is equivalent to Atom.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-And
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* ) 
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Equal | Negation | Naf )* )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )

		Under Query, And may have attribute closure="existential"; 
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="And-inner.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="And-query.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="And.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-and-or.type"/>
</element>
                <ref name="formula-and-or.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="And-query.type">
        <ref name="And.content"/>
        <ref name="And-query.attlist"/>
    </define>
    <define name="And-inner.type">
        <ref name="And.content"/>
        <ref name="And-inner.attlist"/>
    </define>
    <start combine="choice">
<ref name="And"/>
</start>
<define name="And">
<element name="And">
<ref name="And-inner.type"/>
</element>
</define>
    <!--
		*** Or ***
		A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Or
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* )
	  PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Equal | Negation | Naf )* )
	  ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )
		
		Under Query, Or may have attribute closure="existential"; 
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Or-query.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Or-inner.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Or.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-and-or.type"/>
</element>
                <ref name="formula-and-or.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Or-query.type">
        <ref name="Or.content"/>
        <ref name="Or-query.attlist"/>
    </define>
    <define name="Or-inner.type">
        <ref name="Or.content"/>
        <ref name="Or-inner.attlist"/>
    </define>
    <start combine="choice">
<ref name="Or"/>
</start>
<define name="Or">
<element name="Or">
<ref name="Or-inner.type"/>
</element>
</define>
    <!--
		*** formula ***
		The formula role of a conjunctive/disjunctive expression or a rulebase.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula

		content model (below And/Or): 
		DR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Equal )
		ECA Reaction RuleML (Operator | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
		
		content model (below Rulebase): 
		DR Reaction RuleML (Operator | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval)
		KR Reaction RuleML (Operator | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operator | Atom | Rule | Equivalent | Equal )
		ECA Reaction RuleML (Operator | Atom | Rule | Equivalent |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)
		
		Other (context-sensitive) versions of <formula> are in the
		performative and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="formula.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="formula-and-or.content">
        <choice>
            <ref name="inner-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <!--
		In 1.0, Naf is not allowed in the consequent (second child) of Entails
		because Integrity uses of Entails call for classical Neg
		and Rulebase should not contain Naf in any other context (except Query).
		Alternatives would have been to use And in the consequent of Entails
		or to only allow Naf children within Rulebases that are used for Integrity
		and querying, but this would require making the role tags explicit (i.e.
		not skippable). Schematron could be used here to disallow Naf from other
		Rulebases.
	-->
    <define name="formula-rulebase.content">
        <choice>
            <element name="Implies">
<ref name="Implies.type"/>
</element>
            <ref name="Rule"/>
            <element name="Equivalent">
<ref name="Equivalent.type"/>
</element>
            <ref name="outer-quantifier.content"/>
            <ref name="outer-connective.content"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-and-or.type">
        <ref name="formula-and-or.content"/>
        <ref name="formula.attlist"/>
    </define>
    <define name="formula-rulebase.type">
        <ref name="formula-rulebase.content"/>
        <ref name="formula.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       generic connective operator module of
            Reaction RuleML.     This is the XML Schema connective operator module for Reaction
            RuleML.    File: connective_operator_module.xsd    Version: 1.0    Last Modification:
            2011-03-22     This schema declares the following Reaction RuleML elements and
            attributes:      * Operator (Connective)        The approach is modelled after that used
            in "Modularization of XHTML in XML Schema"    WD
            [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T29:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
      *** generic connective Operator ***
      
      	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Operator
      
      	content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)* ) 
        PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal)* ) 
        ECA Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)* )
        
        attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="ConnectiveOperator.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="ConnectiveOperator.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-rulebase.type"/>
</element>
                <ref name="formula-rulebase.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="ConnectiveOperator.type">
        <ref name="ConnectiveOperator.content"/>
        <ref name="ConnectiveOperator.attlist"/>
    </define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML atoms. File:
            atom_module.xsd Version: 1.0 Last Modification: 2012-02-21 This module declares
            the following RuleML elements and attributes: * Atom * op * Rel * degree See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
        *** Atom ***
		A logical atom , i.e. an expression formed from a predicate
		applied to a collection of its (logical) arguments.
		Or a frame object with slots

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Atom
	
		content model:
		in DR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval)*, repo?) | repo), slot*, resl?
		)
		
		in KR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo?) | repo), slot*, resl?
		)
		
		in PR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex)*, repo?) | repo), slot*, resl?
		)
		
		in ECA Reaction RuleML
		(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)*, repo?) | repo), slot*, resl?)
		
		however, the above content model is non-deterministic,
		so it is (equivalently) restructured as follows:
		
		in DR Reaction RuleML:
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)	
			
		in KR Reaction RuleML
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	
	-->
    <define name="Atom.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <!--
		These .extend groups, pointed to by Atom.content, are necessary
		for redefinition to be binary in bindatalog and to add rest
		variables in hornlog.
	-->
    <define name="Atom-repo.extend">
        <choice>
            <ref name="Atom-arg.extend"/>
            <ref name="repo"/>
        </choice>
    </define>
    <define name="Atom-arg.extend">
        
            <oneOrMore>
<choice>
                <ref name="arg"/>
                <ref name="arg.content"/>
            </choice>
</oneOrMore>
            <optional>
<ref name="repo"/>
</optional>
        
    </define>
    <define name="Atom-slots.extend1">
        
            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
        
    </define>
    <define name="Atom-slots.extend2">
        
            <optional>
<ref name="resl"/>
</optional>
        
    </define>
    <define name="Atom.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<ref name="degree"/>
</optional>
            <optional>
<choice>
                <!-- operator optional for frame representation -->
                <element name="op">
<ref name="op-atom.type"/>
</element>
                <ref name="op-atom.content"/>
            </choice>
</optional>
            <ref name="Atom-slots.extend1"/>
            <optional>
<choice>
                
                    <ref name="Atom-repo.extend"/>
                    <ref name="Atom-slots.extend1"/>
                
            </choice>
</optional>
            <ref name="Atom-slots.extend2"/>
        
    </define>
    <define name="Atom.type">
        <ref name="Atom.content"/>
        <ref name="Atom.attlist"/>
    </define>
    <start combine="choice">
<ref name="Atom"/>
</start>
<define name="Atom">
<element name="Atom">
<ref name="Atom.type"/>
</element>
</define>
    <!--
		*** op ***
		An operator expression including the relation of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op

		content model (within Atom): (Rel)
		
		Other (context-sensitive) versions of <op> are in the expr and holog modules.
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="op.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="op-atom.content">
        
            <ref name="Rel"/>
        
    </define>
    <define name="op-atom.type">
        <ref name="op-atom.content"/>
        <ref name="op.attlist"/>
    </define>
    <start combine="choice">
<ref name="op"/>
</start>
<define name="op">
<element name="op">
<ref name="op-atom.type"/>
</element>
</define>
    <!--
		*** Rel ***
		A relation, i.e. a logical predicate, of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rel
		
		content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
		
		attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Rel.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Rel.content">
        <text/>
    </define>
    <define name="Rel.type">
        <ref name="Rel.content"/>
        <ref name="Rel.attlist"/>
    </define>
    <start combine="choice">
<ref name="Rel"/>
</start>
<define name="Rel">
<element name="Rel">
<ref name="Rel.type"/>
</element>
</define>
    <!-- 
		*** degree ***

		An optional uncertainty value (between 0.0 and 1.0)
		that may be assigned to facts and rules.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-degree

		content model: (Data)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="degree.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="degree.content">
        
            <ref name="Data"/>
        
    </define>
    <define name="degree.type">
        <ref name="degree.content"/>
        <ref name="degree.attlist"/>
    </define>
    <start combine="choice">
<ref name="degree"/>
</start>
<define name="degree">
<element name="degree">
<ref name="degree.type"/>
</element>
</define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML slots. File:
            slot_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares the
            following       RuleML element and attributes: * slot        See
            http://www.ruleml.org/modularization for details about this modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-16T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** slot ***
		A user-defined slot consisting of a name (first position) and a filler (second position).
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-slot

		content model:
		DR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval) )
		KR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation) )
		PR Reaction RuleML: ( (Ind|Data|Expr|Plex), (Ind|Data|Skolem|Var|Reify|Expr|Plex) )
		ECA Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action) )
		
		attributes: @card?, @minCard?, @maxCard?, @weight?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
		
	-->
    <define name="slot.attlist">
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="slot-name.extend">
        <choice>
            <ref name="extended-signature-function-sorts.content"/>
        </choice>
    </define>
    <define name="slot.content">
        
            <ref name="slot-name.extend"/>
            <ref name="arg.content"/>
        
    </define>
    <define name="slot.type">
        <ref name="slot.content"/>
        <ref name="slot.attlist"/>
    </define>
    <start combine="choice">
<ref name="slot"/>
</start>
<define name="slot">
<element name="slot">
<ref name="slot.type"/>
</element>
</define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML terms. File:
            term_module.xsd Version: 1.0 Last Modification: 2012-04-03 This module declares the
            following       RuleML elements and attributes: * arg * Ind * Data * Var * Skolem *
            Reify as       well as including a number of complex types for use in expicitly-typed
            data Nodes. See       http://www.ruleml.org/modularization for details about this
            modularization approach.     
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-04-03T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** arg ***
		A role used for the positional arguments of a logical atom.
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)

    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <define name="arg.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="arg.content">
        <choice>
            <ref name="Var"/>
            <ref name="Skolem"/>
            <ref name="Reify"/>
            <ref name="extended-signature-function-sorts.content"/>
        </choice>
    </define>
    <define name="arg.type">
        <ref name="arg.content"/>
        <ref name="arg.attlist"/>
    </define>
    <start combine="choice">
<ref name="arg"/>
</start>
<define name="arg">
<element name="arg">
<ref name="arg.type"/>
</element>
</define>
    <!--
		*** Ind ***
		An individual constant, as in predicate logic, which can also be considered to
		be a fixed argument like RDF resources.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Ind
		
		content model: text

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Ind.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Ind.content">
        <text/> 
    </define>
    <define name="Ind.type">
        <ref name="Ind.content"/>
        <ref name="Ind.attlist"/>
    </define>
    <start combine="choice">
<ref name="Ind"/>
</start>
<define name="Ind">
<element name="Ind">
<ref name="Ind.type"/>
</element>
</define>
    <!--
		*** Data ***
		A fixed argument like RDF literals, allowing XML data.  It may be
		optionally associated with an XML Schema built-in datatype
		(see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
		using the built-in xsi:type attribute.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Data
		
		content model: xs:anytype [optionally datatyped]
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <start combine="choice">
<ref name="Data"/>
</start>
<define name="Data">
<element name="Data">
<data type="string"/>
</element>
</define>
    <!--
		*** Var ***
		A logical variable, as in logic programming.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Var

		content model: text
		
		@mode = + | - | ?; default is ?

	  + input variable which must be bound
        - output variable which must be free (unbound)
        ? can be both input / bound or output / free
    
    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Var.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Var.content">
        <text/>
    </define>
    <define name="Var.type">
        <ref name="Var.content"/>
        <ref name="Var.attlist"/>
    </define>
    <start combine="choice">
<ref name="Var"/>
</start>
<define name="Var">
<element name="Var">
<ref name="Var.type"/>
</element>
</define>
    <!--
		*** Skolem ***
		A Skolem individual constant, like RDF's blank nodes.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Skolem

		content model: text
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Skolem.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Skolem.content">
        <text/>
    </define>
    <define name="Skolem.type">
        <ref name="Skolem.content"/>
        <ref name="Skolem.attlist"/>
    </define>
    <start combine="choice">
<ref name="Skolem"/>
</start>
<define name="Skolem">
<element name="Skolem">
<ref name="Skolem.type"/>
</element>
</define>
    <!--
		*** Reify ***
		Supports reification (a kind of instantiation or quasi-quotation)
		as needed by SWSL. It allows any RuleML tag available within the
		current sublanguage as content, treating it as a term for performing
		reasoning on.
				
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Reify		
		
		content model: (any valid RuleML formula)
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Reify.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Reify.content">
        
            <!--
		  <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/> -->
            <!-- <Reify> only allows valid RuleML -->
            <!--<xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>-->
            <optional>
<element>
<anyName/>
<text/>
</element>
</optional>
        
    </define>
    <define name="Reify.type">
        <ref name="Reify.content"/>
        <ref name="Reify.attlist"/>
    </define>
    <start combine="choice">
<ref name="Reify"/>
</start>
<define name="Reify">
<element name="Reify">
<ref name="Reify.type"/>
</element>
</define>
    <!-- includes the hornlog layer with the 'expr' and 'rest' modules -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML expressions. File:
            expr_module.xsd Version: 1.0 Last Modification: 2011-10-05 [Tara Athan] This module
            declares       the following RuleML elements and attributes: * Expr * op * Fun * Plex *
            @per See       http://www.ruleml.org/modularization for details about this
            modularization approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-10-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
        <!-- necessary for schematron -->
        <!-- 
		<xs:appinfo>

		<sch:ns prefix="r" iri="http://www.deliberation.ruleml.org/1.02/xsd"/>
		-->
    </a:documentation>
    <!--
		*** Expr ***
		A logical function of the form "f(...)" where f is a function name.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Expr

		content model:
		DR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*,
		  repo?, slot*, resl?
		)

    KR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*,
		  repo?, slot*, resl?
		)

		PR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl?		)
		  
		ECA Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op|Fun)?, slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)*, repo?, slot*, resl?
		)  

		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		DR Reaction RuleML:
		(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun)?, slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		KR Reaction RuleML:
				(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun)?, slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		Note the 'positionalized' normal form where the op role is only
		at the beginning of the Expr.
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Expr.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Expr.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<choice>
                <element name="op">
<ref name="op-Expr.type"/>
</element>
                <ref name="op-Expr.content"/>
            </choice>
</optional>
            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
            <optional>
<choice>
                
                    <choice>
                        
                            <oneOrMore>
<choice>
                                <ref name="arg"/>
                                <ref name="arg.content"/>
                            </choice>
</oneOrMore>
                            <optional>
<ref name="repo"/>
</optional>
                        
                        <ref name="repo"/>
                    </choice>
                    <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                
            </choice>
</optional>
            <optional>
<ref name="resl"/>
</optional>
        
    </define>
    <define name="Expr.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Uninterpreted functions">
					<sch:rule context="r:Expr/r:Fun[@per='no']">
						<sch:assert test=
								"not(../r:Expr/r:Fun[@per='yes'] or
									 ../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
					<sch:rule context="r:Expr/r:op/r:Fun[@per='no']">
						<sch:assert test=
								"not(../../r:Expr/r:Fun[@per='yes'] or
									 ../../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <ref name="Expr.content"/>
        <ref name="Expr.attlist"/>
    </define>
    <start combine="choice">
<ref name="Expr"/>
</start>
<define name="Expr">
<element name="Expr">
<ref name="Expr.type"/>
</element>
</define>
    <!--
		*** op ***
		An operator expression including the function name of an expression.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op
				
		content model (within Expr): (Fun)
		
		Other (context-sensitive) versions of <op> are in the atom and holog modules.
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <!-- the (empty) attribute list is declared in the atom module -->
    <define name="op-Expr.content">
        
            <ref name="Fun"/>
        
    </define>
    <define name="op-Expr.type">
        <ref name="op-Expr.content"/>
        <ref name="op.attlist"/>
    </define>
    <!--
		*** Fun ***
		A user-defined function name.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Fun

    content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
    attributes: attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Fun.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Fun.content">
        <text/>
    </define>
    <define name="Fun.type">
        <ref name="Fun.content"/>
        <ref name="Fun.attlist"/>
    </define>
    <start combine="choice">
<ref name="Fun"/>
</start>
<define name="Fun">
<element name="Fun">
<ref name="Fun.type"/>
</element>
</define>
    <!--
		*** Plex ***
		An unordered collection of arguments without a constructor.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Plex
		
		content model (within Atom, Plex, slot):
		DR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*, repo?, slot*, resl? )
    
    KR Reaction RuleML
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Interval)*, repo?, slot*, resl? )
		  
		PR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl? )
		
		ECA Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Atom|Event)*, repo?, slot*, resl? )
		
		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		
		DR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		KR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		content model (within repo): 
		DR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval )*, repo? )
		KR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo? )
		PR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex )*, repo? )
		ECA Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action )*, repo? )
		
		content model (within resl):
		DR/KR/PR/ECA/CEP Reaction RuleML: (slot*, resl? )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Plex.attlist">
        <ref name="term-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Plex.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
            <choice>
                
                    <oneOrMore>
<choice>
                        <ref name="arg"/>
                        <ref name="arg.content"/>
                    </choice>
</oneOrMore>
                    <optional>
<ref name="repo"/>
</optional>
                    <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                    <optional>
<ref name="resl"/>
</optional>
                
                
                    <ref name="repo"/>
                    <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                    <optional>
<ref name="resl"/>
</optional>
                
                
                    <ref name="resl"/>
                
            </choice>
        
    </define>
    <define name="Plex-repo.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <ref name="arg"/>
                <ref name="arg.content"/>
            </choice>
</zeroOrMore>
            <optional>
<ref name="repo"/>
</optional>
        
    </define>
    <define name="Plex-resl.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
            <optional>
<ref name="resl"/>
</optional>
        
    </define>
    <define name="Plex.type">
        <ref name="Plex.content"/>
        <ref name="Plex.attlist"/>
    </define>
    <define name="Plex-repo.type">
        <ref name="Plex-repo.content"/>
        <ref name="Plex.attlist"/>
    </define>
    <define name="Plex-resl.type">
        <ref name="Plex-resl.content"/>
        <ref name="Plex.attlist"/>
    </define>
    <start combine="choice">
<ref name="Plex"/>
</start>
<define name="Plex">
<element name="Plex">
<ref name="Plex.type"/>
</element>
</define>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for RuleML rest variables.
            File:       rest_module.xsd Version: 1.0 Last Modification: 2011-07-05 This module
            declares the following       RuleML elements: * repo * resl See
            http://www.ruleml.org/modularization for details about this       modularization
            approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-07-05T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** repo ***
		A positional rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-repo

		content model: (Var | Plex)
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="repo.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="repo.content">
        <choice>
            <ref name="Var"/>
            <element name="Plex">
<ref name="Plex-repo.type"/>
</element>
        </choice>
    </define>
    <define name="repo.type">
        <ref name="repo.content"/>
        <ref name="repo.attlist"/>
    </define>
    <start combine="choice">
<ref name="repo"/>
</start>
<define name="repo">
<element name="repo">
<ref name="repo.type"/>
</element>
</define>
    <!--
		*** resl ***
		A slotted rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-resl		

		content model: (Var | Plex)
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="resl.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="resl.content">
        <choice>
            <ref name="Var"/>
            <element name="Plex">
<ref name="Plex-resl.type"/>
</element>
        </choice>
    </define>
    <define name="resl.type">
        <ref name="resl.content"/>
        <ref name="resl.attlist"/>
    </define>
    <start combine="choice">
<ref name="resl"/>
</start>
<define name="resl">
<element name="resl">
<ref name="resl.type"/>
</element>
</define>
    <!-- includes the equalog layer with the 'equality' module -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
         This is the XML Schema module for equality in RuleML. File:
            equality_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This module
            declares the following RuleML elements and attributes: * Equal * left * right        See
            http://www.ruleml.org/modularization for details about this modularization approach. 
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2012-02-21T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Equal ***
		An equational formula consisting of two expressions.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal

		content model:
		in DR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)  )
		)
		in KR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)  )
		)
		in PR Reaction RuleML:  (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	( (Ind | Data | Var | Skolem | Reify  | Expr | Plex ), (Ind | Data | Var | Skolem | Reify  | Expr | Plex ) ))
		in ECA Reaction RuleML:	(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)  )
		)		
		
		attributes: @oriented?, @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Equal.attlist">
        <ref name="oriented.attrib"/>
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Equal.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<ref name="degree"/>
</optional>
            <choice>
                
                    <ref name="left"/>
                    <ref name="right"/>
                
                <!-- note that (right, left) is disallowed -->
                
                    <ref name="left.content"/>
                    <ref name="right.content"/>
                
            </choice>
        
    </define>
    <define name="Equal.type">
        <!-- 
			<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Defining equality">
					<sch:rule context=
						"r:Implies/r:then/r:Equal/r:left/r:Expr/r:Fun |
						 r:Implies/r:Equal[2]/r:left/r:Expr/r:Fun |
						 r:Implies/r:then/r:Equal/r:Expr[1]/r:Fun |
						 r:Implies/r:Equal[2]/r:Expr[1]/r:Fun">
						<sch:assert test="@per='yes'">
							A defining equality must have an interpreted left-hand side.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <ref name="Equal.content"/>
        <ref name="Equal.attlist"/>
    </define>
    <start combine="choice">
<ref name="Equal"/>
</start>
<define name="Equal">
<element name="Equal">
<ref name="Equal.type"/>
</element>
</define>
    <!--
		*** left ***
		The left-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-left

		content model: 
		in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	
	-->
    <define name="left.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="left.content">
        <choice>
            <ref name="arg.content"/>
        </choice>
    </define>
    <define name="left.type">
        <ref name="left.content"/>
        <ref name="left.attlist"/>
    </define>
    <start combine="choice">
<ref name="left"/>
</start>
<define name="left">
<element name="left">
<ref name="left.type"/>
</element>
</define>
    <!--
		*** right***
		The right-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-right

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)		
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="right.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="right.content">
        <choice>
            <ref name="arg.content"/>
        </choice>
    </define>
    <define name="right.type">
        <ref name="right.content"/>
        <ref name="right.attlist"/>
    </define>
    <start combine="choice">
<ref name="right"/>
</start>
<define name="right">
<element name="right">
<ref name="right.type"/>
</element>
</define>

    <define name="curieOrIRI.datatype">
        <choice>
<ref name="curie.datatype"/>
<data type="anyURI"/>
</choice>
    </define>
    <define name="curieOrAbsIRI.datatype">
        <choice>
<ref name="curie.datatype"/>
<ref name="absIRI.datatype"/>
</choice>
    </define>
    <define name="termOrCurieOrIRI.datatype">
        <choice>
<ref name="term.datatype"/>
<ref name="curie.datatype"/>
<data type="anyURI"/>
</choice>
    </define>
    <define name="termOrCurieOrIRIs.datatype">
        <list>
<ref name="termOrCurieOrIRI.datatype"/>
</list>
    </define>
    <define name="termOrCurieOrAbsIRI.datatype">
        <choice>
<ref name="term.datatype"/>
<ref name="curie.datatype"/>
<ref name="absIRI.datatype"/>
</choice>
    </define>
    <define name="termOrCurieOrAbsIRIs.datatype">
        <list>
<ref name="termOrCurieOrAbsIRI.datatype"/>
</list>
    </define>
    <define name="absIRI.datatype">
        <data type="anyURI">
            <param name="pattern">[\i-[:]][\c-[:]]+:.+</param>
        </data>
    </define>
    <define name="curie.datatype">
        <data type="string">
            <param name="minLength">1</param>
            <param name="pattern">(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)</param>
        </data>
    </define>
    <define name="term.datatype">
        <data type="Name">
            <param name="pattern">[\i-[:]][/\c-[:]]*</param>
        </data>
    </define>
    <!--
           *** @mode ***
           An attribute for optionally specifying the intended input-output constellations of formulas and terms with the
           following semantics:
        
           "+" The formula/term is intended to be input
           "-" The formula/term is intended to be output
           "?" The formula/term is undefined (input or output)
           "[iri]" the formula/term's mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)  
		   
			By default the mode of formulas when used as conditions, constraints, queries and event patterns is "+" (input)
			and the mode of conclusions, answers and active actions is "-" (output). Variables are "?" (open) by default.
			optional attribute
			
			See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40mode
-->
    <define name="mode.attrib">
        <optional>
<attribute name="mode" a0:defaultValue="?" xmlns:a0="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRI.datatype"/>
<ref name="vocab-modes.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-modes.datatype">
        <choice>
            <value>+</value>
            <value>-</value>
            <value>?</value>
        </choice>
    </define>
    <!--
	  *** @safety ***

	     restriction: interrupting, non-interrupting or transactional or
	     "[iri]" the formula/term's safety mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)
	     
		 default: non-interrupting 
		 optional attribute
		 
		 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40safety
	-->
    <define name="safety.attrib">
        <optional>
<attribute name="safety" a1:defaultValue="non-interrupting" xmlns:a1="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRI.datatype"/>
<ref name="vocab-safety.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-safety.datatype">
        <choice>
            <value>non-interrupting</value>
            <value>interrupting</value>
            <value>transactional</value>
        </choice>
    </define>
    <!--
		*** @per ***
		An optinal attribute indicating how a formulas, terms and operators are interpreted.
		
		Default for formulas is per "value" (truth valuation), for terms per "copy", for modal operators per "modal" and for actions/performatives by "effect".		
		In "reasoning" dialects the default for actions and events is per "value" and in active / messaging dialects it is per "effect".
		In "non-reified" representations as formulas default interpretation per "value" and in "reified" representations as term default interpretation is per copy. 
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40per
	-->
    <define name="per.attrib">
        <optional>
<attribute name="per">
            
                <choice>
<ref name="termOrCurieOrAbsIRI.datatype"/>
<ref name="vocab-per.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-per.datatype">
        <choice>
            <value>copy</value>
            <value>value</value>
            <value>effect</value>
            <value>modal</value>
            <value>open</value>
        </choice>
    </define>
    <!--
		*** @size  ***
		An attribute indicating the size of a counter		
		-1 = unbound / all
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40size
	-->
    <!-- 
		
		replaced by card 
		
		<xs:attributeGroup name="size.attrib">
		<xs:attribute name="size" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="mapSize.attrib">
		<xs:attribute name="mapSize" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>-->
    <!--
    *** @style ***
    
    The style attribute defines the styles of the intended semantics. 
    Predefined semantics are "active", "reasoning", "messaging". 
    Further intented semantics can be defined by semantic profiles internally in the <evaluation> role
    or externally. They can be referenced by ther profile name (term) or resource locator (curie or absolute IRI).
    
   restriction: active | messaging | reasoning | "[IRIs]" (vocabulary terms or curies or absolute IRIs)

	 default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40style
	-->
    <define name="style.datatype">
        <choice>
<ref name="termOrCurieOrAbsIRIs.datatype"/>
<ref name="vocab-style.datatype"/>
</choice>
    </define>
    <define name="vocab-style.datatype">
        <choice>
            <value>active</value>
            <value>messaging</value>
            <value>reasoning</value>
        </choice>
    </define>
    <!--
    *** @key ***
    
    optinal unique local key on all knowledge formulas
    
	 optinal attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40key
	-->
    <define name="key.attrib">
        <optional>
<attribute name="key">
<ref name="curieOrAbsIRI.datatype"/>
</attribute>
</optional>
    </define>
    <!--
    *** @keyref ***
    
    corresponding reference to a unique local key
    
	 optinal attribute
	 
	 http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40keyref
	-->
    <define name="keyref.attrib">
        <optional>
<attribute name="keyref">
<ref name="curieOrAbsIRI.datatype"/>
</attribute>
</optional>
    </define>
    <!--
    *** @node ***
    An optional identification label for a Node, creating accessibility within
    the knowledge representation.
    This can help for representing prioritization between rules, for example. 
    The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
    such a label.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40node
    
    content model: (curieOrAbsIRI.datatype)
  -->
    <define name="node.attrib">
        <optional>
<attribute name="node">
<ref name="curieOrAbsIRI.datatype"/>
</attribute>
</optional>
    </define>
    <!--
		*** @type ***
		An attribute for optionally specifying a (user-defined) type.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40type
		
		Note: In Reaction RuleML the type is changed to Term or Curie or absolute IRI to allow references
		to internal vocabulary terms (e.g. local sort signature definitions) and external vocabulary types (sorts) 
	-->
    <define name="type.attrib">
        <optional>
<attribute name="type">
<ref name="termOrCurieOrAbsIRI.datatype"/>
</attribute>
</optional>
    </define>
    <!--
    *** @meta ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines descriptive meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <meta> role)
     or external metadata vocabularies.
     
	 By default knowledge is contextually annotated by metadata about the source (@src([Locator])) and the name (@label([OID])),
	 with "Locator" being the source location (location of Reaction RuleML knowledge base in which the knowledge is defined) 
	 and OID being the implicitly or explicitly defined object identifer of the knowledge.
	 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40meta
	-->
    <define name="meta.attrib">
        <optional>
<attribute name="meta">
            
                <choice>
<ref name="termOrCurieOrAbsIRIs.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <!--
    *** @qualify ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines qualifying meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <qualification> role)
     or external metadata vocabularies.
      
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40qualify
	-->
    <define name="qualify.attrib">
        <optional>
<attribute name="qualify">
            
                <choice>
<ref name="termOrCurieOrAbsIRIs.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <!--
    *** @scope ***
    
     restriction: global | local | private | "[iris]" (terms or curies or absolute IRIs)
     
     Defines a scope. Predefined scopes are global, local, private. 
     Internal dynamic scopes defined by metadata views (defined in the <scope> role) can be references by the oid name term (<oid>)
     and externally defined scopes by their IRI.
     
	 default value: "global" for relations and functions and "local" for terms 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40scope
	-->
    <define name="scope-formula.attrib">
        <optional>
<attribute name="scope" a2:defaultValue="global" xmlns:a2="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRIs.datatype"/>
<ref name="vocab-scope.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="scope-term.attrib">
        <optional>
<attribute name="scope" a3:defaultValue="local" xmlns:a3="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRIs.datatype"/>
<ref name="vocab-scope.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-scope.datatype">
        <choice>
            <value>local</value>
            <value>global</value>
            <value>private</value>
        </choice>
    </define>
    <!--
		*** @arity ***
		An optional attribute for specifying the arity of a signature.
		The arity of constants / individual objects is zero.
		The arity of predicates and functions is the number of arguments they have.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40arity
	-->
    <define name="arity.attrib">
        <optional>
<attribute name="arity">
<data type="nonNegativeInteger"/>
</attribute>
</optional>
    </define>
    <!--
		*** @prefix ***
		
		a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40prefix
		
	-->
    <define name="prefix.attrib">
        <optional>
<attribute name="prefix">
<ref name="prefix.datatype"/>
</attribute>
</optional>
    </define>
    <define name="prefix.datatype">
        <data type="string">
            <param name="minLength">1</param>
            <param name="pattern">([\i-[:]][\c-[:]]*)?</param>
        </data>
    </define>
    <!--
		*** @vocab ***
		
		an IRI that defines the vocabulary mapping to use when a TERM is referenced in an attribute value.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40vocab
				
	-->
    <define name="vocab.attrib">
        <optional>
<attribute name="vocab">
<data type="anyURI"/>
</attribute>
</optional>
    </define>
    <!--
		*** @card @minCard @maxCard ***
		An attribute optionally specifying the cardinality.
		
		"-1" = unbound
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40card
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40maxCard
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40minCard
	-->
    <define name="card.attrib">
        <optional>
<attribute name="card">
<data type="int"/>
</attribute>
</optional>
        <optional>
<attribute name="maxCard">
<data type="int"/>
</attribute>
</optional>
        <optional>
<attribute name="minCard">
<data type="nonNegativeInteger"/>
</attribute>
</optional>
    </define>
    <!--
		*** @weight ***
		An attribute optionally specifying a relative weight.
		The default is "1", i.e. all knowledge has the same weight of "1". 
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40weight		
	-->
    <define name="weight.attrib">
        <optional>
<attribute name="weight">
            
                <data type="decimal">
                    <param name="minInclusive">0</param>
                    <param name="maxInclusive">1</param>
                </data>
            
        </attribute>
</optional>
    </define>
    <!--
		*** @direction ***
		An attribute indicating the intended direction of an implication rule's inferencing.
		default is bidirectional.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40direction
	-->
    <define name="direction.attrib">
        <optional>
<attribute name="direction" a4:defaultValue="bidirectional" xmlns:a4="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRI.datatype"/>
<ref name="vocab-direction.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-direction.datatype">
        <choice>
            <value>forward</value>
            <value>backward</value>
            <value>bidirectional</value>
        </choice>
    </define>
    <!--
		*** @closure ***
		An attribute indicating how the contained free variables are quantified.
		default is universal closure.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40closure		
	-->
    <define name="closure.attrib">
        <optional>
<attribute name="closure" a5:defaultValue="universal" xmlns:a5="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
<ref name="termOrCurieOrAbsIRI.datatype"/>
<ref name="vocab-closure.datatype"/>
</choice>
            
        </attribute>
</optional>
    </define>
    <define name="vocab-closure.datatype">
        <choice>
            <value>universal</value>
            <value>existential</value>
        </choice>
    </define>
    <!--
		*** @material ***
		An attribute indicating the kind of an implication rule.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40material
	-->
    <define name="material.attrib">
        <optional>
<attribute name="material" a6:defaultValue="no" xmlns:a6="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
                    <value>no</value>
                    <value>yes</value>
                </choice>
            
        </attribute>
</optional>
    </define>
    <!--
		*** @iri ***
		An attribute for referring to a Curie or absolute IRI.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40iri
	-->
    <define name="iri.attrib">
        <optional>
<attribute name="iri">
<ref name="curieOrAbsIRI.datatype"/>
</attribute>
</optional>
    </define>
    <!--
		*** @index ***
		An optional attribute for specifying an ordering on roles.
		
		Note: in Reaction RuleML @index is optional
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40index
	-->
    <define name="index.attrib">
        <optional>
<attribute name="index">
<data type="positiveInteger"/>
</attribute>
</optional>
    </define>
    <!--
		*** @oriented ***
		An attribute indicating whether an equation is oriented (directed)
		or unoriented (symmetric).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40oriented
	-->
    <define name="oriented.attrib">
        <optional>
<attribute name="oriented" a7:defaultValue="no" xmlns:a7="http://relaxng.org/ns/compatibility/annotations/1.0">
            
                <choice>
                    <value>yes</value>
                    <value>no</value>
                </choice>
            
        </attribute>
</optional>
    </define>
    <!-- 
 
  	a group of attributes for all XML elements in Reaction RuleML

	@prefix?, @key?, @keyref?, @xml:id?, @xml:base?
 
  	@key and @keyref attributes for local syntactic modularization of the knowledge base
  	   
  	-->
    <define name="xml.attlist">
        <ref name="prefix.attrib"/>
        <ref name="key.attrib"/>
        <ref name="keyref.attrib"/>
        <attribute name="base" ns="http://www.w3.org/XML/1998/namespace">
<text/>
</attribute>
        <attribute name="id" ns="http://www.w3.org/XML/1998/namespace">
<text/>
</attribute>
    </define>
    <!-- 
 
  	a group of attributes for all XML node elements (type elements) in Reaction RuleML
  	
	@meta?, @qualify?, @node?, @iri?, @vocab?
   	   
  	-->
    <define name="node-element.attlist">
        <ref name="node.attrib"/>
        <ref name="iri.attrib"/>
        <ref name="vocab.attrib"/>
        <ref name="meta.attrib"/>
        <ref name="qualify.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for all XML edge elements (role elements) in Reaction RuleML
  	
	@index?
   	   
  	-->
    <define name="edge-element.attlist">
        <ref name="index.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all grouping formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?  
	
	attributes of grouping formulas are automatically inherited as default attributes to all formulas in the group.
  	-->
    <define name="group-formula-interface.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="material.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all knowledge formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?

   	   
  	-->
    <define name="formula-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="arity.attrib"/>
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="style.attrib"/>
        <ref name="direction.attrib"/>
        <ref name="scope-formula.attrib"/>
        <ref name="closure.attrib"/>
        <ref name="mode.attrib"/>
        <ref name="per.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all terms in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?
   	   
  	-->
    <define name="term-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="arity.attrib"/>
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="scope-term.attrib"/>
        <ref name="mode.attrib"/>
        <ref name="per.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all quantifiers in Reaction RuleML
  	
	@type?, @card?, @minCard?, @maxCard?, @style?, @scope?
  	-->
    <define name="quantifier-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="card.attrib"/>
        <ref name="style.attrib"/>
        <ref name="scope-formula.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all connectives/operators in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
  	-->
    <define name="operator-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="arity.attrib"/>
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="style.attrib"/>
        <ref name="direction.attrib"/>
        <ref name="scope-formula.attrib"/>
        <ref name="mode.attrib"/>
        <ref name="closure.attrib"/>
        <ref name="per.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all action / performatives in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
  	-->
    <define name="action-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="arity.attrib"/>
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="style.attrib"/>
        <ref name="direction.attrib"/>
        <ref name="safety.attrib"/>
        <ref name="scope-formula.attrib"/>
        <ref name="mode.attrib"/>
        <ref name="closure.attrib"/>
        <ref name="per.attrib"/>
    </define>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all events in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
  	-->
    <define name="event-interface.attlist">
        <ref name="type.attrib"/>
        <ref name="arity.attrib"/>
        <ref name="card.attrib"/>
        <ref name="weight.attrib"/>
        <ref name="style.attrib"/>
        <ref name="direction.attrib"/>
        <ref name="safety.attrib"/>
        <ref name="scope-formula.attrib"/>
        <ref name="mode.attrib"/>
        <ref name="closure.attrib"/>
        <ref name="per.attrib"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                              Rules module part of Reaction RuleML.
            It defines the core            Rule construct used as basis for all types of rules in
            Reaction RuleML                      This is the XML Schema rule module for Reaction
            RuleML.           File: rule_module.xsd           Version: 1.0           Last
            Modification: 2011-03-29                      This schema declares the following
            Reaction RuleML elements and attributes:                      * Rule           * on
            * if           * then           * do           * after                     * else
            * elseDo           * elseAfter                          
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
      *** Rule ***
      The Rule element that provides the basic syntax for rules
      in Reaction RuleML.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rule

      content model: 
 	 
 	 In (temporal) DR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )
	 
	 In KR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)))
	 
	 In PR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (elseDo?, do, if) | (if, do, elseDo?)))
	 
	 in ECA Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)? ) )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )

	 
	 in CEP Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)* ) )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( do )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )

	 
      Rule has the following attributes:
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
      
-->
    <define name="Rule.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="material.attrib"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Rule.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<ref name="rule-implementation.content"/>
</optional>
        
    </define>
    <define name="Rule.type">
        <ref name="Rule.content"/>
        <ref name="Rule.attlist"/>
    </define>
    <start combine="choice">
<ref name="Rule"/>
</start>
<define name="Rule">
<element name="Rule">
<ref name="Rule.type"/>
</element>
</define>
    <!--
     *** on ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-on
     
     content model: 
     DR Reaction RuleMl: (  )
     KR Reaction RuleMl: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
     PR Reaction RuleML: ( )
     ECA Reaction RuleML: (Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operator)  
     CEP Reaction RuleML: (Receive | Answer | Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operator) 
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="on.attlist">
        <ref name="xml.attlist"/>
        <ref name="edge-element.attlist"/>
    </define>
    <define name="on.content">
        <choice>
            <ref name="event_group.content"/>
        </choice>
    </define>
    <define name="on.type">
        <ref name="on.content"/>
        <ref name="on.attlist"/>
    </define>
    <start combine="choice">
<ref name="on"/>
</start>
<define name="on">
<element name="on">
<ref name="on.type"/>
</element>
</define>
    <!--
     *** if ***
     *** after ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-after
     
     content model:   
     DR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
     KR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf  )    
     ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
	
	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <start combine="choice">
<ref name="after"/>
</start>
<define name="after">
<element name="after">
<ref name="if.type"/>
</element>
</define>
    <!--
	 *** then ***	
     *** else ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-else
     
     content model: 
     DR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
     KR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: not used in PR Reaction RuleML (only in combination with DR)
     ECA Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
	
	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <start combine="choice">
<ref name="else"/>
</start>
<define name="else">
<element name="else">
<ref name="then.type"/>
</element>
</define>
    <!--
     *** do ***
     *** elseDo ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-do
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-elseDo
     
     content model:  
     DR Reaction RuleML: (  )
     KR Reaction RuleML: ( Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)
     ECA Reaction RuleML:  (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)
     CEP Reaction RuleML:  (Send | Consult | Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operator)

	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="do.attlist">
        <ref name="xml.attlist"/>
        <ref name="edge-element.attlist"/>
    </define>
    <define name="do.content">
        <choice>
            <ref name="action_group.content"/>
        </choice>
    </define>
    <define name="do.type">
        <ref name="do.content"/>
        <ref name="do.attlist"/>
    </define>
    <start combine="choice">
<ref name="do"/>
</start>
<define name="do">
<element name="do">
<ref name="do.type"/>
</element>
</define>
    <start combine="choice">
<ref name="elseDo"/>
</start>
<define name="elseDo">
<element name="elseDo">
<ref name="do.type"/>
</element>
</define>
    <!--
  *** Derivation Rule content model ***
  	((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
	-->
    <define name="DerivationRule.content">
        <choice>
            
                <optional>
<ref name="else"/>
</optional>
                <ref name="then"/>
                <ref name="if"/>
            
            
                <ref name="if"/>
                <ref name="then"/>
                <optional>
<ref name="else"/>
</optional>
            
            
                <ref name="if.content"/>
                <ref name="then.content"/>
                <optional>
<ref name="then.content"/>
</optional>
            
        </choice>
    </define>
    <!--
   *** Production Rule content model ***
   ((if, do, elseDo?) | (elseDo?, do, if))
-->
    <define name="ProductionRule.content">
        <choice>
            
                <optional>
<ref name="elseDo"/>
</optional>
                <ref name="do"/>
                <ref name="if"/>
            
            
                <ref name="if"/>
                <ref name="do"/>
                <optional>
<ref name="elseDo"/>
</optional>
            
        </choice>
    </define>
    <!--
   *** Combined DR Production Rule content model ***
   Production Rule       Derivation Rule    Production Rule with conclusion   inverse Production Rule with conclusion 
   ((if, do, elseDo?) | (if, then, else) | (if, do, then?, elseDo?, else?) | (else?, elseDo?, then?, do, if))
-->
    <define name="DRProductionRule.content">
        <choice>
            
                <optional>
<ref name="else"/>
</optional>
                <optional>
<ref name="elseDo"/>
</optional>
                <optional>
<ref name="then"/>
</optional>
                <ref name="do"/>
                <ref name="if"/>
            
            
                <ref name="if"/>
                <optional>
<ref name="do"/>
</optional>
                <optional>
<ref name="then"/>
</optional>
                <optional>
<ref name="elseDo"/>
</optional>
                <optional>
<ref name="else"/>
</optional>
            
        </choice>
    </define>
    <!--
   *** Reaction Rule content model ***
   (on, (if?, then?, do?, after?,else?, elseDo?)? )
-->
    <define name="ReactionRule.content">
        
            <ref name="on"/>
            <optional>
<choice>
                
                    <optional>
<ref name="if"/>
</optional>
                    <optional>
<ref name="then"/>
</optional>
                    <optional>
<ref name="do"/>
</optional>
                    <optional>
<ref name="after"/>
</optional>
                    <optional>
<ref name="else"/>
</optional>
                    <optional>
<ref name="elseDo"/>
</optional>
                
            </choice>
</optional>
        
    </define>
    <!--
   *** Messaging Rule content model ***
   (do)
-->
    <define name="MessagingRule.content">
        
            <ref name="do"/>
        
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Negation module part of Reaction RuleML.   This
            defines the negation elements for Reaction RuleML.   File: negation_module.xsd
            Version: 1.0   Last Modification: 2011-03-22      * Negation  generic polymorphig
            negation   * Naf           negation as failure (inflationary negation in production
            rules), weak negation   * Neg           classical negation, strong negation   * weak
            * strong   * formula        
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
		*** Negation ***
		A generic polymorphic negation
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Negation
		
		It can be specialized by using
		the @type attribute to specify the type of negation and/or 
 		the @iri attribute to point to an external definition of the negation
 		@key, @keyref, @node

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
        PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action) )
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
		-->
    <define name="Negation.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Negation.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                <element name="formula">
<ref name="formula-negation.type"/>
</element>
                <ref name="formula-negation.content"/>
            </choice>
        
    </define>
    <define name="Negation.type">
        <ref name="Negation.content"/>
        <ref name="Negation.attlist"/>
    </define>
    <start combine="choice">
<ref name="Negation"/>
</start>
<define name="Negation">
<element name="Negation">
<ref name="Negation.type"/>
</element>
</define>
    <define name="formula-negation.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="formula-negation.content">
        <choice>
            <element name="Operator">
<ref name="ConnectiveOperator.type"/>
</element>
            <ref name="Equal"/>
            <ref name="Negation"/>
            <ref name="Neg"/>
            <ref name="extended-signature-predicate-sorts.content"/>
        </choice>
    </define>
    <define name="formula-negation.type">
        <ref name="formula-negation.content"/>
        <ref name="formula-negation.attlist"/>
    </define>
    <start combine="choice">
<ref name="formula"/>
</start>
<define name="formula">
<element name="formula">
<ref name="formula-negation.type"/>
</element>
</define>
    <!--
		*** Naf ***
		A "by default" negation of a logical atom (i.e. "weak" negation or
		negation-as-failure).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Naf
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
   		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
 		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )  		
	
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <define name="Naf.attlist">
        <ref name="Negation.attlist"/>
    </define>
    <define name="Naf.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                <ref name="weak"/>
                <ref name="weak.content"/>
            </choice>
        
    </define>
    <define name="Naf.type">
        <ref name="Naf.content"/>
        <ref name="Naf.attlist"/>
    </define>
    <start combine="choice">
<ref name="Naf"/>
</start>
<define name="Naf">
<element name="Naf">
<ref name="Naf.type"/>
</element>
</define>
    <!--
		*** weak ***
		A role used for negation as failure.
	
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-weak
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation ) )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action ) )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="weak.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="weak.content">
        <choice>
            <ref name="formula-negation.content"/>
        </choice>
    </define>
    <define name="weak.type">
        <ref name="weak.content"/>
        <ref name="weak.attlist"/>
    </define>
    <start combine="choice">
<ref name="weak"/>
</start>
<define name="weak">
<element name="weak">
<ref name="weak.type"/>
</element>
</define>
    <!--
		*** Neg ***
		A classical negation of a logical atom (i.e. classical or "strong" negation).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Neg
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
		PR Reaction RuleML: strong negation not supported by PR Reaction RuleML
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <define name="Neg.attlist">
        <ref name="Negation.attlist"/>
    </define>
    <define name="Neg.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                <ref name="strong"/>
                <ref name="strong.content"/>
            </choice>
        
    </define>
    <define name="Neg.type">
        <ref name="Neg.content"/>
        <ref name="Neg.attlist"/>
    </define>
    <start combine="choice">
<ref name="Neg"/>
</start>
<define name="Neg">
<element name="Neg">
<ref name="Neg.type"/>
</element>
</define>
    <!--
		*** strong ***
		A role used for classical negation.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-strong
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )	
		PR Reaction RuleML: strong negation not supported by PR Reaction RuleML 
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operator | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )	

		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="strong.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="strong.content">
        <choice>
            <ref name="formula-negation.content"/>
        </choice>
    </define>
    <define name="strong.type">
        <ref name="strong.content"/>
        <ref name="strong.attlist"/>
    </define>
    <start combine="choice">
<ref name="strong"/>
</start>
<define name="strong">
<element name="strong">
<ref name="strong.type"/>
</element>
</define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                         Quantifier module part of
            Reaction RuleML redefining the Forall, Exists and introduce the Quantifier element.
            This is the XML Schema Quantifier element for Reaction RuleML.   File:
            quantifier_module.xsd   Version: 1.0   Last Modification: 2011-03-22       * Quantifier
            generic quantifier (used in quantification metatag)   * Forall  predefined inner
            quantifier (used in quantification metatag)   * Exist   predefined inner quantifier
            (used in qualification metatag)       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Quantifier ***
	Explicit generic quantifier, where the quantifier name can be defined by the 
    @type attribute and the @iri attribute can point to an external definition
    of the quantifier.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Quantifier
    
    Format: "quantifier declare(Var)+ such that guard formula(...)?" 
		
	content model: 
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )?

	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="Quantifier.attlist">
        <ref name="quantifier-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Quantifier.content">
        
            <ref name="meta-roles.content"/>
            <oneOrMore>
<choice>
                <ref name="declare"/>
                <ref name="Var"/>
            </choice>
</oneOrMore>
            <optional>
<choice>
                <element name="formula">
<ref name="formula-inner-quantifier.type"/>
</element>
                <ref name="formula-inner-quantifier.content"/>
            </choice>
</optional>
        
    </define>
    <define name="Quantifier.type">
        <ref name="Quantifier.content"/>
        <ref name="Quantifier.attlist"/>
    </define>
    <start combine="choice">
<ref name="Quantifier"/>
</start>
<define name="Quantifier">
<element name="Quantifier">
<ref name="Quantifier.type"/>
</element>
</define>
    <!-- Exists
	make the quantifier constraint restrictions ("such that") optional
	
	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Exists
	
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?

	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
    -->
    <define name="Exists-quantifier.content">
        
            <ref name="meta-roles.content"/>
            <oneOrMore>
<choice>
                <ref name="declare"/>
                <ref name="declare.content"/>
            </choice>
</oneOrMore>
            <optional>
<choice>
                <element name="formula">
<ref name="formula-inner-quantifier.type"/>
</element>
                <ref name="formula-inner-quantifier.content"/>
            </choice>
</optional>
        
    </define>
    <define name="Exists-quantifier.type">
        <ref name="Exists-quantifier.content"/>
        <ref name="Quantifier.attlist"/>
    </define>
    <!-- Forall
	make the quantifier constraint restrictions ("such that") optional
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Forall
	
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?
	
	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Forall-quantifier.content">
        
            <ref name="meta-roles.content"/>
            <oneOrMore>
<choice>
                <ref name="declare"/>
                <ref name="declare.content"/>
            </choice>
</oneOrMore>
            <optional>
<choice>
                <element name="formula">
<ref name="formula-inner-quantifier.type"/>
</element>
                <ref name="formula-inner-quantifier.content"/>
            </choice>
</optional>
        
    </define>
    <define name="Forall-quantifier.type">
        <ref name="Forall-quantifier.content"/>
        <ref name="Quantifier.attlist"/>
    </define>
    <!--
		*** formula ***
		The 'such that' guard formula role of a quantifier (<Forall> or <Exists>).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
		
	     DR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
     	 KR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     	 PR Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Naf  ) 
     	 ECA Reaction RuleML: (Operator | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
		
		Other (context-sensitive) versions of <formula> are in the
		connective and performative modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="formula-inner-quantifier.content">
        <choice>
            <ref name="guard.content"/>
        </choice>
    </define>
    <define name="formula-inner-quantifier.type">
        <ref name="formula-inner-quantifier.content"/>
        <ref name="formula.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                 Profile module part of Reaction RuleML.   This is
            the XML Schema Profile element for Reaction RuleML for describing semantic profiles.
            Semantic Profiles are used to define the interpretation evaluation semantics (under the
            evaluation metatag)    either by referecing external existing profiles or by defining
            them internally.   File: profile_module.xsd   Version: 1.0   Last Modification:
            2011-03-22      * Profile         generic semantic profile       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Profile ***
	Explicit generic semantic profile defining the intended semantics for knowledge interpretation, inference and execution. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Profile
	
	The semantic profile can be defined internally by the any content model (xs:any Element) or externally  

	DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | content(xs:any*)  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens | content(xs:any*) )*)	
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Equal | content(xs:any*)  )*)
 	ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operator | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | content(xs:any*)  )*)   
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @safety, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <define name="Profile.attlist">
        <ref name="group-formula-interface.attlist"/>
        <ref name="safety.attrib"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Profile.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <element name="formula">
<ref name="formula-assert.type"/>
</element>
                <ref name="formula-assert.content"/>
                <element name="content">
<ref name="profile_anycontent.type"/>
</element>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Profile.type">
        <ref name="Profile.content"/>
        <ref name="Profile.attlist"/>
    </define>
    <start combine="choice">
<ref name="Profile"/>
</start>
<define name="Profile">
<element name="Profile">
<ref name="Profile.type"/>
</element>
</define>
    <!--
     *** content ***
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     the optional @prefix and @vocab are used to define a prefix and a term mapping vocabulary for the XML content (see CURIE to IRI and term to IRI translation)
     content model:  (xs:any*)
     
     attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="profile_anycontent.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="profile_anycontent.content">
        <choice>
            <zeroOrMore>
<element>
<anyName/>
<text/>
</element>
</zeroOrMore>
        </choice>
    </define>
    <define name="profile_anycontent.type">
        <ref name="profile_anycontent.content"/>
        <ref name="profile_anycontent.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Time module part of Reaction RuleML. It
            defines the core     time constructs        This is the XML Schema time module for
            Reaction RuleML.    File: time_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Time    
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Time ***
	Explicit generic Time construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Situation
	
	The time can be represented internally 
      * with positional arguments <arg>, e.g., <arg>
<Data xsi:type="xs:dateTime>2011-10-02T10:45:34-00:00</Data>
</arg>
      * with unpositional slots <slot>, e.g., <slot>
<Ind>year</Ind>
<Ind>2011</Ind>
</slot>
<slot>
<Ind>month</Ind>
<Ind>10</Ind>
</slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
      or externally, where the optional @iri attribute points to an external data definition of the time
      The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
      or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
      Note: Time can be defined absolute or relative.
      		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	KR Reaction RuleML:  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
				((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 	
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Time.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Time.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                
                    <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                    <optional>
<ref name="resl"/>
</optional>
                    <optional>
<choice>
                        
                            <choice>
                                
                                    <oneOrMore>
<choice>
                                        <element name="arg">
<ref name="arg_time.type"/>
</element>
                                        <ref name="time_primitives.content"/>
                                    </choice>
</oneOrMore>
                                    <optional>
<ref name="repo"/>
</optional>
                                
                                <ref name="repo"/>
                            </choice>
                            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                            <optional>
<ref name="resl"/>
</optional>
                        
                    </choice>
</optional>
                
                <zeroOrMore>
<element name="content">
<ref name="time_anycontent.type"/>
</element>
</zeroOrMore>
            </choice>
        
    </define>
    <define name="Time.type">
        <ref name="Time.content"/>
        <ref name="Time.attlist"/>
    </define>
    <start combine="choice">
<ref name="Time"/>
</start>
<define name="Time">
<element name="Time">
<ref name="Time.type"/>
</element>
</define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Time
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval | (After | Before | Any | Every | Timer | Operator))
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operator))
     in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator))  
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
          
-->
    <define name="arg_time.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="arg_time.content">
        <choice>
            <ref name="time_primitives.content"/>
        </choice>
    </define>
    <define name="arg_time.type">
        <ref name="arg_time.content"/>
        <ref name="arg_time.attlist"/>
    </define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
     
     content model:  xs:any*

     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="time_anycontent.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="time_anycontent.content">
        <choice>
            <zeroOrMore>
<element>
<anyName/>
<text/>
</element>
</zeroOrMore>
        </choice>
    </define>
    <define name="time_anycontent.type">
        <ref name="time_anycontent.content"/>
        <ref name="time_anycontent.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Spatial module part of Reaction RuleML. It defines
            the core     spatial constructs        This is the XML Schema spatial module for
            Reaction RuleML.    File: spatial_module.xsd    Version: 1.0    Last Modification:
            2011-03-29        This schema declares the following Reaction RuleML elements and
            attributes:        * Spatial       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Spatial ***
	Explicit generic Spatial construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Spatial
	
	The spatial can be represented internally 
      * with positional arguments <arg>
      * with unpositional slots <slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
      or externally, where the optional @iri attribute points to an external data definition of the spatial
      The optional @type attribute defines the type of the spatial
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operator))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	PR Reaction RuleML: not used in PR Reaction RuleML
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
				
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Spatial.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Spatial.content">
        
            <ref name="meta-roles.content"/>
            <choice>
                
                    <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                    <optional>
<ref name="resl"/>
</optional>
                    <optional>
<choice>
                        
                            <choice>
                                
                                    <oneOrMore>
<choice>
                                        <element name="arg">
<ref name="arg_spatial.type"/>
</element>
                                        <ref name="spatial_primitives.content"/>
                                    </choice>
</oneOrMore>
                                    <optional>
<ref name="repo"/>
</optional>
                                
                                <ref name="repo"/>
                            </choice>
                            <zeroOrMore>
<element name="slot">
<ref name="slot.type"/>
</element>
</zeroOrMore>
                            <optional>
<ref name="resl"/>
</optional>
                        
                    </choice>
</optional>
                
                <zeroOrMore>
<element name="content">
<ref name="spatial_anycontent.type"/>
</element>
</zeroOrMore>
            </choice>
        
    </define>
    <define name="Spatial.type">
        <ref name="Spatial.content"/>
        <ref name="Spatial.attlist"/>
    </define>
    <start combine="choice">
<ref name="Spatial"/>
</start>
<define name="Spatial">
<element name="Spatial">
<ref name="Spatial.type"/>
</element>
</define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Spatial
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operator))
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operator))
     in PR Reaction RuleML: not used in PR Reaction RuleML
     in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operator)) 
     
      @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
-->
    <define name="arg_spatial.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="arg_spatial.content">
        <choice>
            <ref name="spatial_primitives.content"/>
        </choice>
    </define>
    <define name="arg_spatial.type">
        <ref name="arg_spatial.content"/>
        <ref name="arg_spatial.attlist"/>
    </define>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
     
     content model:  xs:any*
     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="spatial_anycontent.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="spatial_anycontent.content">
        <choice>
            <zeroOrMore>
<element>
<anyName/>
<text/>
</element>
</zeroOrMore>
        </choice>
    </define>
    <define name="spatial_anycontent.type">
        <ref name="spatial_anycontent.content"/>
        <ref name="spatial_anycontent.attlist"/>
    </define>
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                       Interval module part of Reaction RuleML. It
            defines the core     Interval construct        This is the XML Schema interval module
            for Reaction RuleML.    File: interval_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Interval    
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
	*** Interval ***
	Explicit generic Interval. 
	
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Interval
	
	The interval can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the interval,
      the optional @iri attribute points to an external definition of the interval, and
       An interval can be defined by Events, Actions,  Times, Spatials, and other Intervals can be typed by the 
       interval ontology of Reaction RuleML (defining different types of intervals).
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?])) 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?] )) 
    PR Reaction RuleML: not used in PR Reaction RuleML 
	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))?])) 
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Interval.attlist">
        <ref name="formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Interval.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<choice>
                
                    <element name="arg">
<ref name="arg_interval.type"/>
</element>
                    <optional>
<element name="arg">
<ref name="arg_interval.type"/>
</element>
</optional>
                
                
                    <ref name="interval_primitives.content"/>
                    <optional>
<ref name="interval_primitives.content"/>
</optional>
                
                
                    <element name="content">
<ref name="interval_anycontent.type"/>
</element>
                    <optional>
<element name="content">
<ref name="interval_anycontent.type"/>
</element>
</optional>
                
            </choice>
</optional>
        
    </define>
    <define name="Interval.type">
        <ref name="Interval.content"/>
        <ref name="Interval.attlist"/>
    </define>
    <start combine="choice">
<ref name="Interval"/>
</start>
<define name="Interval">
<element name="Interval">
<ref name="Interval.type"/>
</element>
</define>
    <!--
     *** arg ***
     
     Definition of the the arg role for Intervals
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)
     in KR Reaction RuleML: (Time | Spatial | Interval |  Event | Action | Situation | Ind | Data | Skolem | Var | Reify | Expr | Plex | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator) )
     not used in PR Reaction RuleML     
     ECA Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="arg_interval.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="arg_interval.content">
        <choice>
            <ref name="interval_primitives.content"/>
        </choice>
    </define>
    <define name="arg_interval.type">
        <ref name="arg_interval.content"/>
        <ref name="arg_interval.attlist"/>
    </define>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     content model:  xs:any*
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
     
     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <define name="interval_anycontent.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="interval_anycontent.content">
        <choice>
            <zeroOrMore>
<element>
<anyName/>
<text/>
</element>
</zeroOrMore>
        </choice>
    </define>
    <define name="interval_anycontent.type">
        <ref name="interval_anycontent.content"/>
        <ref name="interval_anycontent.attlist"/>
    </define>
    <!-- include spatial-temporal and interval operators from the algebra modules of reaction ruleml   -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                                spatial-temporal-interval algebra
            module part of Reaction RuleML    This is the XML Schema of the algebra module for
            Reaction RuleML    File: spatial_temporal_interval_algebra_module.xsd    Version: 1.0
            Last Modification: 2011-03-22        This schema declares the following Reaction RuleML
            elements and attributes:                                      Operator (generic
            operator)                   at (general role "at Time | Spatial | Interval)
            Spatial, Temporal, Interval Function Constructs                                       *
            After                   * Before       * Every                   * Any
            * Timer                                                         (Allen's) Interval
            Relations                                      * During                   * Overlaps
            * Starts                   * Precedes                   * Succeeds                   *
            Meets                   * Equal                   * Finishes
            The approach is modelled after that used in "Modularization of XHTML in XML Schema"
            WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-22T29:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--(After | Before | Any | Every | Timer | Operator)-->
    <define name="spatial_temporal_algebra_group.content">
        <choice>
            <ref name="After"/>
            <ref name="Before"/>
            <ref name="Every"/>
            <ref name="Any"/>
            <ref name="Timer"/>
            <element name="Operator">
<ref name="Any.type"/>
</element>
        </choice>
    </define>
    <!-- (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes | Operator) -->
    <define name="interval_algebra_group.content">
        <choice>
            <ref name="During"/>
            <ref name="Overlaps"/>
            <ref name="Starts"/>
            <ref name="Precedes"/>
            <ref name="Succeeds"/>
            <ref name="Meets"/>
            <element name="Equal">
<ref name="IntervalAlgebraOperator.type"/>
</element>
            <ref name="Finishes"/>
            <element name="Operator">
<ref name="IntervalAlgebraOperator.type"/>
</element>
        </choice>
    </define>
    <!--
      *** at ***
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-at
      
	  Note: In Situation Calculus the time is a situation (the history of occured situations as a finite sequence of the events/actions) 	
	
      content model: 
      in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
      in ECA Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operator))
      in CEP Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operator))
      
      attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="at.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="at.content">
        <choice>
            <ref name="time_primitives.content"/>
        </choice>
    </define>
    <define name="at.type">
        <ref name="at.content"/>
        <ref name="at.attlist"/>
    </define>
    <start combine="choice">
<ref name="at"/>
</start>
<define name="at">
<element name="at">
<ref name="at.type"/>
</element>
</define>
    <!--
      *** After / Before***

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-After
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Before

      X after Y  / X before Y
      
      Note: Y might be absolute or relative, e.g. "after 2 days", "2 days after X"  

      content model: 
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] ))
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)?])) 	  

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="After.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="After.content">
        
            <ref name="Interval.content"/>
        
    </define>
    <define name="After.type">
        <ref name="After.content"/>
        <ref name="After.attlist"/>
    </define>
    <start combine="choice">
<ref name="After"/>
</start>
<define name="After">
<element name="After">
<ref name="After.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Before"/>
</start>
<define name="Before">
<element name="Before">
<ref name="After.type"/>
</element>
</define>
    <!--
      *** Every ***
      
      Every X 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Every
      
      Note:  X is often a relative, e.g. "every Monday", "every 2 meters" 
      
      content model:
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation) ))
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Every.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Every.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<choice>
                <element name="arg">
<ref name="arg_interval.type"/>
</element>
                <ref name="interval_primitives.content"/>
                <element name="content">
<ref name="interval_anycontent.type"/>
</element>
            </choice>
</optional>
        
    </define>
    <define name="Every.type">
        <ref name="Every.content"/>
        <ref name="Every.attlist"/>
    </define>
    <start combine="choice">
<ref name="Every"/>
</start>
<define name="Every">
<element name="Every">
<ref name="Every.type"/>
</element>
</define>
    <!--
      *** Any ***
      
      Any X1,..Xn
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Any
            
      e.g. "at any Saturday and Sunday"     
           
      content model: 
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg*] | content(xs:any)* | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)* ))
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Any.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Any.content">
        
            <ref name="meta-roles.content"/>
            <optional>
<choice>
                <oneOrMore>
<element name="arg">
<ref name="arg_interval.type"/>
</element>
</oneOrMore>
                <oneOrMore>
<ref name="interval_primitives.content"/>
</oneOrMore>
                <oneOrMore>
<element name="content">
<ref name="interval_anycontent.type"/>
</element>
</oneOrMore>
            </choice>
</optional>
        
    </define>
    <define name="Any.type">
        <ref name="Any.content"/>
        <ref name="Any.attlist"/>
    </define>
    <start combine="choice">
<ref name="Any"/>
</start>
<define name="Any">
<element name="Any">
<ref name="Any.type"/>
</element>
</define>
    <!--
      *** (Recurring) Timer ***
      
      After X Every Y
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Recurring
      
      Note: X and Y might be relative, e.g. after 1 hour every hour (recurring timer)
      
      content model: 
         
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] )) 
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
       
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="Timer.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Timer.content">
        
            <ref name="Interval.content"/>
        
    </define>
    <define name="Timer.type">
        <ref name="Timer.content"/>
        <ref name="Timer.attlist"/>
    </define>
    <start combine="choice">
<ref name="Timer"/>
</start>
<define name="Timer">
<element name="Timer">
<ref name="Timer.type"/>
</element>
</define>
    <!--
      *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes) ***
      
      operator(Interval, Interval)
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-During
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Overlaps
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Starts
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Precedes
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Succeeds
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Meets
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Finishes
      
      content model: 
      ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg] | [Interval, Interval])
      
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="IntervalAlgebraOperator.attlist">
        <ref name="operator-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="IntervalAlgebraOperator.content">
        
            <ref name="meta-roles.content"/>
            
                <choice>
                    <element name="arg">
<ref name="arg_interval.type"/>
</element>
                    <ref name="Interval"/>
                </choice>
                <choice>
                    <element name="arg">
<ref name="arg_interval.type"/>
</element>
                    <ref name="Interval"/>
                </choice>
            
        
    </define>
    <define name="IntervalAlgebraOperator.type">
        <ref name="IntervalAlgebraOperator.content"/>
        <ref name="IntervalAlgebraOperator.attlist"/>
    </define>
    <start combine="choice">
<ref name="During"/>
</start>
<define name="During">
<element name="During">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Overlaps"/>
</start>
<define name="Overlaps">
<element name="Overlaps">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Starts"/>
</start>
<define name="Starts">
<element name="Starts">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Precedes"/>
</start>
<define name="Precedes">
<element name="Precedes">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Succeeds"/>
</start>
<define name="Succeeds">
<element name="Succeeds">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Meets"/>
</start>
<define name="Meets">
<element name="Meets">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <start combine="choice">
<ref name="Finishes"/>
</start>
<define name="Finishes">
<element name="Finishes">
<ref name="IntervalAlgebraOperator.type"/>
</element>
</define>
    <!-- include test suites   -->
    <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0">
                Test and Proof module part of Reaction RuleML.
            This is the XML Schema Test module for Reaction RuleML.    File: test_module.xsd
            Version: 1.0    Last Modification: 2011-07-20        Further information - see RBSLA
            project (http://rbsla.ruleml.org)    ContractLog framework VVI Testing:
            http://rbsla.ruleml.org/docs/ContractLog_VVI.pdf        This schema declares the
            following Reaction RuleML elements and attributes:            * Test    * vvi    *
            TestSuite    * testbase    * TestItem    * Answer     * formula (Answer)    *
            expectedResult        The approach is modelled after that used in "Modularization of
            XHTML in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].       
        
        
            <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Reaction RuleML Schema</dc:title>
            <dc:version xmlns:dc="http://purl.org/dc/elements/1.1/">1.0</dc:version>
            <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/">RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">custom-built main module for Reaction RuleML</dc:description>
            <dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2011-03-29T23:11:17-0300</dc:date>
            <dc:language xmlns:dc="http://purl.org/dc/elements/1.1/">en</dc:language>
            <dcterms:rights xmlns:dcterms="http://purl.org/dc/terms/">LGPL-3.0</dcterms:rights>
            <dc:relation xmlns:dc="http://purl.org/dc/elements/1.1/">http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        
    </a:documentation>
    <!--
      *** Test ***
      A Test action/primitive that provides the syntax for Verification, Validation and Integrity (VVI) Testing.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Test
      
      An optional scope (<scope>) can be defined so that the test applies only to the scope (constructed view) on the knowledge base.

      content model: 
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (vvi | Entails | TestItem | TestSuite)*)
      
      Test has the following attributes:
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?   
	-->
    <define name="Test.attlist">
        <ref name="action-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="Test.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <ref name="vvi"/>
                <ref name="vvi.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="Test.type">
        <ref name="Test.content"/>
        <ref name="Test.attlist"/>
    </define>
    <start combine="choice">
<ref name="Test"/>
</start>
<define name="Test">
<element name="Test">
<ref name="Test.type"/>
</element>
</define>
    <!--
     *** vvi ***
     
     vvi role - "verification, validation, integrity" tests
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-vvi
     
     content model: ( Entails | TestItem | TestSuite )
     
      vvi has the following attributes:
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
-->
    <define name="vvi.attlist">
        <ref name="edge-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="vvi.content">
        <choice>
            <ref name="Entails"/>
            <ref name="TestSuite"/>
            <ref name="TestItem"/>
        </choice>
    </define>
    <define name="vvi.type">
        <ref name="vvi.content"/>
        <ref name="vvi.attlist"/>
    </define>
    <start combine="choice">
<ref name="vvi"/>
</start>
<define name="vvi">
<element name="vvi">
<ref name="vvi.type"/>
</element>
</define>
    <!--
     *** testsbase ***
     
     base role for the test assertion | consultation base
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-testbase
     
     content model: ( Consult | Assert )
     
      base has the following attributes:
         attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
-->
    <define name="testbase.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="testbase.content">
        <choice>
            <ref name="Consult"/>
            <ref name="Assert"/>
        </choice>
    </define>
    <define name="testbase.type">
        <ref name="testbase.content"/>
        <ref name="testbase.attlist"/>
    </define>
    <start combine="choice">
<ref name="testbase"/>
</start>
<define name="testbase">
<element name="testbase">
<ref name="testbase.type"/>
</element>
</define>
    <!--
      *** TestSuite ***
      A TestSuite consisting of the assertion | consultation base (test assertions) and the VVI tests (integrity entailments, test items or nested test suites 

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestSuite

      content model: 
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (testbase | Consult | Assert), (vvi | Entails | TestItem | TestSuite)*)
      
      TestSuite has the following attributes:
      attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <define name="TestSuite.attlist">
        <ref name="group-formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="TestSuite.content">
        
            <ref name="meta-roles.content"/>
            <zeroOrMore>
<choice>
                <ref name="testbase"/>
                <ref name="Assert"/>
                <ref name="Consult"/>
            </choice>
</zeroOrMore>
            <zeroOrMore>
<choice>
                <ref name="vvi"/>
                <ref name="vvi.content"/>
            </choice>
</zeroOrMore>
        
    </define>
    <define name="TestSuite.type">
        <ref name="TestSuite.content"/>
        <ref name="TestSuite.attlist"/>
    </define>
    <start combine="choice">
<ref name="TestSuite"/>
</start>
<define name="TestSuite">
<element name="TestSuite">
<ref name="TestSuite.type"/>
</element>
</define>
    <!--
      *** TestItem ***
      TestItem describing one particular test consisting of the test act (typically a Query) and the expected result (the expected Answer with the predefined expected truth valuation (<degree>) and results/variable bindings)
      
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestItem
      
      content model:
 		 
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act|Query|Assert|Retract|Update|Send|Receive|Consult|Test|Action), (expectedResult|Answer) )

     attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	  
    -->
    <define name="TestItem.attlist">
        <ref name="group-formula-interface.attlist"/>
        <ref name="node-element.attlist"/>
        <ref name="xml.attlist"/>
    </define>
    <define name="TestItem.content">
        
            <ref name="meta-roles.content"/>
            
                <choice>
                    <ref name="act"/>
                    <ref name="act.content"/>
                </choice>
                <choice>
                    <ref name="expectedResult"/>
                    <ref name="expectedResult.content"/>
                </choice>
            
        
    </define>
    <define name="TestItem.type">
        <ref name="TestItem.content"/>
        <ref name="TestItem.attlist"/>
    </define>
    <start combine="choice">
<ref name="TestItem"/>
</start>
<define name="TestItem">
<element name="TestItem">
<ref name="TestItem.type"/>
</element>
</define>
    <!--
     *** expectedResult***
     
     Definition of the the enclosed role for Send and Receive actions
     
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-expectedResult
     
     content model:  
      in CEP Reaction RuleML: (Answer)
      
      attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

-->
    <define name="expectedResult.attlist">
        <ref name="xml.attlist"/>
    </define>
    <define name="expectedResult.content">
        <choice>
            <ref name="Answer"/>
        </choice>
    </define>
    <define name="expectedResult.type">
        <ref name="expectedResult.content"/>
        <ref name="expectedResult.attlist"/>
    </define>
    <start combine="choice">
<ref name="expectedResult"/>
</start>
<define name="expectedResult">
<element name="expectedResult">
<ref name="expectedResult.type"/>
</element>
</define>
    <!--
     metadata group
     
	This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
	
     content model: (meta*, scope*, guard )
          
	-->
    <define name="metadata.content">
        
            <zeroOrMore>
<ref name="meta"/>
</zeroOrMore>
            <zeroOrMore>
<ref name="scope"/>
</zeroOrMore>
            <zeroOrMore>
<ref name="guard"/>
</zeroOrMore>
        
    </define>
    <!--
     interface group
     
     This internal group defines the interface signature and the evaluation semantics
     
     content model: (evaluation*, signature* )
          
	-->
    <define name="interface.content">
        
            <zeroOrMore>
<ref name="evaluation"/>
</zeroOrMore>
            <zeroOrMore>
<ref name="signature"/>
</zeroOrMore>
        
    </define>
    <!--
     instance group
     
     This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
     
     content model: (qualification*, quantification*, oid? )
          
	-->
    <define name="instance.content">
        
            <zeroOrMore>
<ref name="qualification"/>
</zeroOrMore>
            <zeroOrMore>
<ref name="quantification"/>
</zeroOrMore>
            <optional>
<ref name="oid"/>
</optional>
        
    </define>
    <!--
         
     An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
    
    
     content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
          
	-->
    <define name="meta-roles.content">
        
            <ref name="metadata.content"/>
            <ref name="interface.content"/>
            <ref name="instance.content"/>
        
    </define>
    <!--
         
     An internal group for the implementation of a rule in the Reaction RuleML language
    
    
     content model:
     
     in DR Reaction RuleML: 
     
     ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
          
	-->
    <define name="rule-implementation.content">
        <choice>
            <ref name="DerivationRule.content"/>
        </choice>
    </define>
    <!--
         
     An internal group for the query connectives in the Reaction RuleML language
    
     content model: (Operator | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <define name="query-connective.content">
        <choice>
            <element name="Operator">
<ref name="ConnectiveOperator.type"/>
</element>
            <element name="And">
<ref name="And-query.type"/>
</element>
            <element name="Or">
<ref name="Or-query.type"/>
</element>
            <ref name="Negation"/>
            <ref name="Naf"/>
            <ref name="Neg"/>
            <ref name="Equal"/>
        </choice>
    </define>
    <!--
         
     An internal group for the inner connectives in the Reaction RuleML language
    
    
     content model: (Operator | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <define name="inner-connective.content">
        <choice>
            <element name="Operator">
<ref name="ConnectiveOperator.type"/>
</element>
            <element name="And">
<ref name="And-inner.type"/>
</element>
            <element name="Or">
<ref name="Or-inner.type"/>
</element>
            <ref name="Negation"/>
            <ref name="Naf"/>
            <ref name="Neg"/>
            <ref name="Equal"/>
        </choice>
    </define>
    <!--
         
     An internal group for the outer connectives in the Reaction RuleML language
    
    
     content model: (Operator | Negation | Neg | Equal )
          
	-->
    <define name="outer-connective.content">
        <choice>
            <element name="Operator">
<ref name="ConnectiveOperator.type"/>
</element>
            <ref name="Negation"/>
            <ref name="Neg"/>
            <ref name="Equal"/>
        </choice>
    </define>
    <!--
         
     An internal group for the query quantifiers in the Reaction RuleML language
    
     content model: (Exists )
          
	-->
    <define name="query-quantifier.content">
        <choice>
            <ref name="Exists"/>
        </choice>
    </define>
    <!--
         
     An internal group for the inner quantifiers in the Reaction RuleML language
    
    
     content model: (Forall | Exists | Quantifier)
          
	-->
    <define name="inner-quantifier.content">
        <choice>
            <element name="Forall">
<ref name="Forall-quantifier.type"/>
</element>
            <element name="Exists">
<ref name="Exists-quantifier.type"/>
</element>
            <ref name="Quantifier"/>
        </choice>
    </define>
    <!--
         
     An internal group for the outer quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall  )
          
	-->
    <define name="outer-quantifier.content">
        <choice>
            <ref name="Forall"/>
        </choice>
    </define>
    <!--
         
     An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the predicate sorts Time, Spatial and Interval
    
     content model: (Atom | Time | Spatial | Interval)
          
	-->
    <define name="extended-signature-predicate-sorts.content">
        <choice>
            <element name="Atom">
<ref name="Atom.type"/>
</element>
            <ref name="Time"/>
            <ref name="Spatial"/>
            <ref name="Interval"/>
        </choice>
    </define>
    <!--
         
     An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the function sorts Time, Spatial and Interval
    
     content model: (Ind | Data | Expr | Plex | Time | Spatial | Interval)
          
	-->
    <define name="extended-signature-function-sorts.content">
        <choice>
            <ref name="Ind"/>
            <ref name="Data"/>
            <ref name="Expr"/>
            <ref name="Plex"/>
            <ref name="Time"/>
            <ref name="Spatial"/>
            <ref name="Interval"/>
        </choice>
    </define>
    <!-- An internal group for the time primitives for interpretation as time
		content model: 
		in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operator))
	-->
    <define name="time_primitives.content">
        <choice>
            <ref name="arg.content"/>
            <ref name="spatial_temporal_algebra_group.content"/>
        </choice>
    </define>
    <!-- An internal group for the spatial primitives for interpretation as spatial
		content model: 
		in DR Reaction RuleML ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operator))
	-->
    <define name="spatial_primitives.content">
        <choice>
            <ref name="arg.content"/>
            <ref name="spatial_temporal_algebra_group.content"/>
        </choice>
    </define>
    <!-- Interval primitives
		content model: 
		in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operator))  -->
    <define name="interval_primitives.content">
        <choice>
            <ref name="arg.content"/>
            <ref name="interval_algebra_group.content"/>
        </choice>
    </define>
    <!-- An internal group for the situation primitives for interpretation as situation
		content model: 
		in DR Reaction RuleML: ()
	-->
    <define name="situation_primitives.content">
        <choice> <empty/> </choice>
    </define>
    <!-- An internal group for the event primitives for interpretation as event
		content model: 
		in DR Reaction RuleML: ()
	-->
    <define name="event_primitives.content">
        <choice> <empty/> </choice>
    </define>
    <!-- An internal group for events
		content model:
		
		DR Reaction RuleML ( )-->
    <define name="event_group.content">
        <choice> <empty/> </choice>
    </define>
    <!-- An internal group for the action primitives for interpretation as action
		content model: 
		in DR Reaction RuleML: ()
	-->
    <define name="action_primitives.content">
        <choice> <empty/> </choice>
    </define>
    <!-- An internal group for actions
		content model:
		
		DR Reaction RuleML ( )-->
    <define name="action_group.content">
        <choice> <empty/> </choice>
    </define>
    <!-- An internal group for the imports of the consult primitive
		content model: 
		in DR Reaction RuleML: (payload | RuleML | Reify | Var)
	-->
    <define name="consult_imports.content">
        <choice>
            <ref name="payload"/>
            <ref name="payload.content"/>
        </choice>
    </define>
    <!-- An internal group for the performative primitives
		content model: 
		in DR Reaction RuleML: (Consult|Assert|Retract|Query|Answer|Test)
	-->
    <define name="performative_primitives.content">
        <choice>
            <ref name="Consult"/>
            <ref name="Assert"/>
            <ref name="Retract"/>
            <ref name="Query"/>
            <ref name="Answer"/>
            <ref name="Test"/>
        </choice>
    </define>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: reasoning (in DR Reaction RuleML)
	 optional attribute
-->
    <define name="style.attrib">
        <optional>
<attribute name="style">
<ref name="style.datatype"/>
</attribute>
</optional>
    </define>

</grammar>