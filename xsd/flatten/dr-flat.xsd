<?xml version="1.0" encoding="UTF-8"?>
<xs:schema elementFormDefault="qualified" targetNamespace="http://ruleml.org/spec"
    xmlns="http://ruleml.org/spec" xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:import namespace="http://www.w3.org/XML/1998/namespace"
        schemaLocation="../modules/xml_module.xsd"/>
    
    <!--
		*** RuleML ***
		The n-ary top-level of a RuleML document.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-RuleML
			 
	DR/KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Consult|Assert|Retract|Query|Answer|Test)* )
	PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Assert|Retract|Update|Consult|Query|Answer|Test|Action)* )
	ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act | Assert|Retract|Update|Query|Consult|Answer|Test|Action)* )
	CEP Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act|Assert|Retract|Update|Query|Answer|Send|Receive|Consult|Test|Action)* )
			
 	 Note: key and keyref object identifier are defined to be unique under the RuleML document root
 	 
 	 @vocab: an IRI that defines the mapping to use when a type term (e.g. a frame signature type) is referenced in an attribute value
 	 @prefix: a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
				
	attributes: @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="RuleML.attlist">
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="RuleML.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="act"/>
                <xs:group ref="act.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="RuleML.type">
        <xs:group ref="RuleML.content"/>
        <xs:attributeGroup ref="RuleML.attlist"/>
    </xs:complexType>
    <xs:element name="RuleML" type="RuleML.type">
        <!-- key object identifiers and key object references defined on the top level -->
        <xs:unique name="keyOID">
            <xs:selector xpath=".//*"/>
            <xs:field xpath="@key"/>
        </xs:unique>
        <xs:keyref name="keyOIDref" refer="keyOID">
            <xs:selector xpath=".//*"/>
            <xs:field xpath="@keyref"/>
        </xs:keyref>
    </xs:element>
    <!--
    *** act ***
    The act role of the root element (<RuleML>).
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-act
    
    content model  
    DR/KR Reaction RuleML (Consult|Assert|Retract|Query|Answer|Test)
    PR Reaction RuleML (Assert|Retract|Update|Consult|Query|Answer|Test|Action)
    ECA Reaction RuleML (Assert|Retract|Update|Query|Consult|Answer|Test|Action)
    CEP Reaction RuleML (Assert|Retract|Update|Query|Answer|Send|Receive|Consult|Test|Action)
    
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:group name="act.content">
        <xs:choice>
            <xs:group ref="performative_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:attributeGroup name="act.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:complexType name="act.type">
        <xs:group ref="act.content"/>
        <xs:attributeGroup ref="act.attlist"/>
    </xs:complexType>
    <xs:element name="act" type="act.type"/>
    <!--
      *** Consult ***
      Consult (import) performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Consult
      
      dynamically "consults" (imports) knowledge resource, e.g. a message, documents or external resource (with the @iri attribute).
      
      content model:
 		 
 		 in DR Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in KR Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in PR Reaction RuleML  (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
 		 in ECA Reaction RuleML (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (payload | RuleML | Reify | Var))
	   in CEP Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ((payload | RuleML | Reify | Var) | (enclosed | Message))* )
	  
      Consult has the following attributes:
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 

    -->
    <xs:attributeGroup name="Consult.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Consult.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:group ref="consult_imports.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Consult.type">
        <xs:group ref="Consult.content"/>
        <xs:attributeGroup ref="Consult.attlist"/>
    </xs:complexType>
    <xs:element name="Consult" type="Consult.type"/>
    <!--
     *** payload ***
     
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-payload
     
     content model: (RuleML | Reify | Var)
     
     attributes:  @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="payload.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="payload.content">
        <xs:choice>
            <xs:element ref="RuleML"/>
            <!-- a RuleML knowledge base -->
            <xs:element ref="Reify"/>
            <!-- reified knowledge as payload -->
            <xs:element ref="Var"/>
            <!-- for  binding knowledge to variables in meta programming -->
        </xs:choice>
    </xs:group>
    <xs:complexType name="payload.type">
        <xs:group ref="payload.content"/>
        <xs:attributeGroup ref="payload.attlist"/>
    </xs:complexType>
    <xs:element name="payload" type="payload.type"/>
    <!--
		*** Assert ***
		A KQML-like performative acting as a wrapper specifying that its content is
		asserted, making an 'implicit <Rulebase>' assumption.

		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Assert 

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )*)
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal )*) 
    ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action  )*)

   attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
  -->
    <xs:attributeGroup name="Assert.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Assert.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Assert.type">
        <xs:group ref="Assert.content"/>
        <xs:attributeGroup ref="Assert.attlist"/>
    </xs:complexType>
    <xs:element name="Assert" type="Assert.type"/>
    <!--
		*** Retract ***
		A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
		content is to be deleted, making an 'implicit <Rulebase>' assumption.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Retract

		content model:
		DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )*)
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal )*) 
 		ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action  )*)   

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?   
  -->
    <xs:attributeGroup name="Retract.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Retract.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Retract.type">
        <xs:group ref="Retract.content"/>
        <xs:attributeGroup ref="Retract.attlist"/>
    </xs:complexType>
    <xs:element name="Retract" type="Retract.type"/>
    <!--
      *** Update ***
      Update action
      
      See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Update
      
      content model:
      
      in PR Reaction RuleML
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal),
		 (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal)? )
		 
	  in ECA Reaction RuleML
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal |  Negation | Neg | Time | Spatial | Interval | Event | Action),
		 (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal |  Negation | Neg | Time | Spatial | Interval | Event | Action)? )
	  
      Update has the following attributes:
      @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
      
-->
    <xs:attributeGroup name="Update.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Update.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence>
                <xs:choice>
                    <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                    <xs:group ref="formula-assert.content"/>
                </xs:choice>
                <xs:choice minOccurs="0">
                    <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                    <xs:group ref="formula-assert.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Update.type">
        <xs:group ref="Update.content"/>
        <xs:attributeGroup ref="Update.attlist"/>
    </xs:complexType>
    <xs:element name="Update" type="Update.type"/>
    <!--
		*** Query ***
		A KQML-like performative acting as a wrapper specifying that its content is
		queried, making an 'implicit <Rulebase>' assumption.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Query

		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
		PR Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )* )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Atom | Rulebase | And | Or | Entails |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )* )		

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="Query.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Query.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-query.type"/>
                <xs:group ref="formula-query.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Query.type">
        <xs:group ref="Query.content"/>
        <xs:attributeGroup ref="Query.attlist"/>
    </xs:complexType>
    <xs:element name="Query" type="Query.type"/>
    <!--
      *** Answer ***
      Answer performative / action 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Answer
      
      It delivers the answer to a Query . The answer is given in terms of solved formulas, e.g.
      
      as a <Rulebase> that contains just 'solved' equations with the variable bindings
      
	  <Rulebase>
  		<Equal><Var>x</Var><Ind>a</Ind></Equal>
  		<Equal><Var>y</Var><Ind>b</Ind></Equal>
  		<Equal><Var>z</Var><Ind>c</Ind></Equal>
	  </Rulebase>
	  
	  as ground fact <Atom> matching the query / goal 
	  
	  <Atom>
	  	<Rel>p</Rel>
	  	<Ind>a</Ind>
	  	<Ind>b</Ind>
	  	<Ind>c</Ind>
	  </Atom>
	  
	  as solved ground entailments <Entails> of the answer from the queried (ground or instantiated / forward chained) rule base  
	  
	  With the optional <degree> role a truth/uncertainty value (between 0.0 and 1.0; 
	  with the truth values "1" for true and "0" for false in two-valued logics and "0.5" for unknown in three-valued logics) can be assigned to the answer. 
	  
	  An answer maybe be also just referenced by the local @key-@keyref mechanism  
	  or by the optional @iri attribute, in case of externally published answers. 
	  
	  With the optional @type attribute an answer type can be specified. 
	  The @safety optionally defines if the answer (event) is interrupting or non-interrupting 
	  and the @card attribute optionally defines the number of results contained in an Answer.
	   
	  
      content model:
 		 
	  in CEP Reaction RuleML
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree? (formula | Operation | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)* )
	  
      Answer has the following attributes:
    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
    -->
    <xs:attributeGroup name="Answer.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Answer.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-answer.type"/>
                <xs:group ref="formula-answer.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Answer.type">
        <xs:group ref="Answer.content"/>
        <xs:attributeGroup ref="Answer.attlist"/>
    </xs:complexType>
    <xs:element name="Answer" type="Answer.type"/>
    <!--
		*** formula ***
		The formula role of a performative (<Answer>).
		
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
		
		content model (below Answer formula): 
		(Operation | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action)
  		
		Other (context-sensitive) versions of <formula> are in the
		connective and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:group name="formula-answer.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Entails"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-answer.type">
        <xs:group ref="formula-answer.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <!--
		*** formula ***
		The formula role of a performative (<Assert>, <Retract> or <Query>).

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula

		content model (below Assert formula): 
		DR Reaction RuleML (Operation | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval )
		KR Reaction RuleML (Operation | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Forall |  Time | Spatial | Interval  | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
		PR Reaction RuleML (Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
		ECA Reaction RuleML (Operation | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg |  Time | Spatial | Interval | Event | Action )
		
		content model (below Query): 
		DR Reaction RuleML (Operation | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval )
		KR Reaction RuleML (Operation | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Exists |  Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )
    PR Reaction RuleML (Operation | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal | Action )
		ECA Reaction RuleML (Operation | Rulebase | Atom | Entails | And | Or | Equal | Negation | Naf | Neg | Time | Spatial | Interval | Event | Action )    

		Other (context-sensitive) versions of <formula> are in the
		connective and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <!-- the (empty) attribute list is declared in the connective module -->
    <xs:group name="formula-assert.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Implies"/>
            <xs:element ref="Rule"/>
            <xs:element ref="Equivalent"/>
            <xs:element ref="Entails"/>
            <xs:group ref="outer-quantifier.content"/>
            <xs:group ref="outer-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="formula-query.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
            <xs:element ref="Entails"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-assert.type">
        <xs:group ref="formula-assert.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:complexType name="formula-query.type">
        <xs:group ref="formula-query.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for description-related
            RuleML       elements. File: desc_module.xsd Version: 1.0 Last Modification: 2012-05-17
            [Adrian Paschke]       This module declares the following RuleML elements:
            * meta            descriptive metadata        * scope           scope  (e.g. for scoped
            reasoning)        * guard         guard (e.g. for guard constraints in scoped reasoning)
            * evaluation      semantic profile        * signature       interface signature, pattern
            definition,       * qualification   qualification, e.g. priorities, validity, strategy
            * quantification  quantification       * oid              See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2012-05-17T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
  *** oid ***
  An optional object identifier for an atomic formula, expression or the unifed terms
  of the SWSL branch, as needed for PSOA semantics.
  Note that oids are not required to be unique within a rulebase.
  
  See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-oid
  
  content model: 
  in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
  in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
  in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex)
  in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
  
  attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="oid.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="oid.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element ref="Skolem"/>
            <xs:element ref="Reify"/>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="oid.type">
        <xs:group ref="oid.content"/>
        <xs:attributeGroup ref="oid.attlist"/>
    </xs:complexType>
    <xs:element name="oid" type="oid.type"/>
    <!-- 
     *** meta ***     
     
    An optional container for meta-knowledge about a Node.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-meta
    
	Used for descriptive Metadata annotations in Reaction RuleML
	
     content model: 
     in DR Reaction RuleML: ( Operation | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
     in KR Reaction RuleML: ( Operation | Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
     in PR Reaction RuleML: ( Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
     in ECA Reaction RuleML: ( Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )

     Multiple Metadata annotations are possible by repreating <meta>
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="meta.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="meta.content">
        <xs:choice>
            <xs:group ref="formula-assert.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="meta.type">
        <xs:group ref="meta.content"/>
        <xs:attributeGroup ref="meta.attlist"/>
    </xs:complexType>
    <xs:element name="meta" type="meta.type"/>
    <!--
     *** scope ***
     
     metadata-based scope definition defined over the metadata annotations and the qualifications annotations.
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-scope
     
     Note: scope reasoning in rules can use the metadata scopes to define a constructive view on the rules and facts in the KB.    
     The scoped rule/literal goal only applies in this scope (scoped reasoning/processing)
     
     For an implementation of scoped reasoning as a mechanism to dynamicaly create a scope (a constructive view)
     on the knowledge base and to do scoped reasoning on this scope see the Prova rule engine (http://prova.ws).
     
     Example:
     @src(kb1) @author("Adrian Paschke") @validity([2011-03-20, 2011-04-20]) @label(fact1) fact1(constant1).
     @src(kb2) @author("Alex Kozlenkov") @validity([2011-01-20, 2011-03-20]) @label(fact2) fact2(constant2).
     
     @src(rb1) @label(rule1) rule1(Y) :- @validity(VTime) @authors("Adrian Paschke") fact1(Y) [between(SysTime,VTime)] 
     
     In this example all knowledge is annotated with predefined (@src, ...) and user-defined metadata annotations (@author, @validity, ...). 
     User-defined metadata annotations can be arbitrary name/value pairs described as predicates. The literal "fact1" in the body
     of "rule1" is a scoped literal defining a scope over knowledge in the knowledge base with the scope constraints
     @validity and @author. If such knowledge is found in the KB the meta data value (an Interval) for @validity
     is bound to the variable "VTime" and used in the guard constraint [...] on the literal. The guard is stating that 
     the actual system time should be  within the validity interval. The second scope constraint is directly compared 
     to the constant value "Adrian Paschke".
     The sub-goal literal "fact1" in the rule condition is then applied only on the selected scope 
     (a constructive view on the overall knowledge base which is selected by the metadata scope of the literal) and not on the 
     overal knowledge. It is possible to define scopes for modules (e.g. sets of knowledge such as a rule-base/rule-set or 
     an knowledge updates (assert, retracts) by using the meta data identifier such as @src or @label. Such identifiers can
     be also used for transactional logics.
     
     In Reaction RuleML general metadata annotations (descriptive metadata) are defined under the <meta> tag role and
     qualifying metadata which qualify the rule (such as validity in the above example) are defined under the <qualification> tag.
     The @key attribute which defines a unique identifier for knowledge in the knowledge base is used for a 
     modular nested structuring of the knowledge base. The @key of e.g. <Assert key=""> or <Rulebase key=""> acts as module identifier 
     (which in Prova is denoted by the predefined @src metadata).
     
	 Scopes in Reaction RuleML can be defined within the <scope> role tag on descriptive metadata <meta> and qualifying metadata <qualification> as well as
	 on the unique identifier @key of the knowledge in the knowledge base (<Assert key="">, <Rulebase key="">, <Rule key="">, <Atom key="">)
	 by referencing it with the @keyref attribute.
	 
	 There is a nesting of scopes. Scopes defined on the more general level automatically apply to the inner knowledge. For instance, a scope
	 defined on the level of a <Rulebase> automatically applies to all goal literals of the <Rule>s in the rulebase. Inner scopes
	 overwrite the outer scope. For instance a scope defined on <Assert> becomes overwritten by an inner scope defined on a <Rule> which is within the
	 this asserted knowledge module. That is the goal literals within this rules are automatically applying the innter scope and not the outer scope.
	 
	 Note: the old approach which used <oid> to define a scope has been replaces by the key-keyref approach in Reaction RuleML 1.0
     
     Note: multiple scopes can be defined by repeating the <scope> role element
     Note: an empty scope either assumes the outer scope or an existing scope needs to be explicity referenced by keyref
     
     content model: 
     DR Reaction RuleML  ( (Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
     KR Reaction RuleML  ( Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
     PR Reaction RuleML  ( Operation | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)?     
     ECA Reaction RuleML  ( (Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )

  attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="scope.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="scope.content">
        <xs:choice>
            <xs:group minOccurs="0" ref="formula-query.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="scope.type">
        <xs:group ref="scope.content"/>
        <xs:attributeGroup ref="scope.attlist"/>
    </xs:complexType>
    <xs:element name="scope" type="scope.type"/>
    <!--
     *** guard ***     
     
	guard constraints 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-guard
	
     content model: 
     in DR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
     in KR Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     in PR Reaction RuleML: ( Operation | Atom | And | Or | Equal | Negation | Naf )
     in ECA Reaction RuleML: ( Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)    
    
    attribute: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="guard.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="guard.content">
        <xs:choice>
            <xs:group ref="if.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="guard.type">
        <xs:group ref="guard.content"/>
        <xs:attributeGroup ref="guard.attlist"/>
    </xs:complexType>
    <xs:element name="guard" type="guard.type"/>
    <!--
     *** evaluation ***
     
     The intended evaluation semantics, e.g. model theoretic semantic, proof-semantics, execution semantic such as selection and consumption policies etc.
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-evaluation
     
     Note: multiple Profiles can be defined by repreating the <evaluation> role element
     The Profiles can be defined externally by using the Profile attributes to point to it or internally by defining it in XML (xs:any)
     
     content model: (Profile )     
  
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="evaluation.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="evaluation.content">
        <xs:sequence>
            <xs:element ref="Profile"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="evaluation.type">
        <xs:group ref="evaluation.content"/>
        <xs:attributeGroup ref="evaluation.attlist"/>
    </xs:complexType>
    <xs:element name="evaluation" type="evaluation.type"/>
    <!--
     *** signature ***
     
     The signature defines the signature of knowledge (formula and terms) with optional input / output mode declarations. The signature declaration can act as public interface and
	can be published together with the intended evaluation semantics. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-signature
	
	Note: In PR, RR and CEP reaction rules the signature is extended with events and actions
	for defining the event templates (i.e. the event form / event descriptor which corresponds to the event type/class. The event template is used for
	pattern machting, i.e. in the on part of a reaction rule it triggers the reaction rule if the template matches with required event instances, which are
	instantiations of the event type / class to which make up the required properties of the event template.
		
	Multiple signatures are possible by repreating the <signature> element
	
     content model: 
     DR Reaction RuleML  ( (Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval)? )
     KR Reaction RuleML  ( Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)? )
     PR Reaction RuleML  ( Operation | Rulebase | Atom | Entails | And | Or | Negation | Naf | Equal)? 
     ECA Reaction RuleML  ( (Operation | Atom | Rulebase | And | Or | Entails | Exists |  Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)? )         

  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="signature.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="signature.content">
        <xs:choice>
            <xs:group ref="formula-query.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="signature.type">
        <xs:group ref="signature.content"/>
        <xs:attributeGroup ref="signature.attlist"/>
    </xs:complexType>
    <xs:element name="signature" type="signature.type"/>
    <!--
     *** qualification ***
     
    Definition of the qualification (qualifying metadata), e.g. validity time, priorities, etc.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-qualification
     
    Note: the qualification can be also defined as a situation  <Situation> in KR Reaction RuleML 
	A situation could be also modelled as a changeable situation called fluent (in the KR dialect of Reaction RuleML),
	which changes its truth value depending on the context (context can be time, events/actions which 
	initiate/terminate the changeable situation, or a history of occured events/actions which leads to an occured situation
	as context for the truth changes of the fluent.
	
	That would mean the qualification of the rule changes depending on the situation (the truth value of the fluent in KR RuleML)
	
     content model: 
     in DR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval  )
     in KR Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation )
     in PR Reaction RuleML: ( Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal )
     in ECA Reaction RuleML: ( Rulebase | Atom | Implies | Rule | Equivalent | Entails | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )
  
  attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="qualification.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="qualification.content">
        <xs:choice>
            <xs:group ref="formula-assert.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="qualification.type">
        <xs:group ref="qualification.content"/>
        <xs:attributeGroup ref="qualification.attlist"/>
    </xs:complexType>
    <xs:element name="qualification" type="qualification.type"/>
    <!--
     *** quantification ***
     
     Definition of the quantifier. 
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-quantification
     
     content model: (Forall | Exists | Quantifier)
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
          
-->
    <xs:attributeGroup name="quantification.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="quantification.content">
        <xs:choice>
            <xs:group ref="inner-quantifier.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="quantification.type">
        <xs:group ref="quantification.content"/>
        <xs:attributeGroup ref="quantification.attlist"/>
    </xs:complexType>
    <xs:element name="quantification" type="quantification.type"/>
    <!-- extended descriptors in Reaction RuleML -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML quantifiers. File:
            quantifier_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares
            the       following RuleML elements: * Forall * Exists * declare * formula See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-07-16T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Forall ***
		Explicit universal quantifier.
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-Forall

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens ) )
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action ) )		

    attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
  -->
    <xs:attributeGroup name="Forall.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Forall.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="1">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice>
                <xs:element form="qualified" name="formula" type="formula-forall.type"/>
                <xs:group ref="formula-forall.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Forall.type">
        <xs:group ref="Forall.content"/>
        <xs:attributeGroup ref="Forall.attlist"/>
    </xs:complexType>
    <xs:element name="Forall" type="Forall.type"/>
    <!--
		*** Exists ***
		Explicit existential quantifier.

		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-Exists

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens) )		
    PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare | Var)+, (formula | Operation | Atom | Exists | Quantifier | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) )    
 
    attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="Exists.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Exists.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="1">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice>
                <xs:element form="qualified" name="formula" type="formula-exists.type"/>
                <xs:group ref="formula-exists.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists.type">
        <xs:group ref="Exists.content"/>
        <xs:attributeGroup ref="Exists.attlist"/>
    </xs:complexType>
    <xs:element name="Exists" type="Exists.type"/>
    <!--
		*** declare ***
		A role used for variables declared within a quantifier.
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-declare

		content model: ( Var )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="declare.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="declare.content">
        <xs:sequence>
            <xs:element ref="Var"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="declare.type">
        <xs:group ref="declare.content"/>
        <xs:attributeGroup ref="declare.attlist"/>
    </xs:complexType>
    <xs:element name="declare" type="declare.type"/>
    <!--
		*** formula ***
		The formula role of a quantifier (<Forall> or <Exists>).
		
		See http://www.deliberation.ruleml.org/1.02/glossary/#gloss-formula
		
		content model (below Forall): 
		DR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML ( Atom | Implies | Rule | Equivalent | Forall | Quantifier | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action)

		content model (below Exists): 
		DR Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Atom | Exists  | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens )
		PR Reaction RuleML does not use outer quantifiers (innner quantifiers under <quantification> are used instead)
		ECA Reaction RuleML ( Atom | Exists | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)		
		
		Other (context-sensitive) versions of <formula> are in the
		connective and performative modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:group name="formula-forall.content">
        <xs:choice>
            <xs:element ref="Implies"/>
            <xs:element ref="Rule"/>
            <xs:element ref="Equivalent"/>
            <xs:group ref="outer-quantifier.content"/>
            <xs:group ref="outer-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-forall.type">
        <xs:group ref="formula-forall.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:group name="formula-exists.content">
        <xs:choice>
            <xs:group ref="query-quantifier.content"/>
            <xs:group ref="query-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-exists.type">
        <xs:group ref="formula-exists.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML connectives. File:
            connective_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This
            module       declares the following RuleML elements and attributes: * Implies * if *
            then * Entails *       Equivalent * torso * Rulebase * And * Or * formula        See
            http://www.ruleml.org/modularization for details       about this modularization
            approach. </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2012-07-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!-- necessary for schematron -->
    <!-- 
	<xs:appinfo>
		
		<ns prefix="r" uri="http://ruleml.org/spec"/>
	</xs:appinfo> 
	-->
    <!--
		*** Implies ***
		An implication rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Implies

		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (then, if) | (if, then) | ( (Atom | And | Or | Equal), (Atom | Equal) ) )

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

  -->
    <xs:attributeGroup name="Implies.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Implies.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:sequence>
                    <xs:element ref="then"/>
                    <xs:element ref="if"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="if"/>
                    <xs:element ref="then"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:group ref="if.content"/>
                    <xs:group ref="then.content"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Implies.type">
        <xs:group ref="Implies.content"/>
        <xs:attributeGroup ref="Implies.attlist"/>
    </xs:complexType>
    <xs:element name="Implies" type="Implies.type"/>
    <!-- 
		*** if ***
		The if of an implication rule containing the premise(s),
		also known as the "antecedent" or "if" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if

		content model: 
		DR Reaction RuleML (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )
		KR Reaction RuleML (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Naf ) 
		ECA Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="if.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="if.content">
        <xs:choice>
            <xs:group ref="inner-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="if-entails.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="if.type">
        <xs:group ref="if.content"/>
        <xs:attributeGroup ref="if.attlist"/>
    </xs:complexType>
    <xs:complexType name="if-entails.type">
        <xs:group ref="if-entails.content"/>
        <xs:attributeGroup ref="if.attlist"/>
    </xs:complexType>
    <xs:element name="if" type="if.type"/>
    <!--
		*** then ***
		The then of an implication rule containing the conclusion,
		also known as the "consequent" or "then" part of the rule.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then

		content model: 
		DR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
		KR Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML does not support "then"  (except in combination with DR/KR Reaction RuleML)
		ECA Reaction RuleML ( Opeartor | Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="then.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="then.content">
        <xs:choice>
            <xs:group ref="outer-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="then-entails.content">
        <xs:choice>
            <xs:element ref="Rulebase"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="then.type">
        <xs:group ref="then.content"/>
        <xs:attributeGroup ref="then.attlist"/>
    </xs:complexType>
    <xs:complexType name="then-entails.type">
        <xs:group ref="then-entails.content"/>
        <xs:attributeGroup ref="then.attlist"/>
    </xs:complexType>
    <xs:element name="then" type="then.type"/>
    <!--
		*** Entails ***
		Well-known in (meta-)logic (earlier called 'Turnstile', and 'Demo' in
		Kowalski/Bowen's object/meta-level-amalgamated logic).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Entails
		
		content model:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (if | Rulebase), (then | Rulebase) )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Entails.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Entails.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:element form="qualified" name="if" type="if-entails.type"/>
                <xs:group ref="if-entails.content"/>
            </xs:choice>
            <xs:choice>
                <xs:element form="qualified" name="then" type="then-entails.type"/>
                <xs:group ref="then-entails.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Entails.type">
        <xs:group ref="Entails.content"/>
        <xs:attributeGroup ref="Entails.attlist"/>
    </xs:complexType>
    <xs:element name="Entails" type="Entails.type"/>
    <!--
		*** Equivalent ***
		An equivalence expression, which is "syntactic sugar" for a pair
		of conjoined converse implication rules.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equivalent

		content model: 		
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval), (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval) ) ) )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens), 
		                      (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens) ) ) )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operation | And | Or | Negation | Naf | Atom | Equal), (Operation | And | Or | Negation | Naf | Atom | Equal ) ) ) )                     
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
		CEP Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (torso, torso) | ( (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action), (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action) ) ) )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="Equivalent.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Equivalent.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:sequence>
                    <xs:choice>
                        <xs:element ref="torso"/>
                        <xs:group ref="torso.content"/>
                    </xs:choice>
                    <xs:choice>
                        <xs:element ref="torso"/>
                        <xs:group ref="torso.content"/>
                    </xs:choice>
                </xs:sequence>
                <xs:sequence> </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Equivalent.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<pattern name="Equivalent">
					<rule context="r:Equivalent[count( descendant::r:Equal/r:Expr | descendant::r:Equal/r:left/r:Expr )=2]">
						<assert test=
							"( descendant::r:Equal[1]/descendant::r:Fun[@per = 'copy']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'copy'] )
							 or
							 ( descendant::r:Equal[1]/descendant::r:Fun[@per = 'open']
							   and descendant::r:Equal[2]/descendant::r:Fun[@per = 'open'] )">
						  Equalities within an equivalence expression must either both be interpreted or both uninterpreted.
						</assert>
					</rule>
				</pattern>
			</xs:appinfo>
		</xs:annotation>
                -->
        <xs:group ref="Equivalent.content"/>
        <xs:attributeGroup ref="Equivalent.attlist"/>
    </xs:complexType>
    <xs:element name="Equivalent" type="Equivalent.type"/>
    <!--
		*** torso ***
		A symmetric role used in an equivalence expression combining
		the asymmetric <then> and <if>.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-torso

		content model: 
		DR Reaction RuleML (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Fluent | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operation | And | Or | Negation | Naf | Atom | Equal )
		ECA Reaction RuleML (Operation | And | Or | Atom |  Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="torso.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="torso.content">
        <xs:choice>
            <xs:group ref="inner-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="torso.type">
        <xs:group ref="torso.content"/>
        <xs:attributeGroup ref="torso.attlist"/>
    </xs:complexType>
    <xs:element name="torso" type="torso.type"/>
    <!--
		*** Rulebase ***
		A collection of rules that can be ordered or unordered, without or with duplicates.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rulebase
		
		@prefix for default prefix definitions 
		@vocab for default vocab definitions
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval )* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens )* )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Rule | Equivalent | Equal )* )
    ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action )* )
    
    attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:attributeGroup name="Rulebase.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rulebase.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-rulebase.type"/>
                <xs:group ref="formula-rulebase.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Rulebase.type">
        <xs:group ref="Rulebase.content"/>
        <xs:attributeGroup ref="Rulebase.attlist"/>
    </xs:complexType>
    <xs:element name="Rulebase" type="Rulebase.type"/>
    <!--
		*** And ***
		A conjunctive expression, where <And>Atom</And> is equivalent to Atom.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-And
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* ) 
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Equal | Negation | Naf )* )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )

		Under Query, And may have attribute closure="existential"; 
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="And-inner.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="And-query.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="And.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-and-or.type"/>
                <xs:group ref="formula-and-or.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="And-query.type">
        <xs:group ref="And.content"/>
        <xs:attributeGroup ref="And-query.attlist"/>
    </xs:complexType>
    <xs:complexType name="And-inner.type">
        <xs:group ref="And.content"/>
        <xs:attributeGroup ref="And-inner.attlist"/>
    </xs:complexType>
    <xs:element name="And" type="And-inner.type"/>
    <!--
		*** Or ***
		A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Or
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)* )
	  PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Equal | Negation | Naf )* )
	  ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)* )
		
		Under Query, Or may have attribute closure="existential"; 
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Or-query.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="Or-inner.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Or.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-and-or.type"/>
                <xs:group ref="formula-and-or.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Or-query.type">
        <xs:group ref="Or.content"/>
        <xs:attributeGroup ref="Or-query.attlist"/>
    </xs:complexType>
    <xs:complexType name="Or-inner.type">
        <xs:group ref="Or.content"/>
        <xs:attributeGroup ref="Or-inner.attlist"/>
    </xs:complexType>
    <xs:element name="Or" type="Or-inner.type"/>
    <!--
		*** formula ***
		The formula role of a conjunctive/disjunctive expression or a rulebase.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula

		content model (below And/Or): 
		DR Reaction RuleML (Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval)
		KR Reaction RuleML (Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operation | Atom | And | Or | Negation | Naf | Equal )
		ECA Reaction RuleML (Operation | Atom | And | Or | Negation | Naf | Neg | Equal | Time | Spatial | Interval | Event | Action)
		
		content model (below Rulebase): 
		DR Reaction RuleML (Operation | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval)
		KR Reaction RuleML (Operation | Atom | Implies | Rule | Equivalent | Forall |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens)
		PR Reaction RuleML (Operation | Atom | Rule | Equivalent | Equal )
		ECA Reaction RuleML (Operation | Atom | Rule | Equivalent |  Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)
		
		Other (context-sensitive) versions of <formula> are in the
		performative and quantifier modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="formula.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula-and-or.content">
        <xs:choice>
            <xs:group ref="inner-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <!--
		In 1.0, Naf is not allowed in the consequent (second child) of Entails
		because Integrity uses of Entails call for classical Neg
		and Rulebase should not contain Naf in any other context (except Query).
		Alternatives would have been to use And in the consequent of Entails
		or to only allow Naf children within Rulebases that are used for Integrity
		and querying, but this would require making the role tags explicit (i.e.
		not skippable). Schematron could be used here to disallow Naf from other
		Rulebases.
	-->
    <xs:group name="formula-rulebase.content">
        <xs:choice>
            <xs:element form="qualified" name="Implies" type="Implies.type"/>
            <xs:element ref="Rule"/>
            <xs:element form="qualified" name="Equivalent" type="Equivalent.type"/>
            <xs:group ref="outer-quantifier.content"/>
            <xs:group ref="outer-connective.content"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-and-or.type">
        <xs:group ref="formula-and-or.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:complexType name="formula-rulebase.type">
        <xs:group ref="formula-rulebase.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               generic connective operator module of
            Reaction RuleML.     This is the XML Schema connective operator module for Reaction
            RuleML.    File: connective_operator_module.xsd    Version: 1.0    Last Modification:
            2011-03-22     This schema declares the following Reaction RuleML elements and
            attributes:      * Operation (Connective)        The approach is modelled after that used
            in "Modularization of XHTML in XML Schema"    WD
            [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-22T29:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** generic connective Operation ***
      
      	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Operation
      
      	content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval)* )
		KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Implies | Rule | Equivalent | Forall | Equal | Negation | Neg | Time | Spatial | Interval | Event | Situation | Holds | Initiates | Terminates | Happens)* ) 
        PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Rule | Equivalent | Equal)* ) 
        ECA Reaction RuleML:( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Rule | Equivalent | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action)* )
        
        attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="ConnectiveOperator.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="ConnectiveOperator.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-rulebase.type"/>
                <xs:group ref="formula-rulebase.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="ConnectiveOperator.type">
        <xs:group ref="ConnectiveOperator.content"/>
        <xs:attributeGroup ref="ConnectiveOperator.attlist"/>
    </xs:complexType>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML atoms. File:
            atom_module.xsd Version: 1.0 Last Modification: 2012-02-21 This module declares
            the following RuleML elements and attributes: * Atom * op * Rel * degree See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2012-07-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
        *** Atom ***
		A logical atom , i.e. an expression formed from a predicate
		applied to a collection of its (logical) arguments.
		Or a frame object with slots

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Atom
	
		content model:
		in DR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval)*, repo?) | repo), slot*, resl?
		)
		
		in KR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo?) | repo), slot*, resl?
		)
		
		in PR Reaction RuleML:
		(
			meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Skolem | Var | Reify|Expr|Plex)*, repo?) | repo), slot*, resl?
		)
		
		in ECA Reaction RuleML
		(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?, (op | Rel)?, slot*,
			((arg | Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)*, repo?) | repo), slot*, resl?)
		
		however, the above content model is non-deterministic,
		so it is (equivalently) restructured as follows:
		
		in DR Reaction RuleML:
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)	
			
		in KR Reaction RuleML
		(
				meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, degree?,  (op | Rel)?, slot*,
				( 
					( 
						((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?)
						|
						repo
					),
					slot*)?, 
				resl?
			)
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	
	-->
    <xs:attributeGroup name="Atom.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <!--
		These .extend groups, pointed to by Atom.content, are necessary
		for redefinition to be binary in bindatalog and to add rest
		variables in hornlog.
	-->
    <xs:group name="Atom-repo.extend">
        <xs:choice>
            <xs:group ref="Atom-arg.extend"/>
            <xs:element ref="repo"/>
        </xs:choice>
    </xs:group>
    <xs:group name="Atom-arg.extend">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="arg"/>
                <xs:group ref="arg.content"/>
            </xs:choice>
            <xs:element minOccurs="0" ref="repo"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom-slots.extend1">
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom-slots.extend2">
        <xs:sequence>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Atom.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice minOccurs="0">
                <!-- operator optional for frame representation -->
                <xs:element form="qualified" name="op" type="op-atom.type"/>
                <xs:group ref="op-atom.content"/>
            </xs:choice>
            <xs:group ref="Atom-slots.extend1"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:group ref="Atom-repo.extend"/>
                    <xs:group ref="Atom-slots.extend1"/>
                </xs:sequence>
            </xs:choice>
            <xs:group ref="Atom-slots.extend2"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Atom.type">
        <xs:group ref="Atom.content"/>
        <xs:attributeGroup ref="Atom.attlist"/>
    </xs:complexType>
    <xs:element name="Atom" type="Atom.type"/>
    <!--
		*** op ***
		An operator expression including the relation of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op

		content model (within Atom): (Rel)
		
		Other (context-sensitive) versions of <op> are in the expr and holog modules.
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="op.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="op-atom.content">
        <xs:sequence>
            <xs:element ref="Rel"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="op-atom.type">
        <xs:group ref="op-atom.content"/>
        <xs:attributeGroup ref="op.attlist"/>
    </xs:complexType>
    <xs:element name="op" type="op-atom.type"/>
    <!--
		*** Rel ***
		A relation, i.e. a logical predicate, of an atom.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rel
		
		content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
		
		attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Rel.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rel.content">
        <xs:sequence> </xs:sequence>
    </xs:group>
    <xs:complexType mixed="true" name="Rel.type">
        <xs:group ref="Rel.content"/>
        <xs:attributeGroup ref="Rel.attlist"/>
    </xs:complexType>
    <xs:element name="Rel" type="Rel.type"/>
    <!-- 
		*** degree ***

		An optional uncertainty value (between 0.0 and 1.0)
		that may be assigned to facts and rules.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-degree

		content model: (Data)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="degree.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="degree.content">
        <xs:sequence>
            <xs:element ref="Data"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="degree.type">
        <xs:group ref="degree.content"/>
        <xs:attributeGroup ref="degree.attlist"/>
    </xs:complexType>
    <xs:element name="degree" type="degree.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML slots. File:
            slot_module.xsd Version: 1.0 Last Modification: 2011-07-16 This module declares the
            following       RuleML element and attributes: * slot        See
            http://www.ruleml.org/modularization for details about this modularization approach.     </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-07-16T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** slot ***
		A user-defined slot consisting of a name (first position) and a filler (second position).
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-slot

		content model:
		DR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval) )
		KR Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation) )
		PR Reaction RuleML: ( (Ind|Data|Expr|Plex), (Ind|Data|Skolem|Var|Reify|Expr|Plex) )
		ECA Reaction RuleML: ( (Ind|Data|Expr|Plex|Time|Spatial|Interval|Event|Action), (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action) )
		
		attributes: @card?, @minCard?, @maxCard?, @weight?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
		
	-->
    <xs:attributeGroup name="slot.attlist">
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="slot-name.extend">
        <xs:choice>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:group name="slot.content">
        <xs:sequence>
            <xs:group ref="slot-name.extend"/>
            <xs:group ref="arg.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="slot.type">
        <xs:group ref="slot.content"/>
        <xs:attributeGroup ref="slot.attlist"/>
    </xs:complexType>
    <xs:element name="slot" type="slot.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML terms. File:
            term_module.xsd Version: 1.0 Last Modification: 2012-04-03 This module declares the
            following       RuleML elements and attributes: * arg * Ind * Data * Var * Skolem *
            Reify as       well as including a number of complex types for use in expicitly-typed
            data Nodes. See       http://www.ruleml.org/modularization for details about this
            modularization approach.     </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2012-04-03T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** arg ***
		A role used for the positional arguments of a logical atom.
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)

    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <xs:attributeGroup name="arg.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element ref="Skolem"/>
            <xs:element ref="Reify"/>
            <xs:group ref="extended-signature-function-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg.type">
        <xs:group ref="arg.content"/>
        <xs:attributeGroup ref="arg.attlist"/>
    </xs:complexType>
    <xs:element name="arg" type="arg.type"/>
    <!--
		*** Ind ***
		An individual constant, as in predicate logic, which can also be considered to
		be a fixed argument like RDF resources.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Ind
		
		content model: text

    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Ind.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Ind.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Ind.type">
        <xs:group ref="Ind.content"/>
        <xs:attributeGroup ref="Ind.attlist"/>
    </xs:complexType>
    <xs:element name="Ind" type="Ind.type"/>
    <!--
		*** Data ***
		A fixed argument like RDF literals, allowing XML data.  It may be
		optionally associated with an XML Schema built-in datatype
		(see http://www.w3.org/TR/xmlschema-2/#built-in-datatypes)
		using the built-in xsi:type attribute.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Data
		
		content model: xs:anytype [optionally datatyped]
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
  -->
    <xs:element name="Data" type="xs:anyType"/>
    <!--
		*** Var ***
		A logical variable, as in logic programming.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Var

		content model: text
		
		@mode = + | - | ?; default is ?

	  + input variable which must be bound
        - output variable which must be free (unbound)
        ? can be both input / bound or output / free
    
    attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Var.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Var.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Var.type">
        <xs:group ref="Var.content"/>
        <xs:attributeGroup ref="Var.attlist"/>
    </xs:complexType>
    <xs:element name="Var" type="Var.type"/>
    <!--
		*** Skolem ***
		A Skolem individual constant, like RDF's blank nodes.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Skolem

		content model: text
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Skolem.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Skolem.content">
        <xs:sequence/>
    </xs:group>
    <xs:complexType mixed="true" name="Skolem.type">
        <xs:group ref="Skolem.content"/>
        <xs:attributeGroup ref="Skolem.attlist"/>
    </xs:complexType>
    <xs:element name="Skolem" type="Skolem.type"/>
    <!--
		*** Reify ***
		Supports reification (a kind of instantiation or quasi-quotation)
		as needed by SWSL. It allows any RuleML tag available within the
		current sublanguage as content, treating it as a term for performing
		reasoning on.
				
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Reify		
		
		content model: (any valid RuleML formula)
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Reify.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Reify.content">
        <xs:sequence>
            <!--
		  <xs:element ref="meta" minOccurs="0" maxOccurs="unbounded"/> -->
            <!-- <Reify> only allows valid RuleML -->
            <!--<xs:any minOccurs="0" maxOccurs="unbounded" processContents="strict" namespace="##targetNamespace"/>-->
            <xs:any minOccurs="0" namespace="##targetNamespace" processContents="strict"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Reify.type">
        <xs:group ref="Reify.content"/>
        <xs:attributeGroup ref="Reify.attlist"/>
    </xs:complexType>
    <xs:element name="Reify" type="Reify.type"/>
    <!-- includes the hornlog layer with the 'expr' and 'rest' modules -->
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML expressions. File:
            expr_module.xsd Version: 1.0 Last Modification: 2011-10-05 [Tara Athan] This module
            declares       the following RuleML elements and attributes: * Expr * op * Fun * Plex *
            @per See       http://www.ruleml.org/modularization for details about this
            modularization approach. </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-10-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
        <!-- necessary for schematron -->
        <!-- 
		<xs:appinfo>

		<sch:ns prefix="r" iri="http://www.deliberation.ruleml.org/1.02/xsd"/>
		-->
    </xs:annotation>
    <!--
		*** Expr ***
		A logical function of the form "f(...)" where f is a function name.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Expr

		content model:
		DR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*,
		  repo?, slot*, resl?
		)

    KR Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, 
      (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*,
		  repo?, slot*, resl?
		)

		PR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?
		  (op|Fun)?, slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl?		)
		  
		ECA Reaction RuleML:
		( 		   
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op|Fun)?, slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)*, repo?, slot*, resl?
		)  

		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		DR Reaction RuleML:
		(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun)?, slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		KR Reaction RuleML:
				(
		meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (op | Fun)?, slot*,
			( 
				( 
					( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo? )
					|
					repo
				),
				slot*)? , 
			resl?
		)
		Note the 'positionalized' normal form where the op role is only
		at the beginning of the Expr.
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Expr.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Expr.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="op" type="op-Expr.type"/>
                <xs:group ref="op-Expr.content"/>
            </xs:choice>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:choice>
                        <xs:sequence>
                            <xs:choice maxOccurs="unbounded">
                                <xs:element ref="arg"/>
                                <xs:group ref="arg.content"/>
                            </xs:choice>
                            <xs:element minOccurs="0" ref="repo"/>
                        </xs:sequence>
                        <xs:element ref="repo"/>
                    </xs:choice>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                </xs:sequence>
            </xs:choice>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Expr.type">
        <!--
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Uninterpreted functions">
					<sch:rule context="r:Expr/r:Fun[@per='no']">
						<sch:assert test=
								"not(../r:Expr/r:Fun[@per='yes'] or
									 ../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
					<sch:rule context="r:Expr/r:op/r:Fun[@per='no']">
						<sch:assert test=
								"not(../../r:Expr/r:Fun[@per='yes'] or
									 ../../r:arg/r:Expr/r:Fun[@per='yes'] or
									 ../../r:Expr/r:op/r:Fun[@per='yes'] or 
									 ../../r:arg/r:Expr/r:op/r:Fun[@per='yes'])">
								Functions nested within an uninterpreted function must also be uninterpreted.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <xs:group ref="Expr.content"/>
        <xs:attributeGroup ref="Expr.attlist"/>
    </xs:complexType>
    <xs:element name="Expr" type="Expr.type"/>
    <!--
		*** op ***
		An operator expression including the function name of an expression.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-op
				
		content model (within Expr): (Fun)
		
		Other (context-sensitive) versions of <op> are in the atom and holog modules.
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <!-- the (empty) attribute list is declared in the atom module -->
    <xs:group name="op-Expr.content">
        <xs:sequence>
            <xs:element ref="Fun"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="op-Expr.type">
        <xs:group ref="op-Expr.content"/>
        <xs:attributeGroup ref="op.attlist"/>
    </xs:complexType>
    <!--
		*** Fun ***
		A user-defined function name.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Fun

    content model: (#PCDATA, id?, #PCDATA, meta*, #PCDATA)
    attributes: attribute: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Fun.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Fun.content">
        <xs:sequence> </xs:sequence>
    </xs:group>
    <xs:complexType mixed="true" name="Fun.type">
        <xs:group ref="Fun.content"/>
        <xs:attributeGroup ref="Fun.attlist"/>
    </xs:complexType>
    <xs:element name="Fun" type="Fun.type"/>
    <!--
		*** Plex ***
		An unordered collection of arguments without a constructor.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Plex
		
		content model (within Atom, Plex, slot):
		DR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)*, repo?, slot*, resl? )
    
    KR Reaction RuleML
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Interval)*, repo?, slot*, resl? )
		  
		PR Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex)*, repo?, slot*, resl? )
		
		ECA Reaction RuleML:
		( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		  slot*, (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Atom|Event)*, repo?, slot*, resl? )
		
		however, this is non-deterministic, so it is (equivalently) restructured as follows:
		
		DR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		KR Reaction RuleML:
		(		
		   meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*,
		   slot*,
		     (
		        ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)+, repo?, slot*, resl? )?
		        |
                     ( repo, slot*, resl? )
                     |
                     resl
		     )
		)
		
		content model (within repo): 
		DR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval )*, repo? )
		KR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Situation)*, repo? )
		PR Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex )*, repo? )
		ECA Reaction RuleML: ( (arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action )*, repo? )
		
		content model (within resl):
		DR/KR/PR/ECA/CEP Reaction RuleML: (slot*, resl? )
		
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Plex.attlist">
        <xs:attributeGroup ref="term-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Plex.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:choice>
                <xs:sequence minOccurs="0">
                    <xs:choice maxOccurs="unbounded">
                        <xs:element ref="arg"/>
                        <xs:group ref="arg.content"/>
                    </xs:choice>
                    <xs:element minOccurs="0" ref="repo"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="repo"/>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element ref="resl"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="Plex-repo.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="arg"/>
                <xs:group ref="arg.content"/>
            </xs:choice>
            <xs:element minOccurs="0" ref="repo"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="Plex-resl.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                type="slot.type"/>
            <xs:element minOccurs="0" ref="resl"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Plex.type">
        <xs:group ref="Plex.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:complexType name="Plex-repo.type">
        <xs:group ref="Plex-repo.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:complexType name="Plex-resl.type">
        <xs:group ref="Plex-resl.content"/>
        <xs:attributeGroup ref="Plex.attlist"/>
    </xs:complexType>
    <xs:element name="Plex" type="Plex.type"/>
    <!-- note that elementFormDefault is qualified because of local declarations -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for RuleML rest variables.
            File:       rest_module.xsd Version: 1.0 Last Modification: 2011-07-05 This module
            declares the following       RuleML elements: * repo * resl See
            http://www.ruleml.org/modularization for details about this       modularization
            approach. </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-07-05T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** repo ***
		A positional rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-repo

		content model: (Var | Plex)
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="repo.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="repo.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element form="qualified" name="Plex" type="Plex-repo.type"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="repo.type">
        <xs:group ref="repo.content"/>
        <xs:attributeGroup ref="repo.attlist"/>
    </xs:complexType>
    <xs:element name="repo" type="repo.type"/>
    <!--
		*** resl ***
		A slotted rest variable.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-resl		

		content model: (Var | Plex)
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="resl.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="resl.content">
        <xs:choice>
            <xs:element ref="Var"/>
            <xs:element form="qualified" name="Plex" type="Plex-resl.type"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="resl.type">
        <xs:group ref="resl.content"/>
        <xs:attributeGroup ref="resl.attlist"/>
    </xs:complexType>
    <xs:element name="resl" type="resl.type"/>
    <!-- includes the equalog layer with the 'equality' module -->
    <xs:annotation>
        <xs:documentation xml:lang="en"> This is the XML Schema module for equality in RuleML. File:
            equality_module.xsd Version: 1.0 Last Modification: 2012-02-21 [Tara Athan] This module
            declares the following RuleML elements and attributes: * Equal * left * right        See
            http://www.ruleml.org/modularization for details about this modularization approach. </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Tara Athan (taraathan AT gmail.com)</dc:creator>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2012-02-21T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Equal ***
		An equational formula consisting of two expressions.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal

		content model:
		in DR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)  )
		)
		in KR Reaction RuleML:
		(
		  meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,
			(left, right) |
			(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)  )
		)
		in PR Reaction RuleML:  (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	( (Ind | Data | Var | Skolem | Reify  | Expr | Plex ), (Ind | Data | Var | Skolem | Reify  | Expr | Plex ) ))
		in ECA Reaction RuleML:	(meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (degree)?,	(left, right) |	(  (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)  )
		)		
		
		attributes: @oriented?, @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Equal.attlist">
        <xs:attributeGroup ref="oriented.attrib"/>
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Equal.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:element minOccurs="0" ref="degree"/>
            <xs:choice>
                <xs:sequence>
                    <xs:element ref="left"/>
                    <xs:element ref="right"/>
                </xs:sequence>
                <!-- note that (right, left) is disallowed -->
                <xs:sequence>
                    <xs:group ref="left.content"/>
                    <xs:group ref="right.content"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Equal.type">
        <!-- 
			<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Defining equality">
					<sch:rule context=
						"r:Implies/r:then/r:Equal/r:left/r:Expr/r:Fun |
						 r:Implies/r:Equal[2]/r:left/r:Expr/r:Fun |
						 r:Implies/r:then/r:Equal/r:Expr[1]/r:Fun |
						 r:Implies/r:Equal[2]/r:Expr[1]/r:Fun">
						<sch:assert test="@per='yes'">
							A defining equality must have an interpreted left-hand side.
						</sch:assert>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		-->
        <xs:group ref="Equal.content"/>
        <xs:attributeGroup ref="Equal.attlist"/>
    </xs:complexType>
    <xs:element name="Equal" type="Equal.type"/>
    <!--
		*** left ***
		The left-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-left

		content model: 
		in DR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	
	-->
    <xs:attributeGroup name="left.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="left.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="left.type">
        <xs:group ref="left.content"/>
        <xs:attributeGroup ref="left.attlist"/>
    </xs:complexType>
    <xs:element name="left" type="left.type"/>
    <!--
		*** right***
		The right-hand side of an equational formula.

		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-right

		content model: 
		in DR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval)
		in KR RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
		in PR Reaction RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex )
		in ECA RuleML (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action)		
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="right.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="right.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="right.type">
        <xs:group ref="right.content"/>
        <xs:attributeGroup ref="right.attlist"/>
    </xs:complexType>
    <xs:element name="right" type="right.type"/>

    <xs:simpleType name="curieOrIRI.datatype">
        <xs:union memberTypes="curie.datatype xs:anyURI"/>
    </xs:simpleType>
    <xs:simpleType name="curieOrAbsIRI.datatype">
        <xs:union memberTypes="curie.datatype absIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrIRI.datatype">
        <xs:union memberTypes="term.datatype curie.datatype xs:anyURI"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrIRIs.datatype">
        <xs:list itemType="termOrCurieOrIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrAbsIRI.datatype">
        <xs:union memberTypes="term.datatype curie.datatype absIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="termOrCurieOrAbsIRIs.datatype">
        <xs:list itemType="termOrCurieOrAbsIRI.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="absIRI.datatype">
        <xs:restriction base="xs:anyURI">
            <xs:pattern value="[\i-[:]][\c-[:]]+:.+"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="curie.datatype">
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="term.datatype">
        <xs:restriction base="xs:Name">
            <xs:pattern value="[\i-[:]][/\c-[:]]*"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
           *** @mode ***
           An attribute for optionally specifying the intended input-output constellations of formulas and terms with the
           following semantics:
        
           "+" The formula/term is intended to be input
           "-" The formula/term is intended to be output
           "?" The formula/term is undefined (input or output)
           "[iri]" the formula/term's mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)  
		   
			By default the mode of formulas when used as conditions, constraints, queries and event patterns is "+" (input)
			and the mode of conclusions, answers and active actions is "-" (output). Variables are "?" (open) by default.
			optional attribute
			
			See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40mode
-->
    <xs:attributeGroup name="mode.attrib">
        <xs:attribute default="?" name="mode" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-modes.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-modes.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="+"/>
            <xs:enumeration value="-"/>
            <xs:enumeration value="?"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
	  *** @safety ***

	     restriction: interrupting, non-interrupting or transactional or
	     "[iri]" the formula/term's safety mode is defined in an internal or external vocabulary referenced by the IRI (vocabulary term or curie or absolute IRI)
	     
		 default: non-interrupting 
		 optional attribute
		 
		 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40safety
	-->
    <xs:attributeGroup name="safety.attrib">
        <xs:attribute default="non-interrupting" name="safety" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-safety.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-safety.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="non-interrupting"/>
            <xs:enumeration value="interrupting"/>
            <xs:enumeration value="transactional"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @per ***
		An optinal attribute indicating how a formulas, terms and operators are interpreted.
		
		Default for formulas is per "value" (truth valuation), for terms per "copy", for modal operators per "modal" and for actions/performatives by "effect".		
		In "reasoning" dialects the default for actions and events is per "value" and in active / messaging dialects it is per "effect".
		In "non-reified" representations as formulas default interpretation per "value" and in "reified" representations as term default interpretation is per copy. 
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40per
	-->
    <xs:attributeGroup name="per.attrib">
        <xs:attribute name="per" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-per.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-per.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="copy"/>
            <xs:enumeration value="value"/>
            <xs:enumeration value="effect"/>
            <xs:enumeration value="modal"/>
            <xs:enumeration value="open"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @size  ***
		An attribute indicating the size of a counter		
		-1 = unbound / all
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40size
	-->
    <!-- 
		
		replaced by card 
		
		<xs:attributeGroup name="size.attrib">
		<xs:attribute name="size" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="mapSize.attrib">
		<xs:attribute name="mapSize" type="xs:int" use="optional" default="-1"/>
	</xs:attributeGroup>-->
    <!--
    *** @style ***
    
    The style attribute defines the styles of the intended semantics. 
    Predefined semantics are "active", "reasoning", "messaging". 
    Further intented semantics can be defined by semantic profiles internally in the <evaluation> role
    or externally. They can be referenced by ther profile name (term) or resource locator (curie or absolute IRI).
    
   restriction: active | messaging | reasoning | "[IRIs]" (vocabulary terms or curies or absolute IRIs)

	 default value: reasoning (in DR Reaction RuleML), active (in PR and ECA RuleML), and messaging (in CEP RuleML)
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40style
	-->
    <xs:simpleType name="style.datatype">
        <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-style.datatype"/>
    </xs:simpleType>
    <xs:simpleType name="vocab-style.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="active"/>
            <xs:enumeration value="messaging"/>
            <xs:enumeration value="reasoning"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
    *** @key ***
    
    optinal unique local key on all knowledge formulas
    
	 optinal attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40key
	-->
    <xs:attributeGroup name="key.attrib">
        <xs:attribute name="key" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @keyref ***
    
    corresponding reference to a unique local key
    
	 optinal attribute
	 
	 http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40keyref
	-->
    <xs:attributeGroup name="keyref.attrib">
        <xs:attribute name="keyref" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @node ***
    An optional identification label for a Node, creating accessibility within
    the knowledge representation.
    This can help for representing prioritization between rules, for example. 
    The content of all Node elements (i.e. those that begin with an uppercase letter) of RuleML can begin with 
    such a label.
    
    See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40node
    
    content model: (curieOrAbsIRI.datatype)
  -->
    <xs:attributeGroup name="node.attrib">
        <xs:attribute name="node" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @type ***
		An attribute for optionally specifying a (user-defined) type.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40type
		
		Note: In Reaction RuleML the type is changed to Term or Curie or absolute IRI to allow references
		to internal vocabulary terms (e.g. local sort signature definitions) and external vocabulary types (sorts) 
	-->
    <xs:attributeGroup name="type.attrib">
        <xs:attribute name="type" type="termOrCurieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
    *** @meta ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines descriptive meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <meta> role)
     or external metadata vocabularies.
     
	 By default knowledge is contextually annotated by metadata about the source (@src([Locator])) and the name (@label([OID])),
	 with "Locator" being the source location (location of Reaction RuleML knowledge base in which the knowledge is defined) 
	 and OID being the implicitly or explicitly defined object identifer of the knowledge.
	 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40meta
	-->
    <xs:attributeGroup name="meta.attrib">
        <xs:attribute name="meta" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
    *** @qualify ***
    
     "[iri]" (term or curie or absolute IRI)
     
     Defines qualifying meta knowledge annotations. The IRI points to internal metadata definitions (defined in the <qualification> role)
     or external metadata vocabularies.
      
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40qualify
	-->
    <xs:attributeGroup name="qualify.attrib">
        <xs:attribute name="qualify" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
    *** @scope ***
    
     restriction: global | local | private | "[iris]" (terms or curies or absolute IRIs)
     
     Defines a scope. Predefined scopes are global, local, private. 
     Internal dynamic scopes defined by metadata views (defined in the <scope> role) can be references by the oid name term (<oid>)
     and externally defined scopes by their IRI.
     
	 default value: "global" for relations and functions and "local" for terms 
	 optional attribute
	 
	 See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40scope
	-->
    <xs:attributeGroup name="scope-formula.attrib">
        <xs:attribute default="global" name="scope" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-scope.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="scope-term.attrib">
        <xs:attribute default="local" name="scope" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRIs.datatype vocab-scope.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-scope.datatype">
        <xs:restriction base="xs:string">
            <xs:enumeration value="local"/>
            <xs:enumeration value="global"/>
            <xs:enumeration value="private"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @arity ***
		An optional attribute for specifying the arity of a signature.
		The arity of constants / individual objects is zero.
		The arity of predicates and functions is the number of arguments they have.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40arity
	-->
    <xs:attributeGroup name="arity.attrib">
        <xs:attribute name="arity" type="xs:nonNegativeInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @prefix ***
		
		a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40prefix
		
	-->
    <xs:attributeGroup name="prefix.attrib">
        <xs:attribute name="prefix" type="prefix.datatype" use="optional"/>
    </xs:attributeGroup>
    <xs:simpleType name="prefix.datatype">
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="([\i-[:]][\c-[:]]*)?"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @vocab ***
		
		an IRI that defines the vocabulary mapping to use when a TERM is referenced in an attribute value.
		
		See: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40vocab
				
	-->
    <xs:attributeGroup name="vocab.attrib">
        <xs:attribute name="vocab" type="xs:anyURI" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @card @minCard @maxCard ***
		An attribute optionally specifying the cardinality.
		
		"-1" = unbound
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40card
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40maxCard
			http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40minCard
	-->
    <xs:attributeGroup name="card.attrib">
        <xs:attribute name="card" type="xs:int" use="optional"/>
        <xs:attribute name="maxCard" type="xs:int" use="optional"/>
        <xs:attribute name="minCard" type="xs:nonNegativeInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @weight ***
		An attribute optionally specifying a relative weight.
		The default is "1", i.e. all knowledge has the same weight of "1". 
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40weight		
	-->
    <xs:attributeGroup name="weight.attrib">
        <xs:attribute name="weight" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:decimal">
                    <xs:minInclusive value="0"/>
                    <xs:maxInclusive value="1"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
		*** @direction ***
		An attribute indicating the intended direction of an implication rule's inferencing.
		default is bidirectional.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40direction
	-->
    <xs:attributeGroup name="direction.attrib">
        <xs:attribute default="bidirectional" name="direction" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-direction.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-direction.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="forward"/>
            <xs:enumeration value="backward"/>
            <xs:enumeration value="bidirectional"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @closure ***
		An attribute indicating how the contained free variables are quantified.
		default is universal closure.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40closure		
	-->
    <xs:attributeGroup name="closure.attrib">
        <xs:attribute default="universal" name="closure" use="optional">
            <xs:simpleType>
                <xs:union memberTypes="termOrCurieOrAbsIRI.datatype vocab-closure.datatype"/>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="vocab-closure.datatype">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="universal"/>
            <xs:enumeration value="existential"/>
        </xs:restriction>
    </xs:simpleType>
    <!--
		*** @material ***
		An attribute indicating the kind of an implication rule.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40material
	-->
    <xs:attributeGroup name="material.attrib">
        <xs:attribute default="no" name="material" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:NMTOKEN">
                    <xs:enumeration value="no"/>
                    <xs:enumeration value="yes"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!--
		*** @iri ***
		An attribute for referring to a Curie or absolute IRI.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40iri
	-->
    <xs:attributeGroup name="iri.attrib">
        <xs:attribute name="iri" type="curieOrAbsIRI.datatype" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @index ***
		An optional attribute for specifying an ordering on roles.
		
		Note: in Reaction RuleML @index is optional
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40index
	-->
    <xs:attributeGroup name="index.attrib">
        <xs:attribute name="index" type="xs:positiveInteger" use="optional"/>
    </xs:attributeGroup>
    <!--
		*** @oriented ***
		An attribute indicating whether an equation is oriented (directed)
		or unoriented (symmetric).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-.40oriented
	-->
    <xs:attributeGroup name="oriented.attrib">
        <xs:attribute default="no" name="oriented" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:NMTOKEN">
                    <xs:enumeration value="yes"/>
                    <xs:enumeration value="no"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML elements in Reaction RuleML

	@prefix?, @key?, @keyref?, @xml:id?, @xml:base?
 
  	@key and @keyref attributes for local syntactic modularization of the knowledge base
  	   
  	-->
    <xs:attributeGroup name="xml.attlist">
        <xs:attributeGroup ref="prefix.attrib"/>
        <xs:attributeGroup ref="key.attrib"/>
        <xs:attributeGroup ref="keyref.attrib"/>
        <xs:attribute ref="xml:base" use="optional"/>
        <xs:attribute ref="xml:id" use="optional"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML node elements (type elements) in Reaction RuleML
  	
	@meta?, @qualify?, @node?, @iri?, @vocab?
   	   
  	-->
    <xs:attributeGroup name="node-element.attlist">
        <xs:attributeGroup ref="node.attrib"/>
        <xs:attributeGroup ref="iri.attrib"/>
        <xs:attributeGroup ref="vocab.attrib"/>
        <xs:attributeGroup ref="meta.attrib"/>
        <xs:attributeGroup ref="qualify.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for all XML edge elements (role elements) in Reaction RuleML
  	
	@index?
   	   
  	-->
    <xs:attributeGroup name="edge-element.attlist">
        <xs:attributeGroup ref="index.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all grouping formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?  
	
	attributes of grouping formulas are automatically inherited as default attributes to all formulas in the group.
  	-->
    <xs:attributeGroup name="group-formula-interface.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all knowledge formulas in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?

   	   
  	-->
    <xs:attributeGroup name="formula-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all terms in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @scope?, @per?
   	   
  	-->
    <xs:attributeGroup name="term-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="scope-term.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all quantifiers in Reaction RuleML
  	
	@type?, @card?, @minCard?, @maxCard?, @style?, @scope?
  	-->
    <xs:attributeGroup name="quantifier-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all connectives/operators in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?
  	-->
    <xs:attributeGroup name="operator-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all action / performatives in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
  	-->
    <xs:attributeGroup name="action-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="safety.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <!-- 
 
  	a group of attributes for the meta knowledge interface of all events in Reaction RuleML
  	
	@type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?
  	-->
    <xs:attributeGroup name="event-interface.attlist">
        <xs:attributeGroup ref="type.attrib"/>
        <xs:attributeGroup ref="arity.attrib"/>
        <xs:attributeGroup ref="card.attrib"/>
        <xs:attributeGroup ref="weight.attrib"/>
        <xs:attributeGroup ref="style.attrib"/>
        <xs:attributeGroup ref="direction.attrib"/>
        <xs:attributeGroup ref="safety.attrib"/>
        <xs:attributeGroup ref="scope-formula.attrib"/>
        <xs:attributeGroup ref="mode.attrib"/>
        <xs:attributeGroup ref="closure.attrib"/>
        <xs:attributeGroup ref="per.attrib"/>
    </xs:attributeGroup>
    <xs:annotation>
        <xs:documentation xml:lang="en">                      Rules module part of Reaction RuleML.
            It defines the core            Rule construct used as basis for all types of rules in
            Reaction RuleML                      This is the XML Schema rule module for Reaction
            RuleML.           File: rule_module.xsd           Version: 1.0           Last
            Modification: 2011-03-29                      This schema declares the following
            Reaction RuleML elements and attributes:                      * Rule           * on
            * if           * then           * do           * after                     * else
            * elseDo           * elseAfter                          </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** Rule ***
      The Rule element that provides the basic syntax for rules
      in Reaction RuleML.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Rule

      content model: 
 	 
 	 In (temporal) DR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )
	 
	 In KR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)))
	 
	 In PR Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (elseDo?, do, if) | (if, do, elseDo?)))
	 
	 in ECA Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)? ) )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )

	 
	 in CEP Reaction RuleML:
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (on, (if?, then?, do, after?,else?, elseDo?)* ) )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( do )
	 ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( (else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?) ) )

	 
      Rule has the following attributes:
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
      
-->
    <xs:attributeGroup name="Rule.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="material.attrib"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Rule.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:group minOccurs="0" ref="rule-implementation.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Rule.type">
        <xs:group ref="Rule.content"/>
        <xs:attributeGroup ref="Rule.attlist"/>
    </xs:complexType>
    <xs:element name="Rule" type="Rule.type"/>
    <!--
     *** on ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-on
     
     content model: 
     DR Reaction RuleMl: (  )
     KR Reaction RuleMl: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Situation)
     PR Reaction RuleML: ( )
     ECA Reaction RuleML: (Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operation)  
     CEP Reaction RuleML: (Receive | Answer | Event | Action | Sequence | Disjunction | Xor | Conjunction | Concurrent | Not | Any | Aperiodic | Periodic | AtLeast | ATMost | Operation) 
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="on.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
        <xs:attributeGroup ref="edge-element.attlist"/>
    </xs:attributeGroup>
    <xs:group name="on.content">
        <xs:choice>
            <xs:group ref="event_group.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="on.type">
        <xs:group ref="on.content"/>
        <xs:attributeGroup ref="on.attlist"/>
    </xs:complexType>
    <xs:element name="on" type="on.type"/>
    <!--
     *** if ***
     *** after ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-if
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-after
     
     content model:   
     DR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
     KR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Naf  )    
     ECA Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
	
	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:element name="after" type="if.type"/>
    <!--
	 *** then ***	
     *** else ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-then
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-else
     
     content model: 
     DR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval )
     KR Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: not used in PR Reaction RuleML (only in combination with DR)
     ECA Reaction RuleML: (  Atom  | Negation | Neg | Equal | Time | Spatial | Interval | Event | Action )
	
	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:element name="else" type="then.type"/>
    <!--
     *** do ***
     *** elseDo ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-do
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-elseDo
     
     content model:  
     DR Reaction RuleML: (  )
     KR Reaction RuleML: ( Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation )
     PR Reaction RuleML: (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operation)
     ECA Reaction RuleML:  (Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operation)
     CEP Reaction RuleML:  (Send | Consult | Action | Assert | Retract | Update | Query | Succession | Choice | Flow | Loop | Operation)

	attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="do.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
        <xs:attributeGroup ref="edge-element.attlist"/>
    </xs:attributeGroup>
    <xs:group name="do.content">
        <xs:choice>
            <xs:group ref="action_group.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="do.type">
        <xs:group ref="do.content"/>
        <xs:attributeGroup ref="do.attlist"/>
    </xs:complexType>
    <xs:element name="do" type="do.type"/>
    <xs:element name="elseDo" type="do.type"/>
    <!--
  *** Derivation Rule content model ***
  	((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
	-->
    <xs:group name="DerivationRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="else"/>
                <xs:element ref="then"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element ref="then"/>
                <xs:element minOccurs="0" ref="else"/>
            </xs:sequence>
            <xs:sequence>
                <xs:group ref="if.content"/>
                <xs:group ref="then.content"/>
                <xs:group minOccurs="0" ref="then.content"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** Production Rule content model ***
   ((if, do, elseDo?) | (elseDo?, do, if))
-->
    <xs:group name="ProductionRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="elseDo"/>
                <xs:element ref="do"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element ref="do"/>
                <xs:element minOccurs="0" ref="elseDo"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** Combined DR Production Rule content model ***
   Production Rule       Derivation Rule    Production Rule with conclusion   inverse Production Rule with conclusion 
   ((if, do, elseDo?) | (if, then, else) | (if, do, then?, elseDo?, else?) | (else?, elseDo?, then?, do, if))
-->
    <xs:group name="DRProductionRule.content">
        <xs:choice>
            <xs:sequence>
                <xs:element minOccurs="0" ref="else"/>
                <xs:element minOccurs="0" ref="elseDo"/>
                <xs:element minOccurs="0" ref="then"/>
                <xs:element ref="do"/>
                <xs:element ref="if"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element ref="if"/>
                <xs:element minOccurs="0" ref="do"/>
                <xs:element minOccurs="0" ref="then"/>
                <xs:element minOccurs="0" ref="elseDo"/>
                <xs:element minOccurs="0" ref="else"/>
            </xs:sequence>
        </xs:choice>
    </xs:group>
    <!--
   *** Reaction Rule content model ***
   (on, (if?, then?, do?, after?,else?, elseDo?)? )
-->
    <xs:group name="ReactionRule.content">
        <xs:sequence>
            <xs:element ref="on"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element minOccurs="0" ref="if"/>
                    <xs:element minOccurs="0" ref="then"/>
                    <xs:element minOccurs="0" ref="do"/>
                    <xs:element minOccurs="0" ref="after"/>
                    <xs:element minOccurs="0" ref="else"/>
                    <xs:element minOccurs="0" ref="elseDo"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <!--
   *** Messaging Rule content model ***
   (do)
-->
    <xs:group name="MessagingRule.content">
        <xs:sequence>
            <xs:element ref="do"/>
        </xs:sequence>
    </xs:group>
    <xs:annotation>
        <xs:documentation xml:lang="en">         Negation module part of Reaction RuleML.   This
            defines the negation elements for Reaction RuleML.   File: negation_module.xsd
            Version: 1.0   Last Modification: 2011-03-22      * Negation  generic polymorphig
            negation   * Naf           negation as failure (inflationary negation in production
            rules), weak negation   * Neg           classical negation, strong negation   * weak
            * strong   * formula        </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-22T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
		*** Negation ***
		A generic polymorphic negation
		
		see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Negation
		
		It can be specialized by using
		the @type attribute to specify the type of negation and/or 
 		the @iri attribute to point to an external definition of the negation
 		@key, @keyref, @node

		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
        PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation ) )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action) )
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
		-->
    <xs:attributeGroup name="Negation.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Negation.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:element form="qualified" name="formula" type="formula-negation.type"/>
                <xs:group ref="formula-negation.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Negation.type">
        <xs:group ref="Negation.content"/>
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:complexType>
    <xs:element name="Negation" type="Negation.type"/>
    <xs:attributeGroup name="formula-negation.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="formula-negation.content">
        <xs:choice>
            <xs:element form="qualified" name="Operation" type="ConnectiveOperator.type"/>
            <xs:element ref="Equal"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Neg"/>
            <xs:group ref="extended-signature-predicate-sorts.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-negation.type">
        <xs:group ref="formula-negation.content"/>
        <xs:attributeGroup ref="formula-negation.attlist"/>
    </xs:complexType>
    <xs:element name="formula" type="formula-negation.type"/>
    <!--
		*** Naf ***
		A "by default" negation of a logical atom (i.e. "weak" negation or
		negation-as-failure).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Naf
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
   		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation ) )
 		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )  		
	
		attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <xs:attributeGroup name="Naf.attlist">
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Naf.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:element ref="weak"/>
                <xs:group ref="weak.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Naf.type">
        <xs:group ref="Naf.content"/>
        <xs:attributeGroup ref="Naf.attlist"/>
    </xs:complexType>
    <xs:element name="Naf" type="Naf.type"/>
    <!--
		*** weak ***
		A role used for negation as failure.
	
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-weak
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation |  Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
		PR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation ) )
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation |  Neg | Time | Interval | Spatial | Event | Action ) )
		
		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="weak.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="weak.content">
        <xs:choice>
            <xs:group ref="formula-negation.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="weak.type">
        <xs:group ref="weak.content"/>
        <xs:attributeGroup ref="weak.attlist"/>
    </xs:complexType>
    <xs:element name="weak" type="weak.type"/>
    <!--
		*** Neg ***
		A classical negation of a logical atom (i.e. classical or "strong" negation).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Neg
		
		content model:
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )
		PR Reaction RuleML: strong negation not supported by PR Reaction RuleML
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <xs:attributeGroup name="Neg.attlist">
        <xs:attributeGroup ref="Negation.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Neg.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:element ref="strong"/>
                <xs:group ref="strong.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Neg.type">
        <xs:group ref="Neg.content"/>
        <xs:attributeGroup ref="Neg.attlist"/>
    </xs:complexType>
    <xs:element name="Neg" type="Neg.type"/>
    <!--
		*** strong ***
		A role used for classical negation.
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-strong
		
		content model: 
		DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial ) )
		KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | | Neg | Time | Interval | Spatial | Event | Action | Situation | Holds | Happens | Initates | Terminates ) )	
		PR Reaction RuleML: strong negation not supported by PR Reaction RuleML 
		ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (formula | Operation | Atom | Equal | Negation | Neg | Time | Interval | Spatial | Event | Action ) )	

		attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="strong.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="strong.content">
        <xs:choice>
            <xs:group ref="formula-negation.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="strong.type">
        <xs:group ref="strong.content"/>
        <xs:attributeGroup ref="strong.attlist"/>
    </xs:complexType>
    <xs:element name="strong" type="strong.type"/>
    <xs:annotation>
        <xs:documentation xml:lang="en">                                 Quantifier module part of
            Reaction RuleML redefining the Forall, Exists and introduce the Quantifier element.
            This is the XML Schema Quantifier element for Reaction RuleML.   File:
            quantifier_module.xsd   Version: 1.0   Last Modification: 2011-03-22       * Quantifier
            generic quantifier (used in quantification metatag)   * Forall  predefined inner
            quantifier (used in quantification metatag)   * Exist   predefined inner quantifier
            (used in qualification metatag)       </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-22T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Quantifier ***
	Explicit generic quantifier, where the quantifier name can be defined by the 
    @type attribute and the @iri attribute can point to an external definition
    of the quantifier.
    
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Quantifier
    
    Format: "quantifier declare(Var)+ such that guard formula(...)?" 
		
	content model: 
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )?

	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="Quantifier.attlist">
        <xs:attributeGroup ref="quantifier-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="1">
                <xs:element ref="declare"/>
                <xs:element ref="Var"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-inner-quantifier.type"/>
                <xs:group ref="formula-inner-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Quantifier.type">
        <xs:group ref="Quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <xs:element name="Quantifier" type="Quantifier.type"/>
    <!-- Exists
	make the quantifier constraint restrictions ("such that") optional
	
	http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Exists
	
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?

	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
    -->
    <xs:group name="Exists-quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="1">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-inner-quantifier.type"/>
                <xs:group ref="formula-inner-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Exists-quantifier.type">
        <xs:group ref="Exists-quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <!-- Forall
	make the quantifier constraint restrictions ("such that") optional
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Forall
	
	DR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval )?
	KR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation)
    PR Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Naf)
    ECA Reaction RuleML ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (declare|Var)+, (formula| Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action)?
	
	attributes: @type?, @card?, @minCard?, @maxCard?, @style?, @scope?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:group name="Forall-quantifier.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="1">
                <xs:element ref="declare"/>
                <xs:group ref="declare.content"/>
            </xs:choice>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-inner-quantifier.type"/>
                <xs:group ref="formula-inner-quantifier.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Forall-quantifier.type">
        <xs:group ref="Forall-quantifier.content"/>
        <xs:attributeGroup ref="Quantifier.attlist"/>
    </xs:complexType>
    <!--
		*** formula ***
		The 'such that' guard formula role of a quantifier (<Forall> or <Exists>).
		
		See http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-formula
		
	     DR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval  )
     	 KR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action | Situation )
     	 PR Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Naf  ) 
     	 ECA Reaction RuleML: (Operation | Atom | And | Or | Equal | Negation | Neg | Naf | Time | Spatial | Interval | Event | Action )
		
		Other (context-sensitive) versions of <formula> are in the
		connective and performative modules.
		
		attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:group name="formula-inner-quantifier.content">
        <xs:choice>
            <xs:group ref="guard.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="formula-inner-quantifier.type">
        <xs:group ref="formula-inner-quantifier.content"/>
        <xs:attributeGroup ref="formula.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">         Profile module part of Reaction RuleML.   This is
            the XML Schema Profile element for Reaction RuleML for describing semantic profiles.
            Semantic Profiles are used to define the interpretation evaluation semantics (under the
            evaluation metatag)    either by referecing external existing profiles or by defining
            them internally.   File: profile_module.xsd   Version: 1.0   Last Modification:
            2011-03-22      * Profile         generic semantic profile       </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-22T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Profile ***
	Explicit generic semantic profile defining the intended semantics for knowledge interpretation, inference and execution. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Profile
	
	The semantic profile can be defined internally by the any content model (xs:any Element) or externally  

	DR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | content(xs:any*)  )*)
    KR Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | Situation | Holds | Initiates | Terminates | Happens | content(xs:any*) )*)	
    PR Reaction RuleML: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Equal | content(xs:any*)  )*)
 	ECA Reaction RuleMl: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?,  (formula | Operation | Rulebase | Atom | Rule | Equivalent | Entails | Forall | Quantifier | Equal | Negation | Neg | Time | Spatial | Interval | Event | Action | content(xs:any*)  )*)   
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @safety, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
	-->
    <xs:attributeGroup name="Profile.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="safety.attrib"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Profile.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element form="qualified" name="formula" type="formula-assert.type"/>
                <xs:group ref="formula-assert.content"/>
                <xs:element form="qualified" name="content" type="profile_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Profile.type">
        <xs:group ref="Profile.content"/>
        <xs:attributeGroup ref="Profile.attlist"/>
    </xs:complexType>
    <xs:element name="Profile" type="Profile.type"/>
    <!--
     *** content ***
     
     	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     the optional @prefix and @vocab are used to define a prefix and a term mapping vocabulary for the XML content (see CURIE to IRI and term to IRI translation)
     content model:  (xs:any*)
     
     attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="profile_anycontent.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="profile_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="profile_anycontent.type">
        <xs:group ref="profile_anycontent.content"/>
        <xs:attributeGroup ref="profile_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               Time module part of Reaction RuleML. It
            defines the core     time constructs        This is the XML Schema time module for
            Reaction RuleML.    File: time_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Time    </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Time ***
	Explicit generic Time construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Situation
	
	The time can be represented internally 
      * with positional arguments <arg>, e.g., <arg><Data xsi:type="xs:dateTime>2011-10-02T10:45:34-00:00</Data></arg>
      * with unpositional slots <slot>, e.g., <slot><Ind>year</Ind><Ind>2011</Ind></slot><slot><Ind>month</Ind><Ind>10</Ind></slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed one of the many existing XML syntaxes for time
      or externally, where the optional @iri attribute points to an external data definition of the time
      The optional @type attribute defines the type of the time, e.g. ruleml:TimeInstant (linear continuous time model) 
      or ruleml:TimeInterval (discrete time interval model). The default time semantics is a discrete time model.
      Note: Time can be defined absolute or relative.
      		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operation))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	KR Reaction RuleML:  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
				((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operation))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 
	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operation))+, (repo)?)|(repo)),(slot)*, (resl)?)?) |		       
				content(xs:any*)* ) ) 	
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Time.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Time.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg" type="arg_time.type"/>
                                        <xs:group ref="time_primitives.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                            <xs:element minOccurs="0" ref="resl"/>
                        </xs:sequence>
                    </xs:choice>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="time_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Time.type">
        <xs:group ref="Time.content"/>
        <xs:attributeGroup ref="Time.attlist"/>
    </xs:complexType>
    <xs:element name="Time" type="Time.type"/>
    <!--
     *** arg ***
     
     Definition of the the arg role for Time
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval | (After | Before | Any | Every | Timer | Operation))
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operation))
     in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operation))  
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
          
-->
    <xs:attributeGroup name="arg_time.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_time.content">
        <xs:choice>
            <xs:group ref="time_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_time.type">
        <xs:group ref="arg_time.content"/>
        <xs:attributeGroup ref="arg_time.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
     
     content model:  xs:any*

     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="time_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="time_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="time_anycontent.type">
        <xs:group ref="time_anycontent.content"/>
        <xs:attributeGroup ref="time_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">        Spatial module part of Reaction RuleML. It defines
            the core     spatial constructs        This is the XML Schema spatial module for
            Reaction RuleML.    File: spatial_module.xsd    Version: 1.0    Last Modification:
            2011-03-29        This schema declares the following Reaction RuleML elements and
            attributes:        * Spatial       </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Spatial ***
	Explicit generic Spatial construct. 
	
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Spatial
	
	The spatial can be represented internally 
      * with positional arguments <arg>
      * with unpositional slots <slot>
      * by the any content model (<content>xs:any Element</content>), which acts as an extension point to embed arbitrary XML syntaxes
      or externally, where the optional @iri attribute points to an external data definition of the spatial
      The optional @type attribute defines the type of the spatial
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operation))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation| (After | Before | Any | Every | Timer | Operation))+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
	PR Reaction RuleML: not used in PR Reaction RuleML
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ( 
		        ((slot)*,(resl)?,((((arg|Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action)+, (repo)?)|(repo)),(slot)*, (resl)?)?) | 
				content(xs:any*)* ) ) 
				
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Spatial.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Spatial.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice>
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="slot"
                        type="slot.type"/>
                    <xs:element minOccurs="0" ref="resl"/>
                    <xs:choice minOccurs="0">
                        <xs:sequence>
                            <xs:choice>
                                <xs:sequence>
                                    <xs:choice maxOccurs="unbounded">
                                        <xs:element form="qualified" name="arg"
                                            type="arg_spatial.type"/>
                                        <xs:group ref="spatial_primitives.content"/>
                                    </xs:choice>
                                    <xs:element minOccurs="0" ref="repo"/>
                                </xs:sequence>
                                <xs:element ref="repo"/>
                            </xs:choice>
                            <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                                name="slot" type="slot.type"/>
                            <xs:element minOccurs="0" ref="resl"/>
                        </xs:sequence>
                    </xs:choice>
                </xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="content"
                    type="spatial_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Spatial.type">
        <xs:group ref="Spatial.content"/>
        <xs:attributeGroup ref="Spatial.attlist"/>
    </xs:complexType>
    <xs:element name="Spatial" type="Spatial.type"/>
    <!--
     *** arg ***
     
     Definition of the the arg role for Spatial
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval| (After | Before | Any | Every | Timer | Operation))
     in KR Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action|Situation | (After | Before | Any | Every | Timer | Operation))
     in PR Reaction RuleML: not used in PR Reaction RuleML
     in ECA Reaction RuleML: (Ind|Data|Skolem|Var|Reify|Expr|Plex|Time|Spatial|Interval|Event|Action | (After | Before | Any | Every | Timer | Operation)) 
     
      @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?  
-->
    <xs:attributeGroup name="arg_spatial.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_spatial.content">
        <xs:choice>
            <xs:group ref="spatial_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_spatial.type">
        <xs:group ref="arg_spatial.content"/>
        <xs:attributeGroup ref="arg_spatial.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     @prefix and @vocab is used to define a prefix and a term mapping vocabulary for the XML content
     	See CURIE to IRI and term to IRI translation
     
     content model:  xs:any*
     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="spatial_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="spatial_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="spatial_anycontent.type">
        <xs:group ref="spatial_anycontent.content"/>
        <xs:attributeGroup ref="spatial_anycontent.attlist"/>
    </xs:complexType>
    <xs:annotation>
        <xs:documentation xml:lang="en">               Interval module part of Reaction RuleML. It
            defines the core     Interval construct        This is the XML Schema interval module
            for Reaction RuleML.    File: interval_module.xsd    Version: 1.0    Last Modification:
            2011-03-29     This schema declares the following Reaction RuleML elements and
            attributes:       * Interval    </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
	*** Interval ***
	Explicit generic Interval. 
	
    see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Interval
	
	The interval can be
      defined internally by the any content model (xs:any Element) or externally, where 
      the optional @type attribute defines the name/type of the interval,
      the optional @iri attribute points to an external definition of the interval, and
       An interval can be defined by Events, Actions,  Times, Spatials, and other Intervals can be typed by the 
       interval ontology of Reaction RuleML (defining different types of intervals).
		
	content model: 
	DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex| (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation))?])) 
	KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation)), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation))?] )) 
    PR Reaction RuleML: not used in PR Reaction RuleML 
	ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation)), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation))?])) 
	
	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Interval.attlist">
        <xs:attributeGroup ref="formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Interval.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:sequence>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:element form="qualified" minOccurs="0" name="arg" type="arg_interval.type"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:group ref="interval_primitives.content"/>
                    <xs:group minOccurs="0" ref="interval_primitives.content"/>
                </xs:sequence>
                <xs:sequence>
                    <xs:element form="qualified" name="content" type="interval_anycontent.type"/>
                    <xs:element form="qualified" minOccurs="0" name="content"
                        type="interval_anycontent.type"/>
                </xs:sequence>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Interval.type">
        <xs:group ref="Interval.content"/>
        <xs:attributeGroup ref="Interval.attlist"/>
    </xs:complexType>
    <xs:element name="Interval" type="Interval.type"/>
    <!--
     *** arg ***
     
     Definition of the the arg role for Intervals
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-arg
     
     content model:  
     in DR Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)
     in KR Reaction RuleML: (Time | Spatial | Interval |  Event | Action | Situation | Ind | Data | Skolem | Var | Reify | Expr | Plex | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation) )
     not used in PR Reaction RuleML     
     ECA Reaction RuleML: (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)
     
     attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="arg_interval.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="arg_interval.content">
        <xs:choice>
            <xs:group ref="interval_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="arg_interval.type">
        <xs:group ref="arg_interval.content"/>
        <xs:attributeGroup ref="arg_interval.attlist"/>
    </xs:complexType>
    <!--
     *** content ***
     
          see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-content
     
     content model:  xs:any*
     
     @prefix is used to define a prefix and a term mapping vocabulary for the XML content
     See CURIE to IRI and term to IRI translation
     
     attributes:  @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
-->
    <xs:attributeGroup name="interval_anycontent.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="interval_anycontent.content">
        <xs:choice>
            <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="interval_anycontent.type">
        <xs:group ref="interval_anycontent.content"/>
        <xs:attributeGroup ref="interval_anycontent.attlist"/>
    </xs:complexType>
    <!-- include spatial-temporal and interval operators from the algebra modules of reaction ruleml   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">                        spatial-temporal-interval algebra
            module part of Reaction RuleML    This is the XML Schema of the algebra module for
            Reaction RuleML    File: spatial_temporal_interval_algebra_module.xsd    Version: 1.0
            Last Modification: 2011-03-22        This schema declares the following Reaction RuleML
            elements and attributes:                                      Operation (generic
            operator)                   at (general role "at Time | Spatial | Interval)
            Spatial, Temporal, Interval Function Constructs                                       *
            After                   * Before       * Every                   * Any
            * Timer                                                         (Allen's) Interval
            Relations                                      * During                   * Overlaps
            * Starts                   * Precedes                   * Succeeds                   *
            Meets                   * Equal                   * Finishes
            The approach is modelled after that used in "Modularization of XHTML in XML Schema"
            WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be integrated with
            "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].   </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-22T29:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--(After | Before | Any | Every | Timer | Operation)-->
    <xs:group name="spatial_temporal_algebra_group.content">
        <xs:choice>
            <xs:element ref="After"/>
            <xs:element ref="Before"/>
            <xs:element ref="Every"/>
            <xs:element ref="Any"/>
            <xs:element ref="Timer"/>
            <xs:element form="qualified" name="Operation" type="Any.type"/>
        </xs:choice>
    </xs:group>
    <!-- (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes | Operation) -->
    <xs:group name="interval_algebra_group.content">
        <xs:choice>
            <xs:element ref="During"/>
            <xs:element ref="Overlaps"/>
            <xs:element ref="Starts"/>
            <xs:element ref="Precedes"/>
            <xs:element ref="Succeeds"/>
            <xs:element ref="Meets"/>
            <xs:element form="qualified" name="Equal" type="IntervalAlgebraOperator.type"/>
            <xs:element ref="Finishes"/>
            <xs:element form="qualified" name="Operation" type="IntervalAlgebraOperator.type"/>
        </xs:choice>
    </xs:group>
    <!--
      *** at ***
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-at
      
	  Note: In Situation Calculus the time is a situation (the history of occured situations as a finite sequence of the events/actions) 	
	
      content model: 
      in KR Reaction RuleML: (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)
      in ECA Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operation))
      in CEP Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action) | (After | Before | Any | Every | Timer | Operation))
      
      attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="at.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="at.content">
        <xs:choice>
            <xs:group ref="time_primitives.content"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="at.type">
        <xs:group ref="at.content"/>
        <xs:attributeGroup ref="at.attlist"/>
    </xs:complexType>
    <xs:element name="at" type="at.type"/>
    <!--
      *** After / Before***

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-After
	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Before

      X after Y  / X before Y
      
      Note: Y might be absolute or relative, e.g. "after 2 days", "2 days after X"  

      content model: 
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] ))
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex | Event | Action)?])) 	  

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="After.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="After.content">
        <xs:sequence>
            <xs:group ref="Interval.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="After.type">
        <xs:group ref="After.content"/>
        <xs:attributeGroup ref="After.attlist"/>
    </xs:complexType>
    <xs:element name="After" type="After.type"/>
    <xs:element name="Before" type="After.type"/>
    <!--
      *** Every ***
      
      Every X 
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Every
      
      Note:  X is often a relative, e.g. "every Monday", "every 2 meters" 
      
      content model:
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation) ))
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg | content(xs:any) | (Time | Spatial | Interval |  Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex) )) 

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Every.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Every.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                <xs:group ref="interval_primitives.content"/>
                <xs:element form="qualified" name="content" type="interval_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Every.type">
        <xs:group ref="Every.content"/>
        <xs:attributeGroup ref="Every.attlist"/>
    </xs:complexType>
    <xs:element name="Every" type="Every.type"/>
    <!--
      *** Any ***
      
      Any X1,..Xn
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Any
            
      e.g. "at any Saturday and Sunday"     
           
      content model: 
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg*] | content(xs:any)* | (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)* ))
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (arg* | content(xs:any)* | (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)*)) 

	attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Any.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Any.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice minOccurs="0">
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="arg"
                    type="arg_interval.type"/>
                <xs:group maxOccurs="unbounded" minOccurs="1" ref="interval_primitives.content"/>
                <xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="content"
                    type="interval_anycontent.type"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Any.type">
        <xs:group ref="Any.content"/>
        <xs:attributeGroup ref="Any.attlist"/>
    </xs:complexType>
    <xs:element name="Any" type="Any.type"/>
    <!--
      *** (Recurring) Timer ***
      
      After X Every Y
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Recurring
      
      Note: X and Y might be relative, e.g. after 1 hour every hour (recurring timer)
      
      content model: 
         
      DR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval |  Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
	  KR Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation), (Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval | Event | Action | Situation)?] )) 
      ECA Reaction RuleML: ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg?] | [content(xs:any),content(xs:any)?] | [(Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex), (Time | Spatial | Interval | Event | Action | Ind | Data | Skolem | Var | Reify | Expr | Plex)?])) 
       
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="Timer.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Timer.content">
        <xs:sequence>
            <xs:group ref="Interval.content"/>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Timer.type">
        <xs:group ref="Timer.content"/>
        <xs:attributeGroup ref="Timer.attlist"/>
    </xs:complexType>
    <xs:element name="Timer" type="Timer.type"/>
    <!--
      *** (During | Overlaps | Starts | Precedes | Succeeds | Meets | Equal | Finishes) ***
      
      operator(Interval, Interval)
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-During
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Overlaps
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Starts
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Precedes
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Succeeds
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Meets
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Equal
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Finishes
      
      content model: 
      ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, ([arg, arg] | [Interval, Interval])
      
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="IntervalAlgebraOperator.attlist">
        <xs:attributeGroup ref="operator-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="IntervalAlgebraOperator.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence>
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:element ref="Interval"/>
                </xs:choice>
                <xs:choice>
                    <xs:element form="qualified" name="arg" type="arg_interval.type"/>
                    <xs:element ref="Interval"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="IntervalAlgebraOperator.type">
        <xs:group ref="IntervalAlgebraOperator.content"/>
        <xs:attributeGroup ref="IntervalAlgebraOperator.attlist"/>
    </xs:complexType>
    <xs:element name="During" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Overlaps" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Starts" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Precedes" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Succeeds" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Meets" type="IntervalAlgebraOperator.type"/>
    <xs:element name="Finishes" type="IntervalAlgebraOperator.type"/>
    <!-- include test suites   -->
    <xs:annotation>
        <xs:documentation xml:lang="en">        Test and Proof module part of Reaction RuleML.
            This is the XML Schema Test module for Reaction RuleML.    File: test_module.xsd
            Version: 1.0    Last Modification: 2011-07-20        Further information - see RBSLA
            project (http://rbsla.ruleml.org)    ContractLog framework VVI Testing:
            http://rbsla.ruleml.org/docs/ContractLog_VVI.pdf        This schema declares the
            following Reaction RuleML elements and attributes:            * Test    * vvi    *
            TestSuite    * testbase    * TestItem    * Answer     * formula (Answer)    *
            expectedResult        The approach is modelled after that used in "Modularization of
            XHTML in XML Schema"    WD [http://www.w3.org/TR/xhtml-m12n-schema/], which will soon be
            integrated with    "Modularization of XHTML" (REC-xhtml-modularization-20010410)
            [http://www.w3.org/TR/xhtml-modularization/].       </xs:documentation>
        <xs:documentation source="http://ruleml.org/licensing/ruleml_eula.html"/>
        <xs:appinfo>
            <dc:title>Reaction RuleML Schema</dc:title>
            <dc:version>1.0</dc:version>
            <dc:creator>Adrian Paschke (paschke AT gmx.de)</dc:creator>
            <dc:subject>RuleML, custom-built for Reaction RuleML 1.0</dc:subject>
            <dc:description>custom-built main module for Reaction RuleML</dc:description>
            <dc:date>2011-03-29T23:11:17-0300</dc:date>
            <dc:language>en</dc:language>
            <dcterms:rights>LGPL-3.0</dcterms:rights>
            <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
        </xs:appinfo>
    </xs:annotation>
    <!--
      *** Test ***
      A Test action/primitive that provides the syntax for Verification, Validation and Integrity (VVI) Testing.
      
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-Test
      
      An optional scope (<scope>) can be defined so that the test applies only to the scope (constructed view) on the knowledge base.

      content model: 
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (vvi | Entails | TestItem | TestSuite)*)
      
      Test has the following attributes:
      attributes: @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @safety?, @scope?, @closure?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?   
	-->
    <xs:attributeGroup name="Test.attlist">
        <xs:attributeGroup ref="action-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="Test.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="vvi"/>
                <xs:group ref="vvi.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="Test.type">
        <xs:group ref="Test.content"/>
        <xs:attributeGroup ref="Test.attlist"/>
    </xs:complexType>
    <xs:element name="Test" type="Test.type"/>
    <!--
     *** vvi ***
     
     vvi role - "verification, validation, integrity" tests
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-vvi
     
     content model: ( Entails | TestItem | TestSuite )
     
      vvi has the following attributes:
    attributes: @index?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
-->
    <xs:attributeGroup name="vvi.attlist">
        <xs:attributeGroup ref="edge-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="vvi.content">
        <xs:choice>
            <xs:element ref="Entails"/>
            <xs:element ref="TestSuite"/>
            <xs:element ref="TestItem"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="vvi.type">
        <xs:group ref="vvi.content"/>
        <xs:attributeGroup ref="vvi.attlist"/>
    </xs:complexType>
    <xs:element name="vvi" type="vvi.type"/>
    <!--
     *** testsbase ***
     
     base role for the test assertion | consultation base
     
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-testbase
     
     content model: ( Consult | Assert )
     
      base has the following attributes:
         attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base? 
-->
    <xs:attributeGroup name="testbase.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="testbase.content">
        <xs:choice>
            <xs:element ref="Consult"/>
            <xs:element ref="Assert"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="testbase.type">
        <xs:group ref="testbase.content"/>
        <xs:attributeGroup ref="testbase.attlist"/>
    </xs:complexType>
    <xs:element name="testbase" type="testbase.type"/>
    <!--
      *** TestSuite ***
      A TestSuite consisting of the assertion | consultation base (test assertions) and the VVI tests (integrity entailments, test items or nested test suites 

	see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestSuite

      content model: 
       ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (testbase | Consult | Assert), (vvi | Entails | TestItem | TestSuite)*)
      
      TestSuite has the following attributes:
      attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	-->
    <xs:attributeGroup name="TestSuite.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="TestSuite.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="testbase"/>
                <xs:element ref="Assert"/>
                <xs:element ref="Consult"/>
            </xs:choice>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element ref="vvi"/>
                <xs:group ref="vvi.content"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="TestSuite.type">
        <xs:group ref="TestSuite.content"/>
        <xs:attributeGroup ref="TestSuite.attlist"/>
    </xs:complexType>
    <xs:element name="TestSuite" type="TestSuite.type"/>
    <!--
      *** TestItem ***
      TestItem describing one particular test consisting of the test act (typically a Query) and the expected result (the expected Answer with the predefined expected truth valuation (<degree>) and results/variable bindings)
      
     see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-TestItem
      
      content model:
 		 
	  ( meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?, (act|Query|Assert|Retract|Update|Send|Receive|Consult|Test|Action), (expectedResult|Answer) )

     attributes:  @type?, @mode?, @arity?, @card?, @minCard?, @maxCard?, @weight?, @style?, @direction?, @scope?, @closure?, @material?, @per?, @meta?, @qualify?, @node?, @iri?, @vocab?, @prefix?, @key?, @keyref?, @xml:id?, @xml:base?
	  
    -->
    <xs:attributeGroup name="TestItem.attlist">
        <xs:attributeGroup ref="group-formula-interface.attlist"/>
        <xs:attributeGroup ref="node-element.attlist"/>
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="TestItem.content">
        <xs:sequence>
            <xs:group ref="meta-roles.content"/>
            <xs:sequence>
                <xs:choice>
                    <xs:element ref="act"/>
                    <xs:group ref="act.content"/>
                </xs:choice>
                <xs:choice>
                    <xs:element ref="expectedResult"/>
                    <xs:group ref="expectedResult.content"/>
                </xs:choice>
            </xs:sequence>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="TestItem.type">
        <xs:group ref="TestItem.content"/>
        <xs:attributeGroup ref="TestItem.attlist"/>
    </xs:complexType>
    <xs:element name="TestItem" type="TestItem.type"/>
    <!--
     *** expectedResult***
     
     Definition of the the enclosed role for Send and Receive actions
     
      see: http://wiki.ruleml.org/index.php/Glossary_of_Reaction_RuleML_1.0#gloss-expectedResult
     
     content model:  
      in CEP Reaction RuleML: (Answer)
      
      attributes: @prefix?, @key?, @keyref?, @xml:id?, @xml:base?

-->
    <xs:attributeGroup name="expectedResult.attlist">
        <xs:attributeGroup ref="xml.attlist"/>
    </xs:attributeGroup>
    <xs:group name="expectedResult.content">
        <xs:choice>
            <xs:element ref="Answer"/>
        </xs:choice>
    </xs:group>
    <xs:complexType name="expectedResult.type">
        <xs:group ref="expectedResult.content"/>
        <xs:attributeGroup ref="expectedResult.attlist"/>
    </xs:complexType>
    <xs:element name="expectedResult" type="expectedResult.type"/>
    <!--
     metadata group
     
	This internal group defines the descriptive metadata and the scope (for scoped reasoning on the metadata) + additional guard constraints on the scope
	
     content model: (meta*, scope*, guard )
          
	-->
    <xs:group name="metadata.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="meta"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="scope"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="guard"/>
        </xs:sequence>
    </xs:group>
    <!--
     interface group
     
     This internal group defines the interface signature and the evaluation semantics
     
     content model: (evaluation*, signature* )
          
	-->
    <xs:group name="interface.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="evaluation"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="signature"/>
        </xs:sequence>
    </xs:group>
    <!--
     instance group
     
     This internal group defines the instance including the qualification (qualifying metadata), the quantification and the object id
     
     content model: (qualification*, quantification*, oid? )
          
	-->
    <xs:group name="instance.content">
        <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="qualification"/>
            <xs:element maxOccurs="unbounded" minOccurs="0" ref="quantification"/>
            <xs:element maxOccurs="1" minOccurs="0" ref="oid"/>
        </xs:sequence>
    </xs:group>
    <!--
         
     An internal group for the metadata, interface description, and instance qualification and quantification roles in the Reaction RuleML language
    
    
     content model: (meta*, scope*, guard*, evaluation*, signature*, qualification*, quantification*, oid?)
          
	-->
    <xs:group name="meta-roles.content">
        <xs:sequence>
            <xs:group ref="metadata.content"/>
            <xs:group ref="interface.content"/>
            <xs:group ref="instance.content"/>
        </xs:sequence>
    </xs:group>
    <!--
         
     An internal group for the implementation of a rule in the Reaction RuleML language
    
    
     content model:
     
     in DR Reaction RuleML: 
     
     ((else?, then, if) | (if, then, else?)	| (if.content, then.content, then.content?))
          
	-->
    <xs:group name="rule-implementation.content">
        <xs:choice>
            <xs:group ref="DerivationRule.content"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the query connectives in the Reaction RuleML language
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <xs:group name="query-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="ConnectiveOperator.type"/>
            <xs:element name="And" type="And-query.type"/>
            <xs:element name="Or" type="Or-query.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Naf"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the inner connectives in the Reaction RuleML language
    
    
     content model: (Operation | And | Or | Negation | Naf | Neg | Equal)
          
	-->
    <xs:group name="inner-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="ConnectiveOperator.type"/>
            <xs:element name="And" type="And-inner.type"/>
            <xs:element name="Or" type="Or-inner.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Naf"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the outer connectives in the Reaction RuleML language
    
    
     content model: (Operation | Negation | Neg | Equal )
          
	-->
    <xs:group name="outer-connective.content">
        <xs:choice>
            <xs:element name="Operation" type="ConnectiveOperator.type"/>
            <xs:element ref="Negation"/>
            <xs:element ref="Neg"/>
            <xs:element ref="Equal"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the query quantifiers in the Reaction RuleML language
    
     content model: (Exists )
          
	-->
    <xs:group name="query-quantifier.content">
        <xs:choice>
            <xs:element ref="Exists"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the inner quantifiers in the Reaction RuleML language
    
    
     content model: (Forall | Exists | Quantifier)
          
	-->
    <xs:group name="inner-quantifier.content">
        <xs:choice>
            <xs:element name="Forall" type="Forall-quantifier.type"/>
            <xs:element name="Exists" type="Exists-quantifier.type"/>
            <xs:element ref="Quantifier"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the outer quantifiers in the Reaction RuleML language
    
    
     content model: ( Forall  )
          
	-->
    <xs:group name="outer-quantifier.content">
        <xs:choice>
            <xs:element ref="Forall"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the different additional predicate sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the predicate sorts Time, Spatial and Interval
    
     content model: (Atom | Time | Spatial | Interval)
          
	-->
    <xs:group name="extended-signature-predicate-sorts.content">
        <xs:choice>
            <xs:element name="Atom" type="Atom.type"/>
            <xs:element ref="Time"/>
            <xs:element ref="Spatial"/>
            <xs:element ref="Interval"/>
        </xs:choice>
    </xs:group>
    <!--
         
     An internal group for the different additional function sorts supported in the respective language signature of the Reaction RuleML language
    
     In the DR dialect of Reaction RuleML the signature contains the function sorts Time, Spatial and Interval
    
     content model: (Ind | Data | Expr | Plex | Time | Spatial | Interval)
          
	-->
    <xs:group name="extended-signature-function-sorts.content">
        <xs:choice>
            <xs:element ref="Ind"/>
            <xs:element ref="Data"/>
            <xs:element ref="Expr"/>
            <xs:element ref="Plex"/>
            <xs:element ref="Time"/>
            <xs:element ref="Spatial"/>
            <xs:element ref="Interval"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the time primitives for interpretation as time
		content model: 
		in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operation))
	-->
    <xs:group name="time_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
            <xs:group ref="spatial_temporal_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the spatial primitives for interpretation as spatial
		content model: 
		in DR Reaction RuleML ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (After | Before | Any | Every | Timer | Operation))
	-->
    <xs:group name="spatial_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
            <xs:group ref="spatial_temporal_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- Interval primitives
		content model: 
		in DR Reaction RuleML: ((Ind | Data | Var | Skolem | Reify  | Expr | Plex | Time | Spatial | Interval) | (During | Overlaps | Starts | Precedes | Succeedes | Meets | Equals | Finishes | Operation))  -->
    <xs:group name="interval_primitives.content">
        <xs:choice>
            <xs:group ref="arg.content"/>
            <xs:group ref="interval_algebra_group.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the situation primitives for interpretation as situation
		content model: 
		in DR Reaction RuleML: ()
	-->
    <xs:group name="situation_primitives.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for the event primitives for interpretation as event
		content model: 
		in DR Reaction RuleML: ()
	-->
    <xs:group name="event_primitives.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for events
		content model:
		
		DR Reaction RuleML ( )-->
    <xs:group name="event_group.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for the action primitives for interpretation as action
		content model: 
		in DR Reaction RuleML: ()
	-->
    <xs:group name="action_primitives.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for actions
		content model:
		
		DR Reaction RuleML ( )-->
    <xs:group name="action_group.content">
        <xs:choice> </xs:choice>
    </xs:group>
    <!-- An internal group for the imports of the consult primitive
		content model: 
		in DR Reaction RuleML: (payload | RuleML | Reify | Var)
	-->
    <xs:group name="consult_imports.content">
        <xs:choice>
            <xs:element ref="payload"/>
            <xs:group ref="payload.content"/>
        </xs:choice>
    </xs:group>
    <!-- An internal group for the performative primitives
		content model: 
		in DR Reaction RuleML: (Consult|Assert|Retract|Query|Answer|Test)
	-->
    <xs:group name="performative_primitives.content">
        <xs:choice>
            <xs:element ref="Consult"/>
            <xs:element ref="Assert"/>
            <xs:element ref="Retract"/>
            <xs:element ref="Query"/>
            <xs:element ref="Answer"/>
            <xs:element ref="Test"/>
        </xs:choice>
    </xs:group>
    <!--
    *** @style ***
    
     restriction: active | messaging | reasoning
	 default value: reasoning (in DR Reaction RuleML)
	 optional attribute
-->
    <xs:attributeGroup name="style.attrib">
        <xs:attribute name="style" type="style.datatype" use="optional"/>
    </xs:attributeGroup>
</xs:schema>
