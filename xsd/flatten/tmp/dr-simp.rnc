default namespace = "http://ruleml.org/spec"

start = RuleML | Assert | Retract | Query
RuleML =
  element RuleML {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (act | Assert | Retract | Query)*
  }
Assert =
  element Assert {
    attribute size { xsd:int }?,
    attribute safety {
      xsd:string "transactional"
      | xsd:string "non-interrupting"
      | xsd:string "interrupting"
    }?,
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula
     | Rulebase
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Entails
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Retract =
  element Retract {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula
     | Rulebase
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Entails
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Query =
  element Query {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_2
     | Rulebase
     | Atom
     | Entails
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Exists
     | Quantifier
     | Time
     | Spatial
     | Interval)*
  }
meta =
  element meta {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Rulebase
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Entails
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
scope =
  element scope {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Rulebase
     | Atom
     | Entails
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Exists
     | Quantifier
     | Time
     | Spatial
     | Interval)?
  }
guard =
  element guard {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
evaluation =
  element evaluation {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    Profile
  }
signature =
  element signature {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Rulebase
     | Atom
     | Entails
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Exists
     | Quantifier
     | Time
     | Spatial
     | Interval)
  }
qualification =
  element qualification {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Rulebase
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Entails
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
quantification =
  element quantification {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Forall_2 | Exists_2 | Quantifier)
  }
oid =
  element oid {
    Ind
    | Data
    | Var
    | Skolem
    | Reify
    | Expr
    | Plex
    | Time
    | Spatial
    | Interval
  }
act =
  element act {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Assert | Retract | Query)
  }
formula =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Rulebase
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Entails
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
Rulebase =
  element Rulebase {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_3
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Atom =
  element Atom {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    degree?,
    (op | Rel),
    slot*,
    ((((arg
        | Ind
        | Data
        | Var
        | Skolem
        | Reify
        | Expr
        | Plex
        | Time
        | Spatial
        | Interval)+,
       repo?)
      | repo),
     slot*)?,
    resl?
  }
Implies =
  element Implies {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute material { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute direction {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((then, if)
     | (if, then)
     | ((Atom
         | And_2
         | Or_2
         | Negation
         | Naf
         | Neg
         | Equal
         | Time
         | Spatial
         | Interval),
        (Atom | Negation | Neg | Equal | Time | Spatial | Interval)))
  }
Rule =
  element Rule {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute material { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute direction {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    attribute style {
      xsd:string "reasoning"
      | xsd:string "active"
      | xsd:string "messaging"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((else?, then, if)
     | (if, then, else?)
     | ((Atom
         | And_2
         | Or_2
         | Negation
         | Naf
         | Neg
         | Equal
         | Time
         | Spatial
         | Interval),
        (Atom | Negation | Neg | Equal | Time | Spatial | Interval),
        (Atom | Negation | Neg | Equal | Time | Spatial | Interval)?))?
  }
Equivalent =
  element Equivalent {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((torso, torso)
     | ((Atom | Negation | Neg | Equal | Time | Spatial | Interval),
        (Atom | Negation | Neg | Equal | Time | Spatial | Interval)))
  }
Entails =
  element Entails {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (if_2 | Rulebase),
    (then_2 | Rulebase)
  }
Forall =
  element Forall {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (declare | Var)+,
    (formula_4
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
Quantifier =
  element Quantifier {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (declare | Var)+,
    (formula_4
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)?
  }
Negation =
  element Negation {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_5
     | Atom
     | Equal
     | Negation
     | Naf
     | Neg
     | Time
     | Spatial
     | Interval)
  }
Neg =
  element Neg {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (strong
     | Atom
     | Equal
     | Negation
     | Naf
     | Neg
     | Time
     | Spatial
     | Interval)
  }
Equal =
  element Equal {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute oriented { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    degree?,
    ((left, right)
     | ((Ind
         | Data
         | Var
         | Skolem
         | Reify
         | Expr
         | Plex
         | Time
         | Spatial
         | Interval),
        (Ind
         | Data
         | Var
         | Skolem
         | Reify
         | Expr
         | Plex
         | Time
         | Spatial
         | Interval)))
  }
Time =
  element Time {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((slot*,
      resl?,
      ((((arg_2
          | Ind
          | Data
          | Var
          | Skolem
          | Reify
          | Expr
          | Plex
          | Time
          | Spatial
          | Interval)+,
         repo?)
        | repo),
       slot*,
       resl?)?)
     | content+)
  }
Spatial =
  element Spatial {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((slot*,
      resl?,
      ((((arg_3
          | Ind
          | Data
          | Var
          | Skolem
          | Reify
          | Expr
          | Plex
          | Time
          | Spatial
          | Interval)+,
         repo?)
        | repo),
       slot*,
       resl?)?)
     | content_2+)
  }
Interval =
  element Interval {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    ((arg_4, arg_4?)
     | ((Ind
         | Data
         | Var
         | Skolem
         | Reify
         | Expr
         | Plex
         | Time
         | Spatial
         | Interval),
        (Ind
         | Data
         | Var
         | Skolem
         | Reify
         | Expr
         | Plex
         | Time
         | Spatial
         | Interval)?)
     | (content_3, content_3?))?
  }
formula_2 =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Rulebase
     | Atom
     | Entails
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Exists
     | Quantifier
     | Time
     | Spatial
     | Interval)
  }
And =
  element And {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_6
     | Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Or =
  element Or {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_6
     | Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Naf =
  element Naf {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (weak
     | Atom
     | Equal
     | Negation
     | Naf
     | Neg
     | Time
     | Spatial
     | Interval)
  }
Exists =
  element Exists {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (declare | Var)+,
    (formula_7
     | Atom
     | Exists
     | Quantifier
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
And_2 =
  element And {
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_6
     | Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Or_2 =
  element Or {
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (formula_6
     | Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)*
  }
Profile =
  element Profile {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute size { xsd:int }?,
    attribute safety {
      xsd:string "transactional"
      | xsd:string "non-interrupting"
      | xsd:string "interrupting"
    }?,
    attribute node { xsd:anyURI }?,
    attribute direction {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute iri { xsd:anyURI }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    content_4*
  }
Forall_2 =
  element Forall {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (declare | Var)+,
    (formula_4
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)?
  }
Exists_2 =
  element Exists {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (declare | Var)+,
    (formula_4
     | Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)?
  }
Ind =
  element Ind {
    text
    & (attribute xml:id { xsd:NCName }?,
       attribute xml:base { xsd:anyURI }?,
       attribute keyref {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute key {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute node { xsd:anyURI }?,
       attribute iri { xsd:anyURI }?,
       attribute type {
         xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
         | xsd:string {
             minLength = "1"
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           }
         | xsd:anyURI
       }?)
  }
Data =
  element Data {
    text
    & (attribute * { text }
       | _1)*
  }
Var =
  element Var {
    text
    & (attribute mode {
         xsd:string "+" | xsd:string "?" | xsd:string "-"
       }?,
       attribute xml:id { xsd:NCName }?,
       attribute xml:base { xsd:anyURI }?,
       attribute keyref {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute key {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute node { xsd:anyURI }?,
       attribute type {
         xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
         | xsd:string {
             minLength = "1"
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           }
         | xsd:anyURI
       }?)
  }
Skolem =
  element Skolem {
    text
    & (attribute xml:id { xsd:NCName }?,
       attribute xml:base { xsd:anyURI }?,
       attribute keyref {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute key {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute node { xsd:anyURI }?,
       attribute type {
         xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
         | xsd:string {
             minLength = "1"
             pattern =
               "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
           }
         | xsd:anyURI
       }?)
  }
Reify =
  element Reify {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    (_2
     | Implies
     | Assert
     | Naf
     | after
     | Data
     | arg
     | qualification
     | repo
     | Neg
     | _3
     | Expr
     | right
     | signature
     | else
     | resl
     | op
     | Spatial
     | quantification
     | Profile
     | declare
     | Plex
     | Fun
     | Forall
     | strong
     | Exists
     | then
     | Or_2
     | Negation
     | Entails
     | And_2
     | torso
     | Interval
     | scope
     | Query
     | meta
     | evaluation
     | Retract
     | Time
     | Atom
     | guard
     | oid
     | if
     | Rulebase
     | Equal
     | _4
     | left
     | slot
     | Quantifier
     | Reify
     | Equivalent
     | Rule
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | RuleML
     | Var
     | act
     | formula_5)?
  }
Expr =
  element Expr {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    attribute per {
      xsd:NMTOKEN "open" | xsd:NMTOKEN "value" | xsd:NMTOKEN "copy"
    }?,
    attribute type {
      xsd:Name { pattern = "[\i-[:]][/\c-[:]]*" }
      | xsd:string {
          minLength = "1"
          pattern =
            "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
        }
      | xsd:anyURI
    }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (op_2 | Fun),
    slot*,
    ((((arg
        | Ind
        | Data
        | Var
        | Skolem
        | Reify
        | Expr
        | Plex
        | Time
        | Spatial
        | Interval)+,
       repo?)
      | repo),
     slot*)?,
    resl?
  }
Plex =
  element Plex {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    slot*,
    (((arg
       | Ind
       | Data
       | Var
       | Skolem
       | Reify
       | Expr
       | Plex
       | Time
       | Spatial
       | Interval)+,
      repo?,
      slot*,
      resl?)?
     | (repo, slot*, resl?)
     | resl)
  }
formula_3 =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
degree =
  element degree {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Data
  }
op =
  element op {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Rel
  }
Rel =
  element Rel {
    text
    & (attribute per {
         xsd:NMTOKEN "open"
         | xsd:NMTOKEN "effect"
         | xsd:NMTOKEN "value"
         | xsd:NMTOKEN "modal"
         | xsd:NMTOKEN "copy"
       }?,
       attribute xml:id { xsd:NCName }?,
       attribute xml:base { xsd:anyURI }?,
       attribute keyref {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute key {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute node { xsd:anyURI }?,
       attribute iri { xsd:anyURI }?)
  }
slot =
  element slot {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute weight {
      xsd:decimal { minInclusive = "0" maxInclusive = "1" }
    }?,
    attribute card { xsd:nonNegativeInteger }?,
    (Ind | Data | Expr | Plex | Time | Spatial | Interval),
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
arg =
  element arg {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
repo =
  element repo {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Var | Plex_2)
  }
resl =
  element resl {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Var | Plex_3)
  }
then =
  element then {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom | Negation | Neg | Equal | Time | Spatial | Interval)
  }
if =
  element if {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
else =
  element else {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom | Negation | Neg | Equal | Time | Spatial | Interval)
  }
torso =
  element torso {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom | Negation | Neg | Equal | Time | Spatial | Interval)
  }
if_2 =
  element if {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Rulebase
  }
then_2 =
  element then {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Rulebase
  }
declare =
  element declare {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Var
  }
formula_4 =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | Implies
     | Rule
     | Equivalent
     | Forall
     | Quantifier
     | Negation
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
formula_5 =
  element formula {
    Atom | Equal | Negation | Naf | Neg | Time | Spatial | Interval
  }
strong =
  element strong {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom | Equal | Negation | Naf | Neg | Time | Spatial | Interval)
  }
left =
  element left {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
right =
  element right {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
arg_2 =
  element arg {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
content =
  element content {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (_5
     | _2
     | Implies
     | Assert
     | Naf
     | after
     | Data
     | arg
     | qualification
     | repo
     | Neg
     | _3
     | Expr
     | right
     | signature
     | else
     | resl
     | op
     | Spatial
     | quantification
     | Profile
     | declare
     | Plex
     | Fun
     | Forall
     | strong
     | Exists
     | then
     | Or_2
     | Negation
     | Entails
     | And_2
     | torso
     | Interval
     | scope
     | Query
     | meta
     | evaluation
     | Retract
     | Time
     | Atom
     | guard
     | oid
     | if
     | Rulebase
     | Equal
     | _4
     | left
     | slot
     | Quantifier
     | Reify
     | Equivalent
     | Rule
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | RuleML
     | Var
     | act
     | formula_5)*
  }
arg_3 =
  element arg {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)
  }
content_2 =
  element content {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (_6
     | _2
     | Implies
     | Assert
     | Naf
     | after
     | Data
     | arg
     | qualification
     | repo
     | Neg
     | _3
     | Expr
     | right
     | signature
     | else
     | resl
     | op
     | Spatial
     | quantification
     | Profile
     | declare
     | Plex
     | Fun
     | Forall
     | strong
     | Exists
     | then
     | Or_2
     | Negation
     | Entails
     | And_2
     | torso
     | Interval
     | scope
     | Query
     | meta
     | evaluation
     | Retract
     | Time
     | Atom
     | guard
     | oid
     | if
     | Rulebase
     | Equal
     | _4
     | left
     | slot
     | Quantifier
     | Reify
     | Equivalent
     | Rule
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | RuleML
     | Var
     | act
     | formula_5)*
  }
arg_4 =
  element arg {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute index { xsd:positiveInteger }?,
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval),
    (Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)?
  }
content_3 =
  element content {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (_7
     | _2
     | Implies
     | Assert
     | Naf
     | after
     | Data
     | arg
     | qualification
     | repo
     | Neg
     | _3
     | Expr
     | right
     | signature
     | else
     | resl
     | op
     | Spatial
     | quantification
     | Profile
     | declare
     | Plex
     | Fun
     | Forall
     | strong
     | Exists
     | then
     | Or_2
     | Negation
     | Entails
     | And_2
     | torso
     | Interval
     | scope
     | Query
     | meta
     | evaluation
     | Retract
     | Time
     | Atom
     | guard
     | oid
     | if
     | Rulebase
     | Equal
     | _4
     | left
     | slot
     | Quantifier
     | Reify
     | Equivalent
     | Rule
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | RuleML
     | Var
     | act
     | formula_5)*
  }
formula_6 =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
weak =
  element weak {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom | Equal | Negation | Naf | Neg | Time | Spatial | Interval)
  }
formula_7 =
  element formula {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | Exists
     | Quantifier
     | And
     | Or
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
content_4 =
  element content {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (_8
     | _2
     | Implies
     | Assert
     | Naf
     | after
     | Data
     | arg
     | qualification
     | repo
     | Neg
     | _3
     | Expr
     | right
     | signature
     | else
     | resl
     | op
     | Spatial
     | quantification
     | Profile
     | declare
     | Plex
     | Fun
     | Forall
     | strong
     | Exists
     | then
     | Or_2
     | Negation
     | Entails
     | And_2
     | torso
     | Interval
     | scope
     | Query
     | meta
     | evaluation
     | Retract
     | Time
     | Atom
     | guard
     | oid
     | if
     | Rulebase
     | Equal
     | _4
     | left
     | slot
     | Quantifier
     | Reify
     | Equivalent
     | Rule
     | Ind
     | Rel
     | degree
     | Skolem
     | weak
     | RuleML
     | Var
     | act
     | formula_5)*
  }
_1 =
  element * {
    text
    & (attribute * { text }
       | _1)*
  }
_2 = element * { notAllowed }
after =
  element after {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    (Atom
     | And_2
     | Or_2
     | Negation
     | Naf
     | Neg
     | Equal
     | Time
     | Spatial
     | Interval)
  }
_3 = element * { notAllowed }
Fun =
  element Fun {
    text
    & (attribute val { xsd:NMTOKEN "1" | xsd:NMTOKEN "0.." }?,
       attribute xml:id { xsd:NCName }?,
       attribute xml:base { xsd:anyURI }?,
       attribute keyref {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute key {
         xsd:string {
           minLength = "1"
           pattern =
             "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
         }
         | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
       }?,
       attribute node { xsd:anyURI }?,
       attribute per {
         xsd:NMTOKEN "open" | xsd:NMTOKEN "value" | xsd:NMTOKEN "copy"
       }?,
       attribute iri { xsd:anyURI }?)
  }
_4 = element * { notAllowed }
op_2 =
  element op {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    Fun
  }
Plex_2 =
  element Plex {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    (arg
     | Ind
     | Data
     | Var
     | Skolem
     | Reify
     | Expr
     | Plex
     | Time
     | Spatial
     | Interval)*,
    repo?
  }
Plex_3 =
  element Plex {
    attribute xml:id { xsd:NCName }?,
    attribute xml:base { xsd:anyURI }?,
    attribute keyref {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute key {
      xsd:string {
        minLength = "1"
        pattern =
          "(([\i-[:]][\c-[:]]*)?:)?(/[^\s/][^\s]*|[^\s/][^\s]*|[^\s]?)"
      }
      | xsd:anyURI { pattern = "[\i-[:]][\c-[:]]+:.+" }
    }?,
    attribute node { xsd:anyURI }?,
    meta*,
    scope*,
    guard*,
    evaluation*,
    signature*,
    qualification*,
    quantification*,
    oid?,
    slot*,
    resl?
  }
_5 =
  element * - (Ind
               | Rel
               | Rule
               | Equivalent
               | Reify
               | formula
               | Var
               | act
               | RuleML
               | weak
               | Skolem
               | degree
               | evaluation
               | meta
               | Query
               | Interval
               | scope
               | torso
               | Quantifier
               | slot
               | do
               | left
               | Equal
               | Rulebase
               | guard
               | oid
               | if
               | Atom
               | Time
               | Retract
               | declare
               | Profile
               | Spatial
               | quantification
               | op
               | resl
               | else
               | And
               | Entails
               | Negation
               | Or
               | then
               | Exists
               | strong
               | Forall
               | Plex
               | Fun
               | Naf
               | Assert
               | elseDo
               | Implies
               | signature
               | Expr
               | right
               | on
               | Neg
               | repo
               | qualification
               | arg
               | Data
               | after) {
    text
    & (attribute * { text }
       | _5
       | _2
       | Implies
       | Assert
       | Naf
       | after
       | Data
       | arg
       | qualification
       | repo
       | Neg
       | _3
       | Expr
       | right
       | signature
       | else
       | resl
       | op
       | Spatial
       | quantification
       | Profile
       | declare
       | Plex
       | Fun
       | Forall
       | strong
       | Exists
       | then
       | Or_2
       | Negation
       | Entails
       | And_2
       | torso
       | Interval
       | scope
       | Query
       | meta
       | evaluation
       | Retract
       | Time
       | Atom
       | guard
       | oid
       | if
       | Rulebase
       | Equal
       | _4
       | left
       | slot
       | Quantifier
       | Reify
       | Equivalent
       | Rule
       | Ind
       | Rel
       | degree
       | Skolem
       | weak
       | RuleML
       | Var
       | act
       | formula_5)*
  }
_6 =
  element * - (Ind
               | Rel
               | Rule
               | Equivalent
               | Reify
               | formula
               | Var
               | act
               | RuleML
               | weak
               | Skolem
               | degree
               | evaluation
               | meta
               | Query
               | Interval
               | scope
               | torso
               | Quantifier
               | slot
               | do
               | left
               | Equal
               | Rulebase
               | guard
               | oid
               | if
               | Atom
               | Time
               | Retract
               | declare
               | Profile
               | Spatial
               | quantification
               | op
               | resl
               | else
               | And
               | Entails
               | Negation
               | Or
               | then
               | Exists
               | strong
               | Forall
               | Plex
               | Fun
               | Naf
               | Assert
               | elseDo
               | Implies
               | signature
               | Expr
               | right
               | on
               | Neg
               | repo
               | qualification
               | arg
               | Data
               | after) {
    text
    & (attribute * { text }
       | _6
       | _2
       | Implies
       | Assert
       | Naf
       | after
       | Data
       | arg
       | qualification
       | repo
       | Neg
       | _3
       | Expr
       | right
       | signature
       | else
       | resl
       | op
       | Spatial
       | quantification
       | Profile
       | declare
       | Plex
       | Fun
       | Forall
       | strong
       | Exists
       | then
       | Or_2
       | Negation
       | Entails
       | And_2
       | torso
       | Interval
       | scope
       | Query
       | meta
       | evaluation
       | Retract
       | Time
       | Atom
       | guard
       | oid
       | if
       | Rulebase
       | Equal
       | _4
       | left
       | slot
       | Quantifier
       | Reify
       | Equivalent
       | Rule
       | Ind
       | Rel
       | degree
       | Skolem
       | weak
       | RuleML
       | Var
       | act
       | formula_5)*
  }
_7 =
  element * - (Ind
               | Rel
               | Rule
               | Equivalent
               | Reify
               | formula
               | Var
               | act
               | RuleML
               | weak
               | Skolem
               | degree
               | evaluation
               | meta
               | Query
               | Interval
               | scope
               | torso
               | Quantifier
               | slot
               | do
               | left
               | Equal
               | Rulebase
               | guard
               | oid
               | if
               | Atom
               | Time
               | Retract
               | declare
               | Profile
               | Spatial
               | quantification
               | op
               | resl
               | else
               | And
               | Entails
               | Negation
               | Or
               | then
               | Exists
               | strong
               | Forall
               | Plex
               | Fun
               | Naf
               | Assert
               | elseDo
               | Implies
               | signature
               | Expr
               | right
               | on
               | Neg
               | repo
               | qualification
               | arg
               | Data
               | after) {
    text
    & (attribute * { text }
       | _7
       | _2
       | Implies
       | Assert
       | Naf
       | after
       | Data
       | arg
       | qualification
       | repo
       | Neg
       | _3
       | Expr
       | right
       | signature
       | else
       | resl
       | op
       | Spatial
       | quantification
       | Profile
       | declare
       | Plex
       | Fun
       | Forall
       | strong
       | Exists
       | then
       | Or_2
       | Negation
       | Entails
       | And_2
       | torso
       | Interval
       | scope
       | Query
       | meta
       | evaluation
       | Retract
       | Time
       | Atom
       | guard
       | oid
       | if
       | Rulebase
       | Equal
       | _4
       | left
       | slot
       | Quantifier
       | Reify
       | Equivalent
       | Rule
       | Ind
       | Rel
       | degree
       | Skolem
       | weak
       | RuleML
       | Var
       | act
       | formula_5)*
  }
_8 =
  element * - (Ind
               | Rel
               | Rule
               | Equivalent
               | Reify
               | formula
               | Var
               | act
               | RuleML
               | weak
               | Skolem
               | degree
               | evaluation
               | meta
               | Query
               | Interval
               | scope
               | torso
               | Quantifier
               | slot
               | do
               | left
               | Equal
               | Rulebase
               | guard
               | oid
               | if
               | Atom
               | Time
               | Retract
               | declare
               | Profile
               | Spatial
               | quantification
               | op
               | resl
               | else
               | And
               | Entails
               | Negation
               | Or
               | then
               | Exists
               | strong
               | Forall
               | Plex
               | Fun
               | Naf
               | Assert
               | elseDo
               | Implies
               | signature
               | Expr
               | right
               | on
               | Neg
               | repo
               | qualification
               | arg
               | Data
               | after) {
    text
    & (attribute * { text }
       | _8
       | _2
       | Implies
       | Assert
       | Naf
       | after
       | Data
       | arg
       | qualification
       | repo
       | Neg
       | _3
       | Expr
       | right
       | signature
       | else
       | resl
       | op
       | Spatial
       | quantification
       | Profile
       | declare
       | Plex
       | Fun
       | Forall
       | strong
       | Exists
       | then
       | Or_2
       | Negation
       | Entails
       | And_2
       | torso
       | Interval
       | scope
       | Query
       | meta
       | evaluation
       | Retract
       | Time
       | Atom
       | guard
       | oid
       | if
       | Rulebase
       | Equal
       | _4
       | left
       | slot
       | Quantifier
       | Reify
       | Equivalent
       | Rule
       | Ind
       | Rel
       | degree
       | Skolem
       | weak
       | RuleML
       | Var
       | act
       | formula_5)*
  }
